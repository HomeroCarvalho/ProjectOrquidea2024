[Justificativa da documentação-diário]:
	-----> em projetos anteriores, quando se empacava num trecho do codigo, para retomar depois, ficava-se perdido
	e a moral ficava muito baixo, a ponto de desistir do projeto. com as anotações, não só do product backlog, mas
	a trilha de testes, mudanças aprovadas, e pausa deixado ante uma falha que desnorteia, e a solução ocorrida
	na distanciação do codigo, ajudam e muito a continuar o projeto. foi esta a análise e estratégia adotado.


[Codificacao com a linguagem orientada a objetos orquidea]:
[Instrucoes]:
			----> sempre coloque um ponto-e-virgula após instruções: for, while, casesOfUse, if/else (estruturas com else, não precisa colocar);
			o compilador é bem chato, se não colocar, não compila a próxima instrução após a instrução sem o ponto-e-virgula;

			----> o compilador também é bem chatinho na definição de double e int: em operadores aritmeticos, se não diferenciar um double com operador dot, como "x=1.0",
			não compila para "x=1". Há uma conversão implicita, mas para parametros e validação de chamadas de função/método. 

			----> parametros de função: tipos [int],[double],[string], a passagem como parâmetro de uma função, É POR VALOR: o que significa: é um jargão de linguagens
			de programção. O compilador cria uma cópia do parâmetro, o que impede que modificações ocorridas dentro da função não serão passadas para a variável-parâmetro,
			fora da função. Demais tipos, a passagém é POR REFERÊNCIA, se houver modificação dentros da função, será repassado para a váriave-parâmetro fora da função.

			----> para verificar se um objeto é nulo, chamar a função estática: Objeto.isNILL(objeto);

		
			----> todos objetos instanciados são private, a menos que estão no escopo mais externo, o escopo global, onde são public (vistos dentro dos metodos da classe).
			objetos instanciados dentro de metodos de classe, são private, ou seja é visível apenas no escopo do corpo do metodo onde está,


			----> ao criar bibliotecas importadas, tem que herdar [Objeto], e para cada propriedade,chamar
			a funcao [SetPropriedade(nomePropriedade, nomeClassePropriedade, valor)], para setar uma propriedade;
			para obter a propriedade, chamar a funcao [valor= Objeto.GetValuePropriedade], se quiser
			implementar GETTERS/SETTERS, codificar com estas funções para GETTER/SETTER.
					[NAO ESQUECER]:	
					-----> toda classe importada, deve herdar de [Objeto], e o campo [Objeto.valor=this],
					importante para o processamento da linguagem orquidea.

					-----> para acessar propriedades instanciadas com [Objeto.SetPropriedade],
					vai ter que chamar no codigo do programa VM, a função [Objet.GetValuePropriedade(nomePropriedade)].
					É ISSO, ou vai ter que criar no codigo da classe importada, GETTERs/SETTErs para cada propriedade
					instanciada.

			-----> é possivel acessar propriedades de um objeto, com funcoes de [Objeto.getPropriedade]. isto
			poupa a construção de GETTERs/SETTERS importados, obtendo, setando valores via codigo orquidea.

			-----> propriedades no estilo [Javascript], ou [Python]: se chamar um [Objeto.Set(nomePropriedade,classePropriedade,valor)], tendo
			como objeto caller o objeto [actual], criará uma propriedade, sem especificar no codigo da classe, esta propriedade! É como o [this] em Javascript, [self] em Python.
			e não foi porque se planejou, mas descoberto quando se focou em [Objeto].

	
			-----> ao codificar uma classe orquidea, para cada definição de método, terminar com um ponto-e-virgula, ";".
			isto é essencial para compilar. para cada definição de propriedade, termine também com um ponto-e-virgula, ";".


			-----> para guardar: castings entre objetos (int, double, float, string, char), usar a classe [Castings]!

			-----> CUIDADO com codificação de classes: se após a definição de classe não haver um ponto-e-virgula,
			o compilador nao compila, porque depois deste ponto-e-virgula, pode haver codigo fora de classes!


			-----> instrucao [importer]: a sintaxe é importer {pathDaBiblioteca.dll ou .exe};

			-----> sistema de erros por linha de codigo, regras: 
						----> declaração de nome de classe em 1 linha;
						----> início e finalização de classe (operadores { e }), em 1 linha para cada operador;
						----> declaração de 1 metodo, em 1 linha;
						----> declaração de blocos, em 1 linha cada (operadores { e });
						----> declaração de inicialização e finalização de 1 metodos (operadores { e }, em 1 linha para cada operador;
						----> linhas vazias livremente;
						----> linhas de comentários livremente;
						----> contagem de linhas vazias e linhas com comentários, feito em [ParserAFile];
						----> linhas de importação de bibliotecas, modulos, 1 linha cada;
						----> modulos, conteudo: linhas de codigo, linhas vazio, linha de comentario, como se fosse um programa proprio;
					
			 -----> variaveis estaticas são invocado com o nome da classe, como: Ship.count.

			 -----> propriedades podem ter valor atribuido na definicao, mas há que se ter cuidado: se as variaveis ou valores
			 não puderem ser avaliados, resultará em null. pode com variaveis com valor, operadores sobre estas variaveis, e 
			 principalmente de variaveis que já foi compilada: se não foi compilada, resultara em erro, ou no caso valor=null.



[Anotação]: analise de diferencial:
			-----> linguagem de programação orientada a objetos
			-----> interpretador Prolog
			-----> Wrappers 
			-----> sistema de bibliotecas da Linguagem Base, via API Reflexão.
	

PRODUTO BACKLOG:


[falhas detectadas  a corrigir]:
			----> operações aritimeticas com operador unario ++,--;
							-----> funcional para instrução [for].

			----> if/else com varias condicoes, validado nos testes unitarios, mas falha em programas testes;
			----> parametros string com constante+funcaoString(), não funcionando;


[gravar um jogo compilado](PARA UMA PROXIMA MANUTENCAO DO PROJETO):

			----> precisa gravar cada insturução:
						----> cada instrucao tem uma lista de expressoes, que podem ser instanciadas com seus tokens.
						expandir o codigo de cada tipo de instrução, para instanciar com um grupo de tokesn, SE POSSIVEL.
						----> cada instrucao tem tambem um conjunto de blocos de instruções, processadas recursivamente para cada instrucao.



[RESOLUÇÃO SEM PRIORIDADE, MAS...]:
			----> (x) todos objetos estão sendo instanciados como [public]!, é um caos, visando corrigir um problema de acessor "private";
			em [Create()], os objetos são instanciado então [public], o que significa que não há barreiras de escopos! Parece Javascript,
			com objetos [var]. Para contornar, se não me falha a memória, toda vez que se termina o processamento de uma classe,
			o Escopo.classeCurrent="" (podia ser um nome, como global), e se o escopo for esta classe [global], e o objeto tiver como "private",
			torna-se público, na instanciação do objeto. cuidar também da instanciação DAS PROPRIEDADES ANINHADAS, em [ExpressaoPorClassficacao],
			e fazer uma varredura nesta classe, da palavra "private" (com as aspas incluido). 
					----> (x) melhor solução:
								Há um código específico para tratamento de objetos "private" fora de sua classe de instanciação.
								incluir apenas esta condição, se for "private",	mas a classe Currente não for a classe de instanciação, E NEM a classe global (o nome dado agora para fora de todas classes),
								gera um erro, do contrario torna o objeto como [public], setando seu acessor.

			
[Especificidades da linguagem orquidea]:
			----> qualquer comando estruturado deve terminar com um ponto-e-virgula: instanciacoes, for, if/else,while, casesOfUse, expressoes;
									-----> instrução else não precisa de ponto-e-virgula: if (){blocoIf} else {blocoElse};
									
			----> se nao especificar, um parametro passado para uma funcao é por referencia: se modificar no corpo da função, o valor do parâmetro também muda.
									-----> para passagem por valor, codificar o parametro com :r (read only), como funcaoB(:r int a); [a] é um parametro passado por valor.



			----> (VERIFICANDO. creio que com a lista de Assembly de bibliotecas, resolva) se tiver que importar uma classe de uma Library em .DLL, vai ter que incluir no projeto uma referencia de projeto para a library em .DLL.
			tomando este cuidado, as classes da Library em .DLL poderão ser utilizadas normalmente...

			----> parametros para uma funcao pode ser um objeto (como do tipo "int"), ou uma expressao mais complexa (como x+1),
			o compilador acha o metodo mais adequado de acordo com o tipo da expressão, e o metodo.ExecuteAMethod()
			faz a avaliação de cada parâmetro!..

			-----> bibliotecas externa podem ser carregadas com a instrução [importer (nameAssembly.dll/exe)].
			importará todas classes da biblioteca.

			------> TODOS objetos da linguagem orquidea tem que descender de [Objeto], porque o código
			somente trabalha com [Objeto.valor].


			----> SOBRE CLASSES IMPORTADAS:
						-----> como o nome diz, são bibliotecas, e mais, são bibliotecas de funções! não há problema ter propriedades nas bibliotecas,
						mas tem por GETTERS/SETTERS! Porque o compilador tem dificuldades de fazer castings, sobre objetos importados.
						-----> Então, BIBLIOTECAS são BIBLIOTECAS DE FUNÇÕES..
						-----> nao esquecer que ao construir bibliotecas, tem que ter SEMPRE UM CONSTRUTOR sem parametros!
						-----> funções GETTERS e SETTERS estão operacionais: trabalha com objeto [actual].								
			-----> LISTA DE CLASSES DE BIBLIOTECAS, carregadas em [ImportadorDeClasses], e estão em uma lista estática em [LinguagemOrquidea.libraries].

			
		
			[CLARIFICAÇÃO]:
					-----> (constatação) AHHH, AGORA ENTENDI: tudo no codigo orquidea é feito por escopos. e tudo no codigo importado
					é feito por lista de object! uma função orquidea manipula variaveis, chamadas de funções, dentro de um escopos
					que é o código que guarda o contexto!
									-----> fascinado pela possibilidade de extender o codigo atraves da API de Reflexão da 
									Linguagem Base C Sharp, não se focou na manipulação de [Objeto], e pelo [Escopo].
									A bem da verdade é que não se deu foco no codigo orquidea, por causa da dita fascinação reflexiva...
			
					----> (constatação) AAAAHHH, ENTENDI: a classe [Objeto] é o [object] do orquidea! castings podem ser implementados
					quando se seta o [Objeto.valor]! E NÃO é só isso: [Objeto] possui propriedades, que podem ser implementadas
					para qualquer tipo de dado, que passará na execução de expressao base e pelo sistema de chamadas de metodo.!
							(x) e tem mais: escrevendo codigo orquidea, o Objeto não aparece, apenas defina o tipo, como "int", e o codigo
							faz por baixo dos panos, o processaomento por [Objeto].

					-----> (constatacao e insight): classes importadas devem derivar de [Objeto]:
					o compilador só entende de objetos do tipo [Objeto], mas [Objeto] tem um campo, [Objeto.valor],
					que pode conter qualquer tipo de objeto, seja importado ou não. [Objeto.propriedades],
					contem campos da classe que se quer importar. O que se descobriu é que fazer o casting tardio
					em ((instanciaDaClasseCurrente=ClasseCurrente)this.valor), tem acesso a todas propriedades modificadas
					em funções sobre a instancia de classe... o pesadelo do casting se resolveu...
					
					
					------> GUARDAR BEM: TODOS OBJETOS E EXPRESSOES TEM QUE SER ATUALIZADAS COM DADO DOS ESCOPOS. porque o objeto quando compilado não há valor. o valor
					é criado na instanciação em tempo de execução.
					----->GUARDAR BEM: TODOS OBJETOS E EXPRESSOES TEM QUE SER ATUALIZADAS COM DADO DOS ESCOPOS. porque o objeto quando compilado não há valor. o valor
					é criado na instanciação em tempo de execução.
					----->GUARDAR BEM: O OBJETO [ACTUAL] REPRESENTA UM OBJETO TOTAL, NÃO PROPRIEDADES, ENTÃO AO criar objetos, tem que 
					inserir na lista de propriedades do [actual].

					------ GUARDAR BEM: atribuir obj1.valor= obj1 SOMENTE PARA OBJETOS ORQUIDEA!
					------ GUARDAR BEM TAMBÉM: sempre atualiza os objetos quando se executar um metodo: parametros são atualizados,
				e objeto caller e actual também


			[MELHORIAS NO MODO DE PROGRAMAR]:
					A PROCURA DE TECNICAS DE OTIMIZAÇÃO DE MENOR ESFORÇO QUANDO CODIFICAR: construção de um caso de uso por vez, testes unitarios apos um caso de uso, nomeação de propriedades, funções
					que não precise parar para pensar, e...? escrever menos código é melhor porque concentra e reduz a quantidade de erros.


			1.0 - [EvalExpression.Eval()]:
					----> (x) NAO ESQUECER! para expressao de atribuicao, setar o valor do objeto caller (obj.valor=resultFuncao),
			mas se o objeto caller for um WrapperData Object, tem que haver O REARRANJO do obect valor, para A ESTRUTURA INTERNA
			DO WRAPPER OBJECT! Codificar em WrapperData.SetValor(Objeto objCaller, object valor), que passa para o WRAPPERDATA especifico,o 
			REARRANJO INTERNO DO objeto caller...


			1.0.0.  ----> (x) CRIADO em [GameLibrary], o kit de desenvolvedor, que importa classes, e sinaliza
			como classes importadas, possibilitando a instanciação de objetos de classes importadas.

			1.0.1	----> (x) [Metodo.ExecuteAMethod()]: antes da chamada da execução da função, guardar os objetos do escopo
			do metodo, e depois de voltar da execução, restaurar os objetos guardados. por que? porque pode haver uma
			chamada recursiva, ou chamada a outros metodos, que pode comprometer a integridade dos objetos da sessao
			currente da execução do métedo...

			1.0.2   ----> (x)[EvalExpression.Eval()]: criar cenarios de testes para funções na linguagem orquidea, 
			não funções importadas. Não foi testado, porque o foco não era em [Objeto], mas [funcoes importadas da linguagem base].
			foi testado em pequenos programas, em [ProcessamentoDeInstrucoes][Instrucoes];

			1.0.4  -----> (x) CRIANDO UM EXECUTÁVEL DE UM PROGRAMA VM ORQUIDEA!
						-----> criar o programa orquidea em texto;
						-----> criar um novo projeto, com NET 7;
						-----> importar a .dll do projeto ProjetoOrquidea2023;
						-----> na raiz do projeto, chamar a função ParserFile("nome do arquivo do programa orquidea");
						-----> se não me falhe, isso já executará o programa, talvez tenha um passo a mais: ParserFile.Run();
						-----> salve o projeto. quando rodar o .exe, executará o programa vm orquidea do texto!

			1.0.5    
					----> (x)[Escopos]:
							1- (x) EscopoROOT;
							2- EscopoClasse (lista de propriedades objeto caller);
							3- (x) EscopoSessaoDoMetodo;
							4- (x) EscopoParametros;
							-----> (x) adicionar em [EscopoROOT], todas propriedades estáticas públicas do codigo orquidea.		
					
							construcao de escopos:
									----> (x) EscopoSessaoMetodo= EscopoROOT+EscopoClasse+EscopoVariaveisFuncao+EscoposParametros.
											(x) EscopoROOT: escopo primeiro, contém as variaveis fora das classes;
											(x) EscopoClasse: escopo contendo nome de propriedades, nomes de metodos,operadores...
											(x) EscopoVariaveisFuncao: escopo contendo as variaveis do corpo da funcao;
											(x) EscopoParametros: escopo contendo objetos que são parâmetros da funcao (talvez precise
															  calcular também a lista de objects, para SETAR O VALOR);
															
							
							-----> Escopos são utillizados para controle interno de processamento de funções com instruções em seu corpo, guarda
								  nomes e valores de objetos, variaveis (classes de base orquidea);

			1.1 - ATENÇÃO: TODAS CLASSES TEM QUE TER PELO MENOS UM CONSTRUTOR! Se nao tiver, a classe nao compila,
			e (x) entra em loop infinito!


			1.2 - (x) NOVA IDEIA QUE ENGLOBA TUDO QUE É SEQUENCIAS ID: o que  não é expressão, é comando de programacao
			estruturada! o motor de processamento de expressão agora trata de todas expressoes: chamadas de metodo,
			atribuicao, instanciacao de objeto, propriedades aninhadas, wrappers object getElement/setElement/create,
			numeros, literais, etc..
			
			
			1- (x) processamento muito lento e instaveis quando extender, de ExpressaoGrupo: há casos como busca por função da classe currente,
			que precisa ser feito a todos tokens de Expressao/programa orquidea! Uma ideia recente é implementar um classificador de tokens,
			facilitando a obtenção de tokens de ExpressaoGrupo... esta ideia vem da teoria classica de compiladores, e por que nao posso implementar, ao jeito proprio?...

			2- (x) simplificar os escopos: escopo global, escopo da classe (se for um Objeto, bastaria colocar suas
			propriedades,seus campos, no escopo corrente, e depois atualizado o objeto e retirada dos campos do escopo currente,
			tendo o cuidado de varias chamadas de metodo, listar apenas as ultimas entradas de campos no escopo currente),
			escopo de função, escopos de blocos;
						2-1: (x) TODOS ESCOPOS TEM QUE TER UM NOME! PARA FACILITAR A NAVEGAÇÃO DE ESCOPOS: nomes de classes, nomes de funcoes, nomes de blocos, nome global (escopo raiz);
			
				
			
			3- (x) shortcut em if: se um OR resultar em true, caminhar até o proximo AND; se um AND resultar em false, caminhar até o próximo OR.
			
					
			
			4- (x) classe VECTOR: pode extender para chamadas de função para utilização de campos, propriedades;
			coisas como  vetores[i].X= 15, seria possivel.
						----> funcionalidade fácil! em GetElement/SetElement, incluir a uma verificação se o próximo
						token é o operador dot; se for, INSERE UM OBJETO TEMPORARIO, COM copia de referencia, no GetElement, e uma nova instrucao
						que chama a funcao apos o operador dot, e uma instrução de atualizar o elemento que chamou a função/propriedade.
						Isso faz o pre-processamento, a malha de tokens em [ExpressaoPorClassificacao]
						faz o processamento da 3 instruções, a do objeto temporario, e do objeto temporario chamando a chamada de metodo.
						PODE SER PRECISO ATRIBUIR O objeto temporario ao objeto vetor.
						------> todas classes [WrapperData objects] possibilita a extensão! mas por enquanto retorna um dado,
						não atualiza o elemento do wrapper que invocar a função extendida. e para funções GETTER/SETTER da classe
						do tipo de elemento, e mesmo o SETTER não está operacional, por modificações colaterais com falha resultantes.
						------> nao foi percebido porque não estava claro a retirada de tokens das funções [GetElement],
						e o não saneamento de expressões chamada de metodo seguida de chamadas de metodo! 

			
			5- ( ) Uma biblioteca para programação de jogos: imagem, janelas, controle de teclado,mouse, etc...
						-----> em implementacao.
						-----> resumo:
									-----> com a construção de vetores de classe orquidea, estará pronto para testes
									com pequenos esboços de jogos, parado justamente por falhas não detectadas
									na lista de erros, no escopo. com a lista de errros estática, foi possível verificar
									os erros no código de esboços de jogos.


			6- (x) deixar como objeto orquidea, a classe Expressao, permitindo algo como [Vector1[Expressao].Run;
			isto permitirá o acesso ao pipeline da janela de jogo...
						-----> classe [ExpressionBase] codificada;.

			7- ( ) mais funções strings, e matemática: lista extensiva pesquisada, acrescentar às classes string,
			e double, estas funções. A lista contém 35 funções mais utilizadas em linguagens de programação.
						------> (x) lista de funções strings, quase completamente implementada.

			8- ( ) criaçao de pequenos jogos, como testes/correção da biblioteca para desenvolvimento de jogos.
						-----> jogo hello world! de um jogo que imprime na tela, textos como: atualizando, desenhando, feito 
						e em arquivo externo de programaVM, feito.
						-----> jogos com vetores, mouse, teclado, feitos, mas falhas no processamento do objeto [actual],
						forçou a uma volta ao processamento de funções orquidea e funções importadas, passando 
						por construtores, e modificações em [ExpressaoPorClassficacao];
						
						
			9- (x) FOCAR EM Objeto classe, e não em wrapper data, ou tipos nativos, como int, ou string... são Objeto também,
			mas as funcionalidade tem que ser em classes orquidea...
			
			10- ( ) criar classes de integração entre a linguagem orquidea, e os interpretadores LISP, Prolog, do projeto.

			11- SEM PRIORIDADE:
					[codigo unsafe]: unsafe permite o uso de ponteiros, e a tradução é de *propriedade, para &propriedade,
					permitindo o casting automático, por referência!!!



funcionalidades menores:
			
			-----> OPERADORES:
						-----> o primeiro operador terciário orquidea: faixa de comparações! 5<x<8. vai ser preciso
								analisar a condição terciária do operador, dentro do sistema de operadores, em ExpressaoGrupos.
								uma faixa de comparações é comum em anotação matemática (inequações), creio ser uma boa proposta a ser relevado...
						-----> operadores binarios OR,AND, para manipulação bit-a-bit; operador unario NOT para manipulação bit-a-bit também.
										----> operador terciario deve começar com um simbolo que identifique o operador,
										ex.: "!<a<b", "!<" é um identificador valido. Pode-se extender além, o simbolo "!" pode
										ser o começo da identificação para todos operadores terciarios!
						
			-----> nova instrucao: uses "nomeClasse", permite acesso a variaveis e funções desta classe
			sem utilização de objetos caller! resolvido uma questão: chamada de funções, que precisava anteriormente
			de um objeto caller para procura de qual classe a função está implementada! Muito legal!
			
			-----> (x) inicialização de Vector com valores constantes, ou determinado em tempo de compilação.
			uma notação é que a inicilização de arrays não é somente propriedade do javascript,
			há também em C++, C sharp, Phyton. Como as funções-parâmetro também não é propriedade do javascript,
			há em C/C++ (protótipo de funções), em C sharp (delegate), e é um conceito presente em muitas linguagens de programação.
						-----> (x) inicializacao também é possivel também com expressoes-valor! 
			
			-----> (x) classe [Vector] com uma funcao Sort() (Ordenacao), com valor de texto, em [Objeto.hashText].
			-----> (x) classe [Objeto], com nova propriedade, [hashText], utilizada para fins de ordenação.
		
		
			
			-----> (x) classe Objeto:			
			é possível adicionar/remover propriedades de um Objeto! () E tb de WrapperData,
			que é classe derivada de Objeto.
			
		
			-----> "e:textoExpressao", permite insercao facil de codigo de expressoes,
			como texto de codigo de expressao, nao como string;
					
			-----> modificar o Vector Wrapper, para ter elementos nao [object] mas sim [Objeto], que possibilitara coisas como v[i].x=1, [x] uma propriedade de elemento de [Vector].
			são será preciso adicionar a funcionalidade wrapper: GetProperty(),SetProperty(), descritos no Product Backlog.
							------> TALVEZ SEJA PRECISO modificar os wrapper objects para editar os tokens da expressao,
							em vez de construir uma chamada de metodo. isso porque com os tokens da chamada de metodo
							obtido, pode-se incluir mais sub-expressoes, como propriedade aninhada, sob a expressao principal.
	
			
			-----> (x) IMPLEMENTAR UM POOL DE OBETOS ESTATICOS:
			Para manter a integridade de objetos estaticos, que podem ter dados parametros de processamento na sua classe,
			CRIAR uma lista de objetos estáticos instanciados. Se precisar de um objeto estatico, obter desta lista! Mantem
			a integridade da classe do objeto estatico! Vamos supor que nesta classe de objetos estáticos, haja listas de objetos estaticos
			de controle interno. Se você instanciar o objeto estatico toda vez que utilizar para uma chamada de metodo,
			p.ex., perde-se estas listas de objetos estaticos do objeto estatico. fica resetado, perdendo todos dados previamente processaados.



			(NUMA PROXIMA MANUTENCAO, NAO AGORA, ABRO MAO DISSO)[Metodo]:
					-----> terminar a construcao de chamadas de FUNCAO: sem objeto caller oficial, um objeto caller artificial
		para poder ser chamada como um metodo. 
								------> validação de parametros. se isFunction=true, obtem do objeto os parametros, com o casting (Metodo)objeto;
								------> todas funcoes são publicas, e o escopo é o global. terminando a programação funcional.
											------> extração em fileHeader está sendo feita, mas o processamento está por terminar.
								------> por que as funções não foram implementadas, apenas metodos?
											------> porque uma função não tem um objetocaller! então se inserirmos um objeto caller,
											chamando a função, internamente, a função é possível!


[Sistema de localização de linhas de codigo falhas]:	
			O Sistema está espalhado pelo codigo, 
					Presentes nas Classes:
						-----> ParserAFile: comentarios, linhas vazias, linhas de codigo;
						-----> ExtratoresOO: inserção de linhas a cada constituinte de classe: nome da classe;
						delimitadores de corpoo de classe, +! nomeDeFuncao,+2 dos delimitadores do corpo da classe;
						-----> UtilTokens: notifica as mensagns de erro, utilizando o sistema de linhas com falhas;

					Variaveis:
					-----> variavel ProcessadorIDs.lineCompilation: guarda a linha currente sendo compilada.
								-----> presente em:
											-----> ParserAFile;
											-----> UtilTokens (funcao WriteAErrrorMessage);
											-----> ExtratoresOO (no construtor, e na funcao ExtraiMetodos,
											e na funcao ExtraiPropriedades, e funcao ExtraiOperadores);
					

_________________________________________________________________________________________________________________________________________________________________________________________________
[PROXIMA MANUTENCAO ADITIVA]:		
		-----> planejamento de sistema de compilação rápida: por arquivo compilado, contendo objetos, expressoes, instruções, e codigo de classes (propriedades, metodos, operadores);
							------> apos lançar esta versao, uma nova atualização aditiva, entrará esta funcionalidade.
		-----> um recurso não visto: utilizações de funções, não métodos. para uma linguagem orientada a objeto,
		é complementado com métodos, mas faz uma falta... (função não precisa de muitos escopos, é mais direto).
				
				[Funcoes]:
					-----> é possível, mas dentro de uma classe! funções são previstas em [ExpressaoPorClassficacao],
					como metodos sem objeto caller, o objeto caller é instanciado e adicionado a chamada da função,
					o programador não vê a adição, apenas chama a função.
		
					-----> se quiser, setar em ProcessadorID.InitMapeatmento, o codigo de ids para definição de uma
					função! com esta definição, uma handler que sete no escopo.funcoes, a função construida.
					para chamar a função, setar um objeto estatico.


					
Tempo: estimativa +2 meses, sem prioridade, sendo feito em junto a projetos: jogo javascript, perspectiva visual;
		-----> estourou o prazo, ficando a estimativa recalculada, a partir de 28.05.
_______________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.12:

[ClassificadorDeTokens]:
	----> a ideia do Classificador de tokens é tornar mais rápido o processamento de tokens de Expressoes, p.ex.
	----> classificador está classificando elementos de classes de programa orquidea,e elementos de classes base da linguagem orquidea.
			----> (feito) feito as operacoes mais basicas do classificador, sem classificar nomes de objetos.
				um nome de objeto é um id que nao é nomeClasse, nomeFuncao, nomePropriedade, nem nomeOperador;
			----> (feito) codificar um metodo que obtem a classificacao de um token;
			----> (fixar): (feito, mas ainda com repeticoes)enxugar os nomes de elementos repetidos, como nomes de operadores, nomes de metodos, etc..
	----> extender o classificador, para reconhecer ids como parenteses, colchetes, operador matricial,...
	
	
			
	-----> quando implementar a classificação de tokens em ExpressaoGrupos, fazer como busca hash na procura de tokens! de O(n*m), onde n: numero de tokens do programa,
	e m o numero total de tokens, vai ser ~O(n*3), onde n: numero de tokens do programa! Quero ver algo mais rápido que isso...
_______________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.12:

[ClassificadorDeTokens]:
				----> lista de termos-chave, feito.
				----> classificacao de definicoes de classes, metodos, propriedades e operadores, feito anteriormente.
				----> classificacao de numeros feito.
				----> classificacao de literais-texto feito.

[ClassificadorDeTokens][TabbleHash]:
				----> função [hashNumber]: faltando calculo de caracteres que nao sao letras ou numeros.
				----> classficação com 3 primeiros caracteres, tolerância de x entradas (uma linha de hash, para colisoes) 
				de 3 caracteres iguais.
________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.12:

[ClassificadorDeTokens][TabbleHash]:
				-----> tabela com textos de hash feito;
				-----> funcoes de Read/Write token em hash table, feito.
								-----> funcao Write nao otimizada, mas O(n) (n numero de tokens registrados) porque é feito uma unica vez.
								-----> funcao Read otimizada com hash table, O(1) pelo mecanismo de hash. 
												----> teste inicial deu 2 entradas, correto, entao o desenpenho foi O(2)==> O(1).


__________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.12:

[ClassificadorDeTokens][TabbleHash]: 
				-----> o metodo Write hash table é feito uma unica vez: inserir todos tokens do classificador, em vez de inserir um token especifico.
  				 	   o token a procurar é resultadp de ReadHashTable. Rescrever o metodo Write hash table, para incluir todos elementos vindo do classificador de tokens.
					   a operação é O(n), onde n é o numero de tokens guardados no classificador.

[ExpressaoGrupos]:
				-----> (feito) levantamento de casos de uso para tokens de Expressao. Com dados do classificador, o processamento
				será mais rápido e mais tolerável a extensões.

(a fazer) [ClassificadorDeTokens]: 
				-----> resolver problemas de colisao em que o nome do token na tabela hash é diferente do nome do token fora da tabela.
				-----> resolver casos em que há mais de um tipo de token para um mesmo nome de token.
				-----> falha no carregamento da hash tabela de classficacao. no atual momento, somente buscas
				no classificador, sem a tabela hash, está operacional..
							----> (fixado) falha na classificacao do operador "{";
							----> (constatado) escrita de tokens na tabela hash, operacional.
							----> (insoluvel) colisoes de tokens do codigo, nao há somente pelo tipo do token, se tiver x vezes o token 
							será escrito x vezes na tabela hash!
										----> insoluvel, deixar para o que utiliza a tabela hash, a filtragem do tipo correto do token.

				-----> (constatado) na tabela hash, resolver casos de repeticao de um mesmo token.
				-----> (fixado) filtrar os resultados pelo nome do token, nao pelo nome constado na tabela: retorna valor para "class" e "classeA".

[ExpressaoPorClassificacao]:
				-----> (feito) primeiros casos de uso: numero, literal;
____________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.12 (perto do Natal):
		
[ClassificadorDeTokens]:
				-----> (feito) fixar as funcoes especificas para nomes de tokens (numero,literal,termo-chave, funcao, nome de classe, etc...);
				-----> (feito) codificado uma funcionalidade de classificar tokens que estão fora das definições de classe,
				afim de processo de classificar tokens que estão na parte de start do programa VM.

				-----> (fixado) o calculo do hash number, que estava gerando valores improprios, justamente porque faltou algum caracteres de operadores estruturais.								
____________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.12:

[Classificador]:
				-----> acrescentado o tipo do token, nao a classe a que o token pertence, mas seu tipo. 
[ExpressaoPorClassificacao]:
				-----> testes com expressao de um objeto, feito.
								----> fazer passo-a-passo, 1 caso de uso por vez, testes unitarios, e depois teste de integração.
				-----> casos de uso:
								----> (feito) propriedades aninhadas, com chamada de metodo aninhado a estas propriedades.
								----> (feito) propriedades aninhadas, com uma chamada de metodo aninhada;
													----> nao quebrou o codigo de propriedades aninhadas sem chamada de metodo;
													----> chamada de metodo está sendo registrada como propriedades aninhada!!!
																	----> tem que ser uma chamada recursiva, e nao está havendo...
								----> (fixado) confusão entre o codigo de definicoes de classes, com o codigo da expressao a ser avaliado.
								----> é preciso COMPILAR O CODIGO ANTES...
				----->  ESTÁ SEMPRE ASSIM: a ideia é boa, clara, no desenho maior, mas quando entra a logica de programação,
				as coisas se cumplicam! são muitos detalhes para cobrir, mesmo fazendo caso por caso, utilizando
				testes unitários.. mas tá melhor justamente porque os testes unitarios sao para cada
				caso, e nao testes por uma classe inteira, que era o padrão para se considerar como 1 teste unitario...

				-----> (feito) acrescentar em GetMethodCompatible, os outros tipos de parâmetros: multi-argumento, parametro-funcao, 
				wrappers object,etc...
								----> em UtilTokens.GetMethodCompatible, contem outros tipos de parametros, justamente
								neste caso do [ExpressaoPorClassificacao.GetMethodCompatible]
								----> implementado com a metodo UtilTokens.FindMethodCompatible(), que 
								não é gargalo na codificação...



 __________________________________________________________________________________________________________________________________________________________________________________________________________________
 Daily Scrum 25.12:

[ExpressaoPorClassificacao]:
	(x)	simplificação tremenda do processamento de propriedades aninhadas e chamadas de metodos, podendo fazer qualquer tipo de combinação com essas expressoes,
	e é feita num bloco somente, cortando linhas que seria para processamento em separado, de propriedades aninhadas, e chamadas de metodo.
	(x) codificado objetos com chamadas de metodo, com/sem propriedades aninhadas seguidas.
				(x) construir teste para chamadas de metodo.
							----> (x) feito a primeira parte: propriedadades aninhhadas, propriedades aninhadas seguida de
							chamada de metodo.
							----> (x) planejamento para chamadas de metodo seguidas proprieadades aninhadas, é possível
							vendo programas de outras linguagens orientada a objeto. é prática de POO.
							----> () construido a adição de chamada de metodo, em propriedade aninhada/outra chamada de metodo.
							

	(x) retirar o ValidaParametros(), para chamadas de metodo aninhado com propriedades aninhadas. Por quê? Porque esta função somente
analisa parametros normais, nao multi-argumento, parametros-funcao, wrappers objects,... e não É UTIL para o projeto.	


	(x) CONSTRUIR URGENTEMENTE O OBJETO APOS UMA CHAMADA DE METODO, PORQUE O OBJETO FORMADO PARA POSTERIOR PROCESSAMENTO
	É COM O TIPO DE RETORNO.

[ExpressaoPorClassificacao]:
				-----> casos coberto: 
						(x) literal;
						(x) numero;
						(x) objeto somente;
						(x) objetos nao estaticos com propriedades aninhadas;
						(x) objetos com propriedades aninhadas seguido chamadas de metodos aninhados. 
						(x) objetos nao estaticos com chamadas de metodo;
						(x) objetos com chamadas de metodo seguido de propriedades aninhadas.
						(x)	chamadas de metodo estático, propriedades estáticas.

	
____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.12:

[Objeto]:
		-----> funções da classe Objeto!
					------> (x) Objeto BuildCustomObjeto(string nomeDaClasse): verifica o repositorio de classes, e instancia um objeto com todas propriedades da classe.
					------> (x) void SetValueDefault(Objeto, proprerty): seta o valor default de property de Objeto: 0 para int, "" para string, 0.0 para double, 0.0f para float.
							funções que afetam o blue print de uma classe.	
					------> (x) void AddProperty(nameProperty, nameClass): adiciona uma propriedade para a classe do objeto.
					------> (x) void RemoveProperty(nameProperty, nameClass): remove uma proprriedade da classe parametro.
					------> (x) void AddFunction(Metodo fnc, nameClass): adiciona uma função para a classe parâmetro.
					------> (x) void RemoveFunction(Metodo,  nameClass): remove uma função da classe parâmetro.
					------> (x) campo hash: utilizado para ordenacao de listas de Objeto.
					----->  (x) funcao Sort(hash): ordenacao de lista de objeto, tendo como parametro o valor do campo hash dos objetos.
										----> ordenacoes possiveis: com data de construcao, por ordem de construcao, com tabela hash para obter hash a partir de textos, etc...
										----> inviável: o codigo orquidea nao tem acesso a List da linguagem base!
										pode-se tentar em vez de List, utilizar Vector, que há na linguagem orquidea.

[ExpressaoPorClassificacao]: Testes:
					------> (x) expressao chamada de metodo está adicionando a propria expressao chamada dentro de uma mesma expressao chamada. 
					------> (x) caso de chamada de metodo somente, feito.
					------> (x) Testes para chamada de metodo seguida de chamada de metodo.
					------> (x) Testes para chamada de metodo seguida de propriedade aninhada.
									----> (x) falha no teste: a propriedade aninhada nao está sendo incluida como continuacao da expressao chamada de metodo.
					------> (x) VALIDAR O OBJETO CALLER APOS UMA CHAMADA DE METODO SEGUIDA DE CHAMADA DE METODO.
									----> (x) validado quando se procura uma funcao compativel para a expressao chamada de metodo.


[ExpressaoPorClassificacao]: 

					------> (x) utilizar o [SetValueDefault] quando a referida instanciação, para setar um valor inicial.
					------> (x) nao esuecer quando instanciar um Objeto, chamar a [BuildCustomObjeto()], que voltará com todas propriedades da classe do Objeto.
					------> (x) quando instanciar uma expressao ChamadaDeMetodo, nao esquecer de instanciar um objeto com [BuildCustomObjeto],
					com a classe DO VALOR DE RETORNO DO METODO, é cruscial para chamdas de metodos e apos propriedades aninhadas...
					
[ExpressaoPorClassificacao]:
					------> casos:
								-----> funções sem objeto caller; (metodos da classe currente).
													----> compor como objeto [actual].
								-----> objeto [actual].
								-----> processamento de objetos wrapper (verificar se pode substituir os tokens em anotacao wrapper, pelos tokens de chamadas de metodo);
								-----> operadores! mesmo sistema de [ExpressaoGrupos]: processamento quando todas sub-expressoes forem construido.
								-----> operador igual (=): construção de Expressões de Atribuição. em processamento junto com demais operadores.
								-----> expressoes entre parenteses: isNextToken("("), como entrada deste tipo de expressao.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________									
Daily Scrum 27.12 (manhã):

[ExpressaoPorClassificacao]:
					------> casos:
								(x) funcoes sem objeto caller (metodos da classe currente).o objeto caller fica sendo o [actual].
								

					------> (x) verificar urgentemente as contagens de tokens utilizados, porque a malha de tokens é feita por for,
					que depois de continue, avança 1 unidade.
											-----> (x) contagem para expressao chamada de metodo, 
											verificar os demais casos, porque há metodos contando +1 sem previsão de correcao da malha de tokens.
											-----> (x) contagem para expressao propriedade aninhadas, feito.

											-----> (x) fixar no teste: [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]:
														----> (x) quebra no codigo! contagem feita de tokens está falhando.
														----> (x) fixar a funcao [classificador.isNameFunction(token, nameClass)].
																			----> retirado do projeto.
																			----> substituido pela leitura de header class.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.12 (tarde):

[ExpressaoPorClassificacao]:
					-----> (x) operadores: codificado a extração de dados de operadores.

					-----> revisar a contagem de tokens, para expressoes propriedade aninhada, e chamadas de metodo.
											-----> houve modificação no codigo que nao se conseguiu acompanhar conscientemente.
											os testes passaram.
															-----> (x) fixar propriedade aninhada seguida de propriedade aninhada, checado.
																				-----> propriedade aninhada seguida de propriedade aninhada, checado.
															-----> (x) chamada de metodo seguida de chamada de metodo, checado.
					-----> tornado mais explicito a logica de programação: contagem de tokens em funcao, conta
					exatamente o numero de tokens consumido, e não -1 do ajuste do processamento da malha de tokens,
					sendo feita externamente. o ajuste é necessário porque a malha de tokens não pode pular tokens,
					mesmo que seja após o último token.
															-----> ajuste na contagem de tokens, que conta somente os tokens,
															e não o ajuste por causa do incremento na malha.

[FileHeader]:
		-----> (x) verificar se a substituicao de classes, entre dois testes, está sendo feito, porque 
		está dando o mesmo erro quando testes de [ExpressaoGrupos].
					-----> se não me falhe a memória, classes iguais estão sem tratamento se forem exatamente iguais!

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.12 (manhã):

						
[ExpressaoPorClassificacao]:
		----->(x) quando adicionar expressao chamada de metodo e expressao propriedade aninhada, na expressao principal, retirar 1 unidade da malha de token.
		não falhou porque esta adição se dava como ultimo processamento de tokens. mas vai falhar se acrescentarmos algo além da adição destas expressoes,
		como p.ex., operadores. Retirando 1 unidade, corrige o problema. É preciso exatidão no processamento de tokens...
							----->(x)[VERIFICADO] retirada 1 unidade na malha de token, e não gerou erros colaterais. Mas para verificar a exatidão, 
							acompanhar o processamento de expressão ou chamada de método, ou propriedade aninhada, verificando qual o próximo token:
							se for ponto-e-vírgula, é porque a exatidão está cumprido.
											-----> (x - x) fixado quando em processamento de expressao chamada de metodo;
											-----> (x - x) fixado quando em processamento de expressao propriedades aninhadas.

							Testes que falharam:
							-----> (x) [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]
							-----> (x) [TesteChamadaDeMetodoSeguidaDePropriedadeAninhada]

[Expressao.InitHeaders()]:
		-----> (fixado) (x) testes de propriedades aninhadas seguido de propriedade aninhadas falhou, e a falha é real! 
		-----> (x) para resolver isso, verificar como se dá a substituicao de classes de nomes iguais, em [Expressao.InitHeaders].
			
		



[ExpressaoPorClassificacao]:
		
		-----> continuar os casos de tipo de expressao, como operadores, wrapper objects.
						-----> (feito) em wrappers objects, considerar UM PRE-PROCESSAMENTO, substituido a anotação wrapper, por tokens de chamada de metodos.
						fica claro que o mecanismo wrapper é mesmo um pré-processamento, e dá a possibilidade de extender as chamadas de metodos, como p.ex.,
						matriz[1,1].x, em anotacao wrapper, fica: matriz.GetElement(1,1).x, x é uma propriedade aninhada. não havia previsão para tal caso,
						porque achava-se que não há chamadas de metodo seguido de propriedades aninhadas...
									----> graças, os metodos Set/Get/Create já retornam a lista de tokens da chamada
									de metodo, e não uma expressao chamada de metodo. com isso, é
									possível reescrever o codigo de tratamento de wrappers object como um pre-processamento,
									inserindo tokens, que serão consumidos na malha principal de tokens.
						-----> com o preprocessamento, é possivel construir coisas como v[1].X=1, traduzido por v.GetElement(1).X...


Projeto:
		----> procurar por problemas enfrentrado, para criar funcoes e classes que resolva estes problemas (necessidade nao atendida),
		como p.ex., retirar tokens em uma lista, de tokens presentes tabem em outra lista...



[ExpressaoPorClassificacao][WrapperObjects]:
		-----> (x) feito o pré-processamento de wrappers object, 
			   a ser chamado antes da malha de tokens em [ExpressaoPorClassificacao.ProcessingExpression()];
									-----> (x) notações wrapper previstas: GET,SET element.
									-----> (x) wrapper objects: Vector, Matriz testes feitos. 
									-----> (x) wrapper object DictionaryText, precisa de reformulação, porque não há sinal de igual
									na notação para diferenciar uma chamada GET de SET.
												-----> (x) fixar os tokens da chamada de metodo SET para DictionaryText Wrapper.
									-----> (x) wrapper object JaggedArray;



[ExpressaoPorClassificacao][DictonaryText]:
		-----> (x) falha porque nao havia tokens para expressao literal! 
		
[ExpressaoPorClassificacao][Testes]:
		-----> o problema das classes iguais em diferentes cenarios de testes, está causando erros colaterais,
		que são resolvidos automaticamente.. VERIFICAR O Expression.InitHeaders().

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.12:

(x) [ExpressaoPorClassificacao][classe double e string]: (x) caso de que pode-se incluir o objeto caller como 1o.parametro.
(x)[ExpressaoPorClassificacao][ExpressaoEntreParenteses]: (x) caso de expressao entre parenteses.

(x)[ExpressaoPorClassificacao][operadores]:
		-----> (x) implementar o caso de ocorrencia de operadores.
		-----> (x) atos de sabotagem está falhando o resultado de alguns testes, quando se depura o teste, 
		o resuldado é que o teste passou.

(x)[ExpressaoPorClassificacao][ExpressaoAtribuicao]:
		-----> extraido de [ExpressaoGrupos], por estar estável e não causar gargalos de desempenho.
		-----> (x) testes.
______________________________________________________________________________________________________________________________________
Daily Scrum 01.01: 

(x)uma classe de configuração de inicialização do sistema de compilação! InitSystem.
			(x) funcionalidades:
				1- (x)isResetClassificador;    // quando [true] o sistema de classificador, deve ser resetados. Quando o classificador é resetado, setar esta variável para false;
											   // deve ser setado para [true], se o FileHeader, Em Expressao.InitHeader(), for resetado, ante a novas classes que são iguais entre cenários de testes diferente.
				2- (x)List<string> classesIncludeFirstParameter ; // classes que podem ter 1o. parametro como objeto caller. No atual condição, estas classes está dentro do processamento de Expressoes: ExpressaoGrupos, ExpressaoPorClassificacao,
															   // o que não é conviniente para expansões para outras classes novas com esta funcionalidade..
															   // atuais classes: double, string...
																
	
	
(x) (FIXADO!) Falha na logica de programacao em FileHeaders: para reconstrucao, tem que compilar os codigos da classa orquidea,
e então isso perde desempenho, porque está calculando as classes, de qualquer jeito.

		
				
(x)[ExpressaoPorClassificacao][ExpressaoAtribuicao]: verificar se há mais tipos de expressoes que compoem uma expressao
de atribuicao, como chamadas de metodo, wrapper objects,etc... (wrapper object possuem uma expressao de atrbuicao propria: SetElement);
											----> ATRIBUICAO DE UM WRAPPER OBJECT, NAO HAVIA PREVISAO.. 
											ATUALIZAR O EVALEXPRESSION.EVAL() PARA TRATAMENTO DE EXPRESSAO DE ATRIBUICAO COM WRAPPER OBJECT.

(x) [ExpressaoPorClassificacao]: o classificador precisa ser reinicializado quando o FileHeader é reinicializado! quando houver um reset em [FileHeader],
reset também em [ExpressaoPorClassificacao]. Para o tratamento de classes de nomes iguais em cenarios de testes diferentes,
pode causar um risco de erro. para execução de um programa VM, não se vê este gargalo.


()[WrapperObjects]:
		-----> (x) faltando um caso de expressao atribuição: atribuiçção de um wrapper object (nao um elemento de wrapper object)! O problema de casting aparentemente é resolvido.
				-----> uma funcao WRAPPERDATA: SetValor(object wrapperObject), para cada tipo de wrapper, e em EvalExpression(),
					   verificar se o objeto atribuir é um wrapper object (isWrapperObject=true), e então chamar esta função, e o casting está resolvido!
										-----> MODIFICAÇÃO de EvalExpression.Eval() incluida no PRODUCT BACKLOG.

		-----> (x) nao esquecer de setar o tipo da expressao Get/Set wrapper como o tipoElemento, e nao o tipo do wrapper.
										-----> (x) FIXAR no teste [TestePropridadesAninhadasSeguidasDeChamadaDeMetodo].
										-----> tentativa de melhorar desempenho do classificador, falha: o codigo precisa
										se inicializado apenas quando seu valor é null.

		-----> (x) verificar se deslocar a obtenção de WRAPPER DATA pode ser feito dentro da classe WRAPPER DATA,
			para facilitar quando se acrescentar mais tipos de Wrapper Object, sem ter que percorrer o codigo inteiro
			a procura de funcionalidade de Wrapper Data.
	



		-----> ( ) o processamento de criação de wrappers object estava fora do processamento de [ExpressaoGrupos],
		com [WrapperManager], que era um código que juntava GET/SET/CREATE de wrapper objects, de maneira ineficiente,
		que está causando gargalos de desempenho. no préprocessamento em [ExpressaoPorClassificacao], fica mais claro,
		menos gargalo, e poupa codigo. IMPLEMENTAR a funcionalidade pre-processamento CREATE de wrapper objects.
										-----> ( ) funcao WrapperData.Create precisa ser modificado para retornar os tokens processados.
															------> (x) pronto para codificar a lista de tokens processados, em todos
															Wrappers Object.


-----> ( ) VERIFICAR URGENTEMENTE SE parametros WrapperObject está sendo classificado como wrapper object, no [ClassificadorDeTokens].	


-----> (x) DESCOBERTO A PERDA DE DESEMPENHO: a cada instanciação de ProcessedOfIDs, os header são construidos. a cada metodo, cada operador, o header é reconstruido,
a cada bloco de instrução, o header é reconstruido. Por isso, classes com instruções em suas funções, diminui o desempenho e é um GARGALO, no PROCESSO de compilação.
										------> (x) A UNICA SOLUCAO É UMA FUNCAO QUE RESETA O HEADER, A CADA CENARIO DE TESTE. E ELIMINAR
									O CASO EM QUE OS HEADERS NÃO É NULO, EM Expression.InitHeaders().
															------> (x) confirmado é isso mesmo! no construtor de ProcessadorID,
															há uma chamada para [Expressao.InitHeaders]!

										-------> (x) implementar esta função em todos testes: Expressao, ExpressaoGrupos,
										ExpressaoPorClassificacao. e tambem no ParserFile classe.
															------> (x) ExpressaoPorClassificacao, implementado a função em todos testes.
															------> (x) Expressao, implementado a função em todos testes.
															------> (x) ExpressaoGrupos, implementado a função em todos testes.
																		-----> (x) melhora no desempenho dos cenarios de testes,
																		mesmo sem [Instrucao] no corpo das funções.

										-------> (x) implementar esta função nos testes de pequenos programas, em [Instrucao.Testes].

						

____________________________________________________________________________________________________________________________________________________________________________________________________________
Sem Prioridade:
		-----> novos operadores binario: OR,AND,XOR;  como operadores de bits, na classe int, bool;
		-----> novos operadores unarios: NOT;
____________________________________________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 02.01:

[Projeto][DESCOBERTO A PERDA DE DESEMPENHO]:
			----> (x) implementar em [Instrucao][PequenosProgramas], a função de SystemIni.
									-----> em pequenos programas, havia uma instrucao que fazia o mesmo..
			----> (x) implementar em [ParserFile],a função de SystemIni.


[WrapperData Objects]:
			-----> (x) implementar o processamento de tokens processados, no metodo [Create()], de todos wrapper datas.
							-----> em WrapperDataVector.CREATE(), implementado.
							-----> em WrapperDataJaggedArray.CREATE(), implementado.
							-----> em WrapperDataMatriz.CREATE(), implementado.
							-----> em WrapperDictionaryText.CREATE(), implementado


			-----> (x) testes de CREATE, em todos tipos de wrapper data.
							-----> em WrapperDataVector.CREATE(), testes feitos.
							-----> em WrapperDictionaryText.CREATE(), testes feitos.
							-----> em WrapperJaggedArray.CREATE(), testes feitos.
							-----> em WrapperDataMatriz.CREATE(), testes feitos.


[Anotação]:
			-----> Há uma funçao de Vector, e todos Wrapper Object, [Casting], que resolveria o problema de atribuicao em EvalExpression.Eval();
_______________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 08.01:

[ExpressaoPorClassificacao][WrappersObjectCreate]:
		------> (x)  testes com instanciação de wrapper objects (chamada de metodo CREATE).
							----> implementado os tokens consumido [tokensProcessed]:
										----> wrapper vector.
										----> wrapper jagged array.
										----> wrapper dictionary text.
										----> wrapper matriz.
				(x) testes feitos, o pre-processamento CREATE de Wrapper Objects está operacional.

		-----> (x) como operadores tem varios operadores numa mesma entrada na tabela hash, foi colocado
		mais adiante, no final do processamento, porque faz o processamento de todos outros tipos de tokens,
		e depois operadores, economizando porque os outros tokens nao tem tanta celulas na tabela hash: normalmente é 1 celula,
		desempenho: O(1);


[ExpressaoPorClassificacao][Testes]:
		-----> (x) fixar com cenario: [TestePropriedadeAninhadaSeguidaDePropriedadeAninhada].

[ClassificadorDeTokens]:
-----> (x) VERIFICAR URGENTEMENTE SE parametros WrapperObject está sendo classificado como wrapper object, no [ClassificadorDeTokens].	
		-----> ( ) propriedades: estaticas, multi-argumentos, parametro-funcao, estão sem classificacao com um campo especifico.
					----> ( ) planejamento para casos de propriedades verificadas.


[Expressao]:
		-----> (x) preparacao para migracao de processamento de [Expressao], de [ExpressaoGrupos] para [ExpressaoPorClassificacao];
					----> (x) funcionalidades externas de [ExpressaoGrupos], implementado em [ExpressaoPorClassificacao].
					----> (x) codificar [Expressao], para compor com [ExpressaoPorClassificacao].
									----> (x) remover [WrappersManager], e chamadas de processamento wrapper, em [Expressao],
									que será feito em [ExpressaoPorClassificacao].
												----> processamento de wrappers data é por expressao,
												feito em Instrucao.ExpressaoValida();


[Expressao]:			
		-----> (x) em Expressao.ExtraiExpressoes(), está adicionando o token [virgula], como token de uma Expressao.
					----> (x) atualizado [ExpressaoPorClassificacao], [ExpressaoGrupos] não necessário, 
					esta funcionalidade será feito por [ExpressaoPorClassificacao].

[Expressao][Testes]:
		----> () quebra de codigo: processamento de headers nao está sendo feito corretamente.
						----> falha de natureza desconhecido está removendo as classes na compilacao da 2a. classe do cenario de teste.
										-----> headers formados de uma vez, mas na passagem de classes há a falha.
												-----> falha ao compilar um metodo, em [ExtratoresOO.ExtraiMetodos()];
												-----> investigando, a falha está em [Instrucao.Atribuicao];
												-----> investigando, a falha está na instanciação de 1 [Expressao]!;
												-----> investigando, a falha está no novo moto de expressoes, [ExpressaoPorClassificacao]!;
												-----> investigando, a falha está na tabela hash de classficacao de tokens!;
															----> (x) encontro, a falha está em [ExtractHeadersClassFromClassesOrquidea],
															que está resetando o cabeçalho de classes headers!;
															----> (x) falha persiste,os headers nao estão inicializando
															os tokens da 2a. classe em diante;
																		----> (x) tentativa de compilar todas classes,
																		em uma unica compilacao, o codigo entrou em loop infinito!!!.
																					-----> (x) a falha está em instruções fora das classes,
																					como expressoes de inicializacao!


										-----> headers está sendo reconstruido em [Expressao.InitHeaders()]!
														----> logica nao muito clara, em [Expressao.InitHeaders()]...


[ProcessadorIDs]:
		-----> (x) remover a funcionalidade de extração de expressoes wrappers objects, será feito normalmente por [Expressao],
		via [ExpressaoPorClassificacao], em [Instrucao.ExpressaoValida].

________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 09.01:

[ProcessadorDeID]:
		-----> (x) retirar do mapeamento toda sequencia que NÃO for comando de programação estruturada! O que
		resta é expressões: expressoes de atribuição, expressoes wrapper object, expressoes chamada de metodo,
		expressoes propriedades aninhadas! Fica enxuto o processamento de compilação, e muito mais fácil de
		extender (com novos comandos estruturados, como outros tipos de comando for)! É o mesmo conceito do
		classificador de tokens: resumir todos casos possíveis....
					-----> (x) testes: na fixar instanciacao de objetos, e instrucao if/else;
							-----> (x) não havia caso de instanciacao de um objeto! porque era funcao do compilador, nao do motor de processamento de expressoes.
		-----> (x) IMAGINE AS POSSIBILIDADES: COM utilização massica do motor de processamento de expressoes, o que resta são comandos de programação estruturada.
		as expressoes cercam quase tudo: chamadas de metodo, atribuicao, instanciacao, wrappers object create/setElement/getElement,numeros, literais, etc...,
		fica extremamente facial extender a lista de comandos de programacao estruturada, como novos tipos de comando for...


[Expressao]:
		-----> (x) migração de [ExpressaoGrupos] para [ExpressaoPorClassificacao], completado.


[Expressao][Testes]:
		-----> (x) fixado o loop infinito relatado no Daily anterior.
					----->(x) fixar um teste unitario no 1o. teste, que não foi avaliado em razão do loop infinito que o cenario entrou.
							-----> (x) falha em expressao entre parenteses: o caso em [ExpressaoPorClassificacao] nao
							está registrado a expressao com o tipo especifico: [ExpressaoEntreParentes]! (e esta faltando os 2 tokens de parenteses, para
							atualizacao da malha de tokens).



[ProcessadorDeID]:
		-----> (x) fixar a compilação de muitas classes, em ProcessadorDeID, não está compilando instruções fora de classes.
							-----> (x) modificacoes de corte e processamento de comandos estruturados, e demais por expressoes, fixou este caso.
							-----> (x) pequeno programa fatorial compilado.
							-----> (x) descoberto o loop infinito do Daily anterior: TODA CLASSE DEVE TER AO MENOS UM CONSTRUTOR!
							no cenario nao havia 1 construtor sequer, e o processamento retornava null na compilacao da
							classe, entrando em loop infinito...

		-----> (x) testes atualizado com chamada de funcao de inicializacao de compilacao, testes feitos.
		-----> (x) removido os handlers de nao-handlers de comandos de programação estruturada.
		

[ClassificadorDeTokens]:
-----> ( ) propriedade estatica: comeca com nome de classe, e verifica se o proximo token é operador dot, e o nome seguinte se é nome de uma propriedade.
		----> (x) Classe tem uma lista com propriedades estáticas, registrar nesta lista as propriedades estáticas.
					--->[ExtratorOO] já tem previsão para registro de propriedades estáticas.

		----> (x) classe [FileHeader] tem previsao para expressao de inicializacao de propriedade! é só atualizar
		o [ExtratorOO].[ExtraiPropriedades] para obter os tokens da expressao, fazer a avaliação e atribuir o valor;
		é de se notar que somente expressoes com valores sem objetos não-constantes, o que é verdade para outras linguagens, também...
					----> () cenario de teste unitario para propriedade com valor na inicializacao.
									----> falha no calculo de valor de propriedade;

_________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.01:

[ClassificadorDeTokens]:
	-----> (x) propriedades: estaticas, multi-argumentos, parametro-funcao, estão sem classificacao com um campo especifico.
					----> (x) (verificado) realmente, no classificador de tokens não há campos especificos para multi-argumentos, estaticas,
					parametro-funcao.
	-----> (x) implementar novos campos de tipos especificos de propriedades.
	-----> (x) implementar em [ClassificadorDeTokens], campos especificos para propriedades. salvo engano, 
	o [ExtratorOO] já está implementando estes campos especificos...
					-----> (x) propriedades sao compiladas em [ExtratoresOO], e nao [ExpressaoPorClassificacao]!

[WrapperVector]:
	-----> (x) nova funcionalidade: lista de elementos instanciados, como: Vector v1= ["salada","churrasco","tradicional"];
	apos a chamada de metodo Create, inserir chamadas de metodo [SetElement], 1 para cada valor da lista de inicializacao.
	é possivel deixar a instanciacao no momento de criacao dentro do programa VM: aumento de ortogonalidade..
					----> (x) testes feitos para valores numeros e literais, mas pode há muitas possibilidades: 
					passando expressoes, como elemento, o codigo funciona: no momento da instanciacao,
					os valores expressoes são passados para o codigo!

[WrapperDictionaryText]:
	-----> (x) para manter a compatibilidade com outros Wrappers Data, foi modificado a anotação wrapper SET Element
	de [WrapperDictionaryText], para conter um sinal de atribuição [=], nesse tipo de anotação SET.

[FileHeader]:
		-----> (x) fixar a obtenção de expressao de inicializacao de propriedades.
					----> (x) sem tokens de expressao de atribuicao, o teste passa.
					----> (x) teste com tokens de atribuicao de propriedade, teste passou.


[Expressao][Testes]:
		-----> (x) realizar todos testes de [Expressao]. apenas 1 teste foi feito e validado, ante a migracao de
		[ExpressaoGrupos] para [ExpressaoPorClassificacao].
					----> fixar nos cenarios de testes:
								----> (x) [TesteParametrosMultiArgumentos];
								----> (x) [TesteExpressaoProcessamentoObjetoDictionaryText];
								----> (x) [TesteExpressaoOperadorVariosOperadores];
								
[Escopo]:
		-----> (x) organizar a hierarquia de Escopo: EscopoROOT (estático, escopo inicial), EscopoCurrent (estático,
		podendo ser um Escopo De Metodo, Escopo de Bloco).
					----> (x) escopo ROOT, poderia ser inicializado em [SystemInit], e instanciado em [ProcessadorDeIDs],
					na primeira compilação. EscopoRoot= compilador.escopo.Clone();
					----> (x) criar nomes id para Escopos.
					----> (x) nomes de escopos de classes;
								
_______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.01:

 		
[Escopo]:
		----> (x) o Escopo na maior parte do codigo é [EscopoCurrent]. Na maior parte, o processamento
					é feito dentro de uma função! Com excessao de Escopos de Blocos: fazer a mudança do
					EscopoCurrent de uma função, para o EscopoBloco, e quando o Bloco encerrar suas instruções,
					voltar o EscopoCurrent para escopo de Funcao.
								-----> pausa para planejamento se faz uma copia do escopo de funcao para o escopo currente,
								e volta do escopo currente para o escopo anterior. talvez precise de uma funcao escopo.Clone();
										-----> (x) implementado o [Escopo.EscopoCurrent], na execução de METODO,
										voltando ao escopo parametro quando a funcao termina.
										-----> (x) implementado o [Escopo.EscopoCurrent], na execução de BLOCO,
										voltando para o estado anterior quando o bloco termina.
										-----> (x) implementado a adicao dos escopos de classe, para o escopo global.
										-----> (x) é preciso adicionar os escopos de funcao da classe, para o escopo da classe.

					-----> (x) nomes de escopos de funcoes: em [ExtratoresOO].ExtraiMetodos(), dar nome ao escopo de
					metodos, com cuidado no nome que pode ter varios metodos com mesmo nome. o então
					deixar apenas como [Escopo.name="function"];
							----> pausa para planejamento de nomes de escopos com sobrecarga de funcoes.
					-----> (x) verificar se [Escopo.Clone()] copia todos escopos folhas.


		-----> (x) uma aplicação de [EscopoCurrent] seria a avaliação de uma [Expressao] via codigo orquidea,
		uma extensão em planejamento, visando adicionar às classes da linguagem a classe [Expressao],
		só que avaliar uma expressão precisa do escopo currente! se setar o escopo currente para o escopo da funcao
		currente, ou escopo de bloco, ou mesmo o escopo root, eliminaria no codigo disponibilizado desta classe,
		o objeto escopo.


[ExpressaoPorClassificacao]:
		
[ExpressaoPorClassificacao][Testes]:
		-----> (x) fixar com teste: [TesteParametrosMultiArgumentos];
		-----> ( ) falha em expressao de propriedades aninhadas como: [a.propriedade1.propriedade2].
							----> (x) a falha está em 1a. propriedade aninhada, 2a. propriedade aninhada.
										----> (x) estava sem validação da sequencia de propriedades aninhadas!
							----> quando muda de posicao os cenarios, o teste passa!
										----> (x) Falha no classificador de expressoes! Tem que resetar a TabelaHash do classificador.
														----> (x) com a construcao da tabela hash a cada teste,
														houve perda de desempenho,
														mas normal porque são vários pequenos programas nos cenarios de testes...

		-----> ( ) [copiando] seria interessante copiar e adaptar os testes em [ExpressaoGrupos] para [ExpressaoPorClassificacao].
							-----> falha em [TestesChamadasDeMetodosEstaticas]:
														----> (x) nao está reconhecendo um metodo estatico!
																		-----> é preciso registrar na tabela hash o nome do objeto estático!
														----> (x) falha na atribuicao de um objeto string!
																		-----> se for um valor constante ou de objeto constante,
																		avalia a expressao e seta o valor do objeto string, do cenario,
																		senão, deixa o calculo do valor para quando avaliar a expressao
																		como um todo.

														----> (x) com a correção, outros trechos de codigo falhou!:
																	(x) são cenarios com expressao de atribuicao, justamente o trecho de codigo que foi fixado.
																				
																		-----> (x) [TesteOperadorUnarioEBinarioMasFuncionandoComoBinario];
																						----> (x) operador binario;
																						----> (x) operador unario;

																		-----> (x) [TestesExpressoesMaisDe1ElementoWrapper];

														-----> (x) o caso é o seguinte: o operador igual
														não pode ser modificado sua insercao,
														no entanto é processado como operador comum,
														diferente de [ExpressaoGrupos] que processava
														em separado, e com testes havia passado...

___________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.01 (tarde):

[Expressao][Testes]:

		-----> () importar mais testes de [ExpressaoGrupos];
						----> parado no teste 6 de [ExpressaoGrupos];
						----> (x) fixar com teste expressao chamada de metodo, com parametros complexos: expressao entre parenteses:
										----> "objetoA.metodoA((x+1),y+1);"...
													----> expressao entre parenteses é envelopada, entao o tipo da 
													expressao é Elementos[0].tipoExpressao!
[ClassificadorDeTokens.TabelaHash]:
		-----> (x) tabela hash está computando todas classes da linguagem, a cada teste! Separar no classificador,
		os tokens classificados das classes de linguagem...
						----> (x) ou seta em systemInit, uma flag nao para anular a tabela hash do classificador,
						mas para não computar as classes da linguagem orquidea.
						----> (x) testes feitos, nao resultou em ganho de desempenho;


		
		-----> (x) Verificar se [Expressao.tipoDaExpressao] está sendo setado corretamente. em teste manual, varias expressoes
		ficaram com valor null; Tem que verificar, porque expressoes complexar, como: obj1.metodo1()+obj2.metodo2() é preciso.
						----> uma funcao de codigo anterior estava lançando exceções, justamente porque pode
						haver expressoes null, e o processamento otimizado com LinQ precisa que os valores sejam <>null,
						salvo melhor codigo que implemente uma condicao em que o elemento pesquisado seja <> null.
___________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.01:


[ClassificadorDeTokens.TabelaHash]:
		-----> (x) verificar se faltou construir o classificador após o reset!
						-----> (x) apesar da logica de programacao anterior, continuava a carregar para classificador as classes
						da linguagem! Está automatizado, na medida do possivel: de 35 segundos, foi a 25 segundos
						o tempo total de rodar todos testes!


[Expressao]:
		-----> (x) fixar com os testes:
					(x) [TesteExpressaoChamadasDeMetodo]: todas expressoes nao passou.
							-----> os headers de codigo nao estão sendo carregados!
											---> (x) funcao [ExtratoresOO.ExtraiMetodos()] está apagando os headers de codigo!
											---> (x) falha no fileHeader, que resetava a lista de headers class, toda
											vez que se chamava mais de 1a. vez os headers!
											no codigo anterior, os header eram carregados uma unica vez,
											mas com o classificado, é carregado mais de 1a vez, causando a falha.

					(x) [TesteExpressaoPropriedadesAninhadas]; 5 expressao gerou excecao.

					(x) [TesteAvaliacaoAtribuicaoPropriedadesAninhadas];
								----> (x) expressao propriedades aninhadas sem setar o tipo da expressao,
								passou em outros testes porque não havia operação aritmética que precisa do tipo da expressao
								para validação!
								----> (x) falha em operacao aritmetica com propriedades aninhadas, como: a.prop1= a.prop1+b.prop2;
														-----> (x) nao havia previsao de incremento de indice da malha de tokens,
														para o caso de propriedade aninhadas expressao de atribuicao!

					(x) falha quando há classes de mesmo nome em cenarios de testes diferentes,
					ou classes com mesmo nome mas com propriedades, nomes de métodos diferentes..



		
		-----> (x) importar mais testes de [ExpressaoGrupos];
						----> todos testes de[ExpressaoGrupos] foram importados para [Expressao];
						----> (x) todos testes importados, feito.
						
						
[ExpressionBase];
	----> (x) planejamento, design de uma classe de [Expressao] disponibilizada como classe da linguagem orquidea.
	com esta classe, será possível construir pequenos jogos!

						----> [ExpressionBase]:
									----> metodos:
												Run(): faz a avaliação da expressao.
												Compile(ExpressaoBase exprss , string codigo): compila uma expressão. 
									-----> campos:
												Expressao exprss: public;
												string codigo: public;
												object result: public;

						----> no decorrer do projeto, mais metodos podem ser adicionados.
						----> importado como library, como classes default da linguagem orquidea.

________________________________________________________________________________________________________________________________
Daily Scrum 12.01 (tarde):

[ClassificadorDeTokens.TabelaHash]:

						
[Expressao][Testes]:
		-----> ( ) o metodo GetMethodCompatible() está com alguma propriedade estática
		que invalida expressoes chamada de metodo seguintes..
					-----> () o codigo de [ClassificadorDeTokens] não está limpando as classes de cenario anterior corretamente!
								----> (x) falha na codificacao da funcao obterClassesHeader(): os nomes dos metodos
								não estão qualificados como [headerCode]!
								----> (x) e nomes de classes também!
										----> (x) é preciso apagar as classes headers também!.		
										----> (x) falha em busca por List!, forçando para metodo convencional.   
					-----> ( ) continua a falha:
								----> fixar os testes:
										----> (x) [TesteParametrosMultiArgumentos];
												----> (x) o reset nao está funcionando!, está extraindo também todas
												classes do cenario de teste currente!;  removido do projeto;


										---->  (x) o caso É O SEGUINTE: só está ocorrendo falhas porque
										os testes contem mesmos nomes de classe; numa situação sem testes, o codigo passa;

										----> (x) modificando para nomes unicos para cada cenario de teste,
										ou nomes iguais mas mesmas propriedades, mesmos metodos, os testes passou.


[Expressao][Testes]:

		-----> (x) na saida do terminal, está registrando um bocado de Exceções, no entanto o código continua normalmente
				e fazendo validações nos cenários de testes.
								----> verificar [ClassificadorDeTokens.TabelaHash.isXX()], que pode gerar exceção 
								na leitura de tokens nao mapeados.
												----> (x) caracteres de tokens nao mapeados, como [A..Z], ",",""",'^', acrescentados.
																----> diminuiu de 74 para 49 segundos de processamento, todos testes.
																Em [Expressao][Testes] com [ExpressaoGrupos],
																o tempo de processamento era mais de 3 minutos!, senão mais,
																era preciso parar o processamento, deixando testes sem validação,
																tamanha a demora. havia no [FileHeader] um erro de lógica,
																e no motor de processamento [ExpressaoGrupos], havia
																entradas duplicadas de processamento de tokens!
																----> o classificador é resiliente: mesmo encontrando
																caracteres nao mapeados, continua o processamento.

												----> (x) antes, verificar se em [TabbleHash.ReadToken()], [TabbleHash.WriteToken()],
												está gerando exceção, e procurar incluir os tokens nao reconhedidos no
												código de geração de hashNumero.

[FileHeader]:
		----> (x) codificar a remoção de classes com mesmo nome que o das classes já presentes nos headers.
								----> (x) confirmado: classes com mesmo nome estão sendo adicionados, sem verificação
								se há classe com mesmo nome já armazenado! Não verificado anterioremente
								porque o header inicializava as classes headers antes de iniciar o processamento...
								----> (x) falha no codigo de fixar as classes com mesmo nome.
												----> (x) regressão de testes para [FileHeader]: a remoção está funcionando,
												a falha não está em FileHeader!
												----> (x) codigo duplicado de extração de classes de mesmo nome,
												em [Expressao.InitHeaders()], fazendo a mesma funcionalidade de
												extração de classes com mesmo nome.
												----> ( ) procurar onde está passando a duplicação de classes de mesmo nome.
												quase certo que seja em [ClassificadorDeTokens];



________________________________________________________________________________________________________________________________
Daily Scrum 15.01:

[Metodo.ExecuteAMethod()]:
		-----> ( ) depois de carregar os parâmetros, e antes de chamar a execução da função propriamente dito,
		guardar os objetos da sessão currente do escopo do metodo, e depois de voltar da execução, restaurar
		os objetos da sessao currente, com os dados salvos. não salva o escopo dos parâmetros não...
		
					------> QUAL É O PASSO-A-PASSO DE CHAMAR UMA FUNCÃO?
								----> 1- empilha os parâmetros;
								----> 2- chama a função;
								----> 3- desempilha os parâmetros;
						-----> no caso específico, tem que empilhar também os objetos da sessao do metodo (EscopoSessao=EscopoDoMetodo.clone()),
						e quando terminar a chamada, desempilhar os objetos da sessao do método.
									----> a discutir ainda se o EscopoCurrente deve ser o EscopoSessao, antes e após a chamada
									da função. O escopoSessao é o anterior EscopoDoMetodo (é uma lista contendo
									os dados de variaveis dentro da função, e não tem valores definidos antes
									da chamada da função), mas é um clone deste escopo,
									e é passado na execução da função! (pasando mais os parâmetros):
											funcao(parametros, escopoSessao): apos voltar da chamada, o escopoSessao deve
											ser restaurado: seus objetos não são modificados e passados para fora da chamada.
											
						-----> dois metodos: 
										pilhaSessao.push(sessaoMetodo.objetos), pilhaSessao.pop(sessaoMetodo.objetos),
									  e pilhaParametros.pus(parametros.objetos), e pilhaParametros.pop(parametros.objetos);

[FileHeader]:
		-----> (x) procurar onde está passando a duplicação de classes de mesmo nome.
		quase certo que seja em [ClassificadorDeTokens] ----> está na tabela hash.


[TabelaHash]:
		-----> (x) vai ser preciso uma funcao de TabelaHash.removeClasse(nomeClasse),
				sendo os tokens da classe vinda do ClassificadorDeTokens.
		-----> (x) vai ser preciso também uma funcao de remoção de tokens de uma classe, presente no classificador. 


		-----> (x) apos testes, INCLUIR na tabela hash, a funcao de remover classes repetidas.
							----> (x) teste se os tokens da classe repetida foi removido na tabela hash.
							----> (x) teste também se os tokens da classe repetida foi removido no classificador.			
							----> (x) bastaria no Classificador, obter a lista de classes base orquidea,
							e o que nao estiver, remover.. ao construir a tabela, vai ser apenas com os elementos
							nao removidos.
							[Testes]:
										----> (x) nao está removendo as classes no [ClassificadorDeTokens]!;
													-----> (x) não faz o processamento de tokens da classe header que
													tem o mesmo nome da classe a remover.
									
							

[ClassificadorDeTokens]:
		----> ( ) arrumar a lista de nomes de classes presentes, a fim de imprimir resultados com [ClassificadorDeTokens.PrintResults()];
							----> ( ) falha DE NATUREZA DESCONHECIDO ESTÁ IMPEDINDO de obter a lista de nomes de classes no classificador.
							----> (x) apesar dos cenarios de testes, é preocupante a lista vazia de nomes de classes.
							----> (x) fixar com base no teste:
										-----> (x) [TesteWriteReadHashTable] (cenario desatualizado);






		
__________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.01 (manhã):

[TabelaHash]:
		----> (x) nao está registrando nomes de propriedades! de funcoes sim.
						-----> (x) logica dificil de implementar: os headers são formados antes de chegar ao Classificador!
										----> sequencia logica combinado [TabelaHash] com [ClassificadorDeTokens].
		----> (x) está operacional, porem as classes anteriores nao estão sendo removidas! e há perda de desempenho.
						-----> (x) desempenho dos cenarios de testes foi de 46s, para 56s.
						-----> (x) classes antigas estão sendo removidas, do classificador.
										----> (x) classes antigas removidas no [Classificador], [TabelaHash], e [ExpressaoHeaders].

		----> () verificar a [TabelaHash], na tela de saida mostrou duas excessões por index fora da faixa de um array,
		que com certeza é na [TabelaHash], porque é um objeto que é array, e outros objetos como [FileHeaders], [Classificador],
		contem apenas Listas.

[Expression.headers]:
		----> (comentario) se o [FileHeader] fosse um único objeto, porque o é, seria mais fácil fazer a lógica de classes headers, classificador,
		e tabelaHash...


[ExpressionBase]:
		-----> (x) testes com pequenas expressoes, como "a= x+1";

		-----> (x) expressao "x=x+1", com "x=5", está retornado "7";
						---->é porque a expressao de atribuicao estava calculando x=x+1 no momento da instanciação.
						o correto é que somente a expressao de atribuicao for uma constante (numero, literal),
						fosse atribuida no valor do objeto caller.

		

[WrapperData]:
		-----> (x) NAO ESQUECER! para expressao de atribuicao, setar o valor do objeto caller (obj.valor=resultFuncao),
			mas se o objeto caller for um WrapperData Object, tem que haver O REARRANJO do obect valor, para A ESTRUTURA INTERNA
			DO WRAPPER OBJECT! Codificar em WrapperData.SetValor(Objeto objCaller, object valor), que passa para o WRAPPERDATA especifico,o 
			REARRANJO INTERNO DO objeto caller...
							-----> (x) função: [WrapperData.SetValor(Objeto objCaller, object valor)()], retorna um Objeto,
							que é a copia wrapper/objeto de [valor].
							-----> (x) verificar se a funcao Objeto.Clone() está clonando corretamente os wrappers objects.
											-----> (x) em [WrapperData], criado um metodo estatico para clonar um [Objeto]
											que seja também um [WrapperObject], e inserido no Objeto.Clone().

_____________________________________________________________________________________________________________________________________________
Daily Scrum 16.01 (tarde);

[EvalExpression.Eval()][Testes]:
		-----> ( ) fixar com testes em [EvalExpression] (apos o acerto dos escopos falado acima);
						----> (x) testes com expressoes sem atribuição, feito primeiro teste;
						----> (x) testes com expressoes com atribuição, falha, mas era previsto: a atribuição
						está dependendo da função [WrapperData.SetValor(Objeto objCaller, object valor)()];
											----> (x) falha na construção da ExpressaoAtribuição.
														----> (x) ExpressaoAtribuicao estava com o objeto a receber a atribuição
														como wrapper object!;
											----> (x)mesmo com uma expressao atribuicao complexa, o valor é calculado assim mesmo, prejudicando o calculo
											em [EvalExpression]!

						----> (x) retirado provisoriamente o WrapperData.SetValor(Objeto objCaller, object valor)(),
						no calculo de Expressao de Atribuicao.




_______________________________________________________________________________________________________________________________________________
Daily Scrum 17.01 (manhã):

[EvalExpression.Eval()]:
					----> no calculo de [ExpressaoAtribuicao], inserir WrapperData.SetValor(Objeto objCaller, object valor)(),
					a fim de calculos de resultados objetos wrapper.
										 ----> (x) fixado para Objeto.
										 ----> (x) fixado para WrapperObject!
[EvalExpression.Eval()][Testes]:
		----> (x) criar cenarios de testes para atribuicao wrapper object: "Vector v1; Vector v2; expressao: v1=v2";
										-----> (x) falha na expressao de atribuicao: "v1=v2;"
										-----> (x) falha na avalicao de expressao chamada de metodo wrapper data;
															-----> (x) confusao entre codigo muito modificado, 
															está calculando corretamente a chamada de metodo,
															mas não atualiza o objeto contido no escopo, justamente
															porque é preciso um casting de object para wrapper object.

															-----> funcao Metodo.ExecuteAMethod() estava para ser atualizada,
															no proximo item do ProductBacklog.

															-----> (x) casting wrapper objects feito.
															-----> (x) falha no nome do objeto wrapper de retorno da funcao! (está sem nome...);
																			-----> (x) precisa pasar como parametro o objeto caller, em metodo.ExecutAFunction.
															
															-----> (x) falha na atualizacao do objeto no escopo externo: está modificando
															todos valores de objeto, nao apenas o do objeto caller.
															
															

		----> (x) a verdade é que não havia previsão para retorno de wrapper object em um Metodo.ExcecutaAMethod();
						
						

___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.01 (tarde):

[EvalExpression.Eval()][Testes]:
		-----> (x) falha na Expressao Atribuicao: valor a atribuir está com null!
					----> (x) modificações no cálculo de [ExpressaoObjeto], para retornar valores apenas quando Objeto.valor!=null...;
					----> uma solução seria setar o valor de Objeto.valor, com o proprio Objeto, prevenindo de falhas
					quando Objeto.valor=null;
					----> (x) fixar a funcao [WrapperData.SetValor()];
										-----> (x) a falha está em [Vetor.Clone()]. 
										-----> (x) revisar todas funções Clone() de Wrappers Object.
															-----> faltou propriedades de Objeto, como nome.
					----> (x) WrapperData.Clone() faz uma cópia em profundidade, não apenas a referência (ponteiro)!

[EvalExpression.Eval()][Testes]:
		----> () criar cenarios de testes para funções na linguagem orquidea, não funções importadas.
		Não foi testado, porque o foco não era em [Objeto], mas [funcoes importadas da linguagem base].

[EvalExpression.Eval()][Testes]:
		----> parado ante a incerteza e insegurança de atos claros de SABOTAGEM!



______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.01:

[ExecuteAMethod]: modificações aprovado para calculos de parametros, escopos, separação de funções importadas,
de funções na linguagem orquidea. ver arquivo externo: URGENTE_ORQUIDEA.txt;
				----> (x) 1a. prioridade codificada, em uma nova funcao de obter parametros com valores atualizados.
								----> testes razoaveis, 1a prioridade implementada.
				----> (x) 2a. prioridade codificada, separando funcoes importadas de funcoes orquidea.
				funcoes importadas nao precisam de escopos, apenas a lista de object parametros;
				funcoes orquidea precisam de escopos, mas nao lista de object parametros.

		-----> (x) conclusao: simplificação com desempenho melhor, pois há funcoes importadas que precisava construir escopos,
		que nao sao necessarios. e também a não necessidade de avaliar todos tipos de expressao-parametros,
		pois há valores constantes ou bem definidos, como expressao-objeto,  expressao-numero, expressao-literal.
		no codigo anterior, era bala de canhao para resolver um problema bem mais leve: todos parametros-expressoes
		era avaliada, nao importa se fosse constantes, ou valores já determinados.


[ExcecutaAMethod]:
		-----> (x) verificar se o escopo corpo do metodo está sendo utilizado...

[ExecuteAMethod][Testes]:
				----> (x) verificar a execução da seguinte expressao: "double.root2(9)", que lançou exceção.
								----> falta de cenario de teste para ExpressaoNumero como parametro de função! 
								----> deixar de fanfarronice e cercar todos casos de testes, mas para 
								isso, é para criar mais testes unitarios, 1 para cada caso de codigo possivel.


[ExecuteAMethod][Testes]:				
				----> ( ) testes para funções com instruções de programa VM.
								----> (nao necessario, o escopo de sessao é construido a cada execução da função)
				acertar o empilhamento de escopos de sessao, pois pode ser perdido durante a execução da função recursiva.
								----> (x) falha esperada na compilacao de uma instrucao if, dando como [ValidExpress],
								e nao [if]: falha em [Expressao.Instance.ValidaExpressaoCondicional()];
								----> x) OBSERVACAO: expressao condicional expressamente setada para reconhecer apenas uma
								expressao condicional! e não havia processamento de operadores "||" e "&&"!
												----> (x) modificacao para reconhecer 1 ou mais expressoes condicionais, feito.
				
[EvalExpression.Eval()][Testes]:
				----> ( ) teste para avaliação de expressão condicional com short cut condicional.
				----> (x) falha na obtencao de operadores condicionais, em Expressao.ObtemOperadoresCondicionais();
								----> (x) solução recursiva, pois há expressoes entre parenteses de expressoes entre parenteses!
												----> (x) codificado [Expressao.ValidaExpressaoCondicional],
												como solução recursiva.
												----> (x) o fato é que expressoes condicionais entre parenteses
												contem um unico operador, com exceção que a expressao entre parenteses
												seja um wrapper de outras expressoes entre parenteses!
				-


[ExpressaoPorClassificacao]:
				----> (x) incluir operadores condicionais "&&" e "||" como operadores validos para expressoes entre parenteses.
				----> (x) falha na inclusao de operadores condicionais &&, ||, regressao para [ExpressaoPorClassificacao];
								----> (x) nao havia previsao no classificador de tokens, era esperado: as expressoes
								condicionais anteriores era de apenas uma expressao entre parenteses, que contem um
								unico operador condicional...
													----> operadores conectivos condicionais adicionados no [ClassificadorDeTokens],
													como operadores da linguagem orquidea, operadores universais.
				---> (x) sem previsao de operadores condicionais "&&" e "||" para processamento de operadores, em [ExpressaoPorClassificacao];
								----> () falha em testes de operadores condicionais conectivos..

[ExpressaoPorClassificacao]:
			   ----> () fixar com testes seguintes:
						----> (x) [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]; (cenario sobreposto);
						----> (x) [TesteExpressaoEntreParentesis]; (cenario desatualizado); 
						----> (x) [TesteWrapperObjectJaggedArray]; ("pequeno" defeito, na função JaggedArray.Clone, não testado em outros cenarios); 
						----> (x) [TesteWrappersObjectVector]; (cenario desatualizado);
						----> (x) [TesteWrapperDictionaryText];(cenario desatualizado);
						----> (x) [TesteWrapperObjectMatriz]; (cenario desatualizado);
				----> (x) clonagem de wrappers object funcionando.
[Expressao]:
			----> (x) ante a nova modificação no [ClassificadorDeTokens], e [ExpressaoPorClassificacao],
			para prever operadores conectivos condicionais: "&&", "||", foi realizado uma nova bateria de testes unitário.
			----> (x) foi válido, porque pegou-se um pequeno erro em [JaggedArray.Clone()], que os testes não abrangeram posteriormente
			a codificação de [WrapperData.Clone()];
__________________________________________________________________________________________________________________
Daily Scrum 01.02:

[EvalExpression.Eval()][Testes]:
				----> (x) operadores conectivos registrados em [ExpressaoPorClassificacao]:
								----> ante a bateria de testes, observou-se que cada [ExpressaoEntreParenteses]
								contem um unico operador condicional, o que pode auxiliar na avaliação de [ExpressaoEntreParenteses]
								compostas de outras [ExpressaoEntreParenteses].
								
				----> ( ) teste para avaliação de expressão condicional com short cut condicional.



[ExecuteAMethod][Escopos]:
				----->(X) valores passados por referencia, não por valor, todos objetos. pode ter
				consequencias indesejavel, como uma função recursiva com valores de parametros passados por referencia,
				exigindo malabarismos maiores para obter valores sem modificar os valores dos parametros.
							-----> (x) ver resolução de nova tag  :r, que especifica que um parâmetro deve ser passado
							por valor (r: readOnly); (implementado em fileHeader, funcoes clone, funcoes copy, 
							e em ExtratoresOO(extrai parametros funcao, extrai propriedades));
							-----> (x) classes modificadas:
										1- FileHeader: parametros de metodos com a tag :r, sao passados por valor;
										2- ExtratoresOO: parametros de metodos com a tag :r, sao passados por valor;
										3- WrapperData: parametros de metodos com a tag :r, sao passados por valor;
										4- Objeto: parametros de metodos com a tag :r, sao passados por valor;
										5- todos metodos de clonagem de objetos, com a tag :r, sao passados por valor;
										6- todos metodos de copia de objetos, com a tag :r, sao passados por valor;
				-----> (x) implementar em [ExecuteAMethod], fazer uma copia quando o parametro tem a tag :r, e passar a copia para lista de parametros.

[ExecuteAMethod][funcao orquidea][Testes]:
				-----> (x) falha esperada na execução da função em linguagem orquidea: o programa VM não foi revisado,
				ante a muitas e extensas modificações no codigo orquidea, e a inclusão de novas funcionalidades.
							-----> (x) a falha está em FileHeader, justamente porque a tag :r não foi implementada corretamente.
				-----> (x) REVISAR a obtencao de parametros de funcoes wrappers object, com a tag :r implementada.
							-----> (x) testar com parametros wrapper object com a tag :r;
				-----> (x) fixado todas falhas em funcoes orquidea, com a tag :r implementada.
				-----> (x) fixado falha com wrapper object dictionary text, em FileHeader;
				-----> (x) fixado todas falhas em [FileHeader], contagem de tokens de classe ocorreu exata.
				-----> (x) o programa vm não está retornando o valor esperado, entrando no caso de retorno de [return 1];
							----> (x) falha no [ExtratoresOO.ExtraiMetodos], está incluindo o parametro da função no escopo de corpo do metodo.
											---->	(x) EU MESMO FIZ A REGRA DE INCLUSÃO EXPLICITAMENTE, EM [ExtratoresOO.ExtraiMetodos()],
											incluindo os parametros como objeto do corpo do metodo!
				-----> (x) a sintaxe da linguagem é um pouco chata: precisa de um ponto-e-virgula para finalizar uma instrução,
				não importa se for depois de um bloco de instrucoes delimitado por {};

[FileHeader]:
				----> (x) fixar parametros multiargumentos (tag !);
				----> (x) fixar parametros DictionaryText, está com nome do parametro wrapper object errado;
				----> (x) alguns cenarios de testes desatualizados, como [TestExtractionHeadersFromAssembly];
				----> (x) fixar com teste:
								(x) [TestePropriedadeProtected]; (cenario com validacao errado, teste desatualizado);

[ExpressaoPorClassificadorDeTokens]:
		----> (x) VERIFICAR SE HÁ PROCESSAMENTO DE METODOS DENTRO DA CLASSE DO METODO, E ASSIM SEM OBJETO CALLER,
		OU SE PRECISA CHAMAR COMO [actual.metodo(x)], evidenciando o objeto caller como o objeto que fez a chamada,
		e processa dados feitos no [metodo(x)].
					-----> a supresa esquecido é que há previsão para função sem objeto caller, porque a tabela
					hash tem o nome de todas funções possíveis no código. ao detectar, constroi um objeto [actual],
					e associa a chamada da função [metodo(x)] (no exemplo relato) com uma chamada [actua.metodo(x)],
					que não é percebida externamente ao código...
					-----> outra supresa, para queimar a lingua... a validação da lista de expressoes parametros
					estava com limite >=2, o que seria verdade para tokens de parametros, nao a lista de expressao de parametros...
					o codigo quase todo está com processamento de lista de tokens de parametros...

______________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.02:

[Vector]:
		----> (x) criado funcao Vector.Sort(), que ordena elementos do tipo Objeto, com o valor hashText,
		ou seja o valor de [Objeto] deve ser uma string.
						----> testes feitos, em Objeto.Testes.
		
[Objeto]:		
		----> (x) criado um campo [hashText], para ordenaçoes de valores texto.
		----> (x) criado funcao [Objeto.SetHashWithText()], que constroi o campo [hashText] do [Objeto].


[EvalExpression]:
		----> (x) retirado o parser de operandos, porque se for diferente de tipos numeros, e diferente de Objeto,
		(como um tipo de operando importado), iria falhar.

[EvalExpression.Eval()][implementacao de Testes: "if short cut"]:

			----> (c) teste para avaliação de expressão condicional com short cut condicional. (1o. teste da classe de Testes).
					----> algoritmo:
							se for [operadorConectivo], e expressao for Elementos= ((exprssParenteses),(exprssParenteses), operadorConectivo), retornar o operador conectivo.
							se NAO for [operadorConectivo], e expressao for =(exprssParentes), retornar o operador no Elemento[2] (pos ordem, exp.parenteses contem 1 operador condicional);
										-----> percorrer a expressao inteira procurando exprssEntreParenteses, com nOperador= ncountExpressoesEntreParenteses.
							----> inicialmente procura o primeiro operador conectivo, MAS PODE ser de um indice =[0..x], x= ElementoCurrente de sub-expressao.
					----> primeiro resultado feito, mas e se for mais complicado, como (((a<=1)&& (b>=3)) || (c>3))?
										-----> neste caso, se falhar a primeira condicao short cut, tem que passar para a proxima expressao condicional
										(indice=1 (2o. operador conectivo));
										-----> falha no processamento do 2o. operador conectivo, justamente porque nao está na 1a. sub-expressao, mas na 2a. sub-expressao.	
					----> (x) testes;
							-----> (x) cenario de testes: ((a<=1) && (b>=2)),p.ex., validado;
							-----> (x) cenario de testes: (((a<=1) && (b>=2))|| (c==5)), p.ex.,validado.

							-----> (x) o algoritmo é simples: 
									  expressoes condicionais conectivas são: ([expressaoNaoConectiva],[expressaoNaoConectiva],[expresaoOperadorConectivo]);
									  1- se quisermos expressao conectiva: retorna [expresaoOperadorConectivo],
									  2- se quisermos expressao nao conectiva, retorna [expressaoNaoConectiva](indiceOperadorNaoConectivo);
									  Parece algo de PROLOG!
							
			----> (x) descobriu-se que os operandos do operador, não é os dois últimos operandos na pilha! 
							creio que há que se pensar mais um poquinho... solução trivial: executar a	EXPTRESSAO ENTRE PARENTESES da 
							expressao condicional cuurente, modificar a função que faz o processador de short cut de ifs, para retornar a expressao 
							entre parenteses...
							-----> (x) simplesmente nao havia previsão de executar uma expressao entre parenteses, sem short cuts de ifs!
											----> (x) expressao entre parenteses avaliado como uma sub-expressao de sua expressao SEM parenteses.

							-----> (x) falha de processamento de operandos em short cuts de ifs, fixado.
							
							


[WrapperData][Clone],[Objeto.Clone]:
		-----> (x) verificar se o atributo valor= Objeto criado em Wrappers Data, porque falha se for uma chamada de método de
		função importada, que obtem o valor de um parametro pelo atributo valor.
							----> ( ) realmente, não há atribuicao de valor=objeto criado. setar o valor e executar
							toda bateria de testes unitários.
							----> (x) existe em WrappersObject.Clone previsão para valor=objeto clonado.
				

[ExpressaoPorClassificacao]:
		-----> (x) VERIFICAR as chamadas da função [ExpressaoPorClassificacao.BuildListParameters()];
		
[CLARIFICAÇÃO]:
		-----> (constatação) AHHH, AGORA ENTENDI: tudo no codigo orquidea é feito por escopos. e tudo no codigo importado
		é feito por lista de object! uma função orquidea manipula variaveis, chamadas de funções, dentro de um escopos
		que é o código que guarda o contexto!
						-----> fascinado pela possibilidade de extender o codigo (com a construção de bibliotecas)
						atraves da API de Reflexão da Linguagem Base C Sharp, não se focou na manipulação de [Objeto], e pelo [Escopo].
						A bem da verdade é que não se deu foco no codigo orquidea, por causa da dita fascinação reflexiva...

_____________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.02:

[CONCLUSAO DA SEMANA ANTERIOR]:
			-----> uma semana de muitos insights, muitas funcionalidades implementadas, muitas revisões de código com depurador,
			revelação de verdades implicitas no código, inserção de funcionalidades para cobrir lacunas, como operadores condicionais
			conectivos (&&, ||) que não estava previsto, varias reviravoltas! 


[EvalExpression.Eval()][Testes][if short cut]:
			-----> (x) a simplificação do código em [Expressao.ObtemOperadoresCondicionais()], quebrou
			a funcionalidade! o teste passou porque não havia condição impeditiva, a lista de nomes de operadores condicionais
			conectivos retornava uma lista de tamanho nulo. Fazer uma varredura nos tokens da expressao,
			procurando tokens de operadores conectivos.
							----> (x) falha estrutural, a lista de tokens não está listando operador conectivo || !;
												----> tabela hash reconhece os operadores && e ||, então o fato é de sabotagem,
												não está retornando o operador ||, mas o classificador classifica o token |...
												----> nao é falha estrutural, cenario de teste em [ExpressaoPorClassifcacao]
												retornou mesmo o token ||, então é PARA PARAR O JOGO MESMO...
							-----> () verificar o que está acontecendo, em [EvalExpression.Testes].


			-----> ( ) o sistema de short cuts de ifs está EQUIVOCADOS! avalia-se a expressao condicional
			que foi selecionada, dai então seta true se resultar true, ou false na expressao inteira, se o resultado
			for false (mas seguindo regras de short cuts, apenas o retorno está errados)...
							----> ( ) expressoes inteiras de condicional deve ser avaliada expressao condicional cada,
							com 2 operandos e 1 operador condicional. e o short cut evita avaliação da expressão inteira,
							se o sistema determinar que o resultado for false, ou true, se apenas uma expressão condicional
							retornar um valor definitivo, quero dizer, para a expressão total.
			
			-----> ( ) realizar mais testes, como ((a==1) && (b<=2) && (c>=1));
			-----> ( ) o que acontece se quisermos um operador nao conectivo>1?


[Metodo]:		
		[BuildParameters()]
		----> (x) Está SEM PREVISÃO PARA PARÂMETROS WRAPPER OBJECTS! a não ser seja tratamento via parametro normal...
				----> ( ) incluso como parametro normal, mas criar um teste unitario para verificar.

		[ExecuteAOperator()]:
				----> ( ) Metodo.ExecuteAOperator: parece que esta função está calculando os
				operandos através de uma lista de expressao-parametro, mas estes operandos
				foi calculado previamente em eval.EvalExpressionPosOrdem(). Retirar este
				metodo e transferir para o Metodo.ExecuteAFunctionImportada, que precisa
				apenas da lista de objects dos valores de parametros.


			



[ClassificadorDeTokens]: POSSIBILIDADE DE MUDANÇA:
	------> possibilidade de codigo mais tolerante a falhas, porem gasto de memoria a avaliar:
	para obter o valor ascii de um char, basta apenas fazer um cast int no caracter: (int)caracter!
	simplifica e muito o Classificador.TableHash! não precisa de mapeamento e cobre todos caracter
	se não houver um valor máximo de caracteres, a tabela hash crescerá a um tamanho incomodo! (255 caracteres,
	para um hash de 3 letras, leva a um valor de tamanho de tabela 256*256*256, ou um valor 24bits de tamanho,
	mas para um hash de 2 letras, leva a um valor aceitavel de 256*256, ou 16bits de tamanho (65536)  porém as colisões
	serão muito mais frequentes, mas ainda O(1), mas com 2 ou mais acessos, e ainda com O(1))...
	------> o codigo está funcionando, apenas se esqueceu de um caracter nao mapeado, havera possivel falha...
_______________________________________________________________________________________________________________________________________________________________________________________
Scrum Daily 14.02:

[EvalExpression.Eval()][Testes]:
		
		----> (x) está sem previsão de expressão entre parenteses! modificação no design de expressoes entre parenteses,
		com uma expressao dentro da expressao entre parenteses, ficou sem implementação em [EvalExpression.EvalPosOrdem]!;
						( ) a testar;

		----> ( ) fixar com testes:
						(x) [TestesWrapperObjectsExpressaoAtribuicao]:
								----> (x) funcao importada nao está atualizando o escopo externo, apos a execução da chamada de metodo!
										----> (x) construtores wrapper nao estão obtendo o nome do Objeto Wrapper!
										----> (x) o algoritmo anterior estava validando, mas com a modificacao
										extensa da classe metodo, perdeu-se nos detalhes. com o objeto caller
										como parametro, ficou claro qual objeto deveria ser atualizado na chamada
										de metodo!
								-----> ( ) a procurar efeitos colaterais,porque o codigo foi alterado com muitas
								consequencias.


_______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.02:


[ExpressaoPorClassificacao][Testes]: 
			( ) expressao com parametros de uma chamada de metodo está invalido! com parametros como : metodoA(x+1,y+1), está devolvendo 4 Expressoes-Parametros!
			dificil agora consertar sem perder os outros cenarios de testes!!
							-----> (x) codificado a funcao de extracao de parametros, incluir no codigo de [ExpressaoPorClassificacao.ExtraiParametros];
							-----> (x) fixar a funcao de [ExpressaoPorClassficacao.ExtraiParametros()]
										-----> (x) teste para cenarios anteriores, com parametros de chamada de funcao como obj.metodoA(1,1), ou obj.metodoB(x,1), passou.
										-----> ( ) testes para cenarios como obj.metodoA(x+1,y+1);
														-----> ( ) atualizar os cenarios de testes de [Expressao] ( ), [ExpressaoPorClassificacao] (x),
														que contenham [ExpressaoOperador] para validação do teste.
																	----> FIXAR com os testes (ou atualizar):
																				( ) [TesteExpressaoOperadores]; (x) para exressao nao parametro, o codigo anterior é o que vale.
																				( ) [TesteInstanciacaoWrapperObjectVector]; ( ) expressao com vectors, fixar.
																				( ) [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]; ( ) 2a. chamada de metodo apos uma chamada de metodo,
																				não está funcionando corretamente;


[EvalExpression.Eval()][Testes]:

			(x) [TesteAvaliacaoChamadaDeMetodo] (x=-1.0);
							-----> double.abs(-1.0) está retornando 0, deveria retorna 1!
											-----> (x) expressao retornando como operador [binario], deveria ser [unario], mas o operador é [binario] e [unario] também!
														-----> (x) faltou especificar o tipo de operandos: binario, unario pre, ou unario pos. o valor default é binario,
														mas para operadores unarios, nao seta para unario, ficando como binario, que é o default
														------>(x) ante a extensa reorganizacao do codigo, em [Execute Mehtod], não há previsão pra
														expressao operador unario pre, unario pos!!
																	-----> confirmado, na funcao [BuilderParametros], não há previsão de processamento
																	com expressao operador. melhor, a avalicao default está com apeans uma sub-expressao;

																	-----> ExpressaoOperador precisa de uma lista de sub-expressoes,que possui mais de 1 sub-expressao
																	dos parametros da chamada de metodo.

														------> (x) o caso de expressoes parametros, com mais de um parametro independente, falha 
														porque se incluirá como uma expressao de operador todos parametros.
																	-----> funcao que acerta a expressao operador, retirando os operandos da lista de sub-expressoes,
																	reajustando a lista de valores que incluiu um opernado, mas este operando faz parte de uma operacao
																	com operadores, feito.

														-----> ( ) regredir o codigo para antes desta modificação: O PROCESSAMENTO DE OPERADORES FOI MUDADO,
														E O CODIGO ANTERIOR PODE FAZER ESTE PROCESSAMENTO!
														
														-----> ( ) ante a constatacao de parametros numa expressao invalidos numa expressao chamada de metdodo, com mais de 1 parametros,
							vai ser preciso, alem de [ExpressaoPorClassificacao], alterar este codigo...
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.02:

[Expressao]:
			-----> (x) modificado a funcao Expressao.ToString(), para compor com os tokens dos elementos sub-expressoes. 


[ExpressaoPorClassificacao],[Expressao]: motivo de testes: modificação em como se processa parametros de uma chamada
de metodo, se for ExpressaoOperador, nao mais se obtem toda a equacao sem uma expressao wrapper. visa a corrigir
a falha quando 2 ou mais parametros, a equação por extenso funde as equacoes dos parametros, se ambas forem com ExpressaoOperador.

[ExpressaoPorClassificacao]:

			----> FIXAR com os testes (ou atualizar):
					(x) [TesteExpressaoOperadores]; (x) para exressao nao parametro, o codigo anterior é o que vale. (deveria ser wrapp com uma expressao container?);
					(x) [TesteInstanciacaoWrapperObjectVector]; (falha na expressao de tamanho do vetor, era para ser
						expssSize.Elementos[0].tipoDaExpressao,	mas estava expssSize.tipoDaExpressao)
					(x) [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]; (modificacoes posteriores quebraram esse codigo.)
						não está funcionando corretamente;
					(x)	[TesteExpressaoCondicionalComConectivos];	
						cenario com codigo anterior;

[Expressao]:
			----> fixar com os testes:
					(x) [TesteUmaChamadaDeMetodo];
									-----> casting de numeros, em UtilTokens.GetMethodCompatible()-->Casting(), estava inoperante, devia 
									ao inves de olhar o parameter[x].Elemento[0].tipoDaExpressao, estava em parameter[x].tipoDaExpressao, ou seja 
									nao fazia o casting de numeros, quando na realizacao de um cenario em que tinha que fazer o casting, falhou,
									sendo em outros testes, nao precisava fazer o casting, os tipos de numeros em parametros da chamada estava com o tipo exato...


[Metodo][BuilderParameters]:
			-----> (x) regredir o codigo para antes desta modificação: O PROCESSAMENTO DE OPERADORES FOI MUDADO,
														E O CODIGO ANTERIOR PODE FAZER ESTE PROCESSAMENTO!

			
[EvalExpression][Testes]:
( ) [TestesFuncoesClasseString] (1a. avaliação);
			------> (x) contagem de parametros está duplicado!
							----> (x) a expressao de atribuicao está mal formado!
							----> (x) regressao para um teste em [ExpressaoPorClassificacao].


[ExpressaoPorClassificacao]:
			-----> (x) expressao atribuicao, constroi um objeto estatico, confundindo com a inclusao do objeto como
				1o. parametro da funcao!
						----> (x) falha em distinguir um objeto estático com um objeto nao estático.
							como a construcao é feita com um objeto estático, o motor de processamento
							de expressao, atribui como 1o. parametro o objeto...
						----> (x) em [Objeto], havia uma propriedade justamente para distinguir
							um objeto estático de um não estático, e que não havia sido utilizada
							no algoritmo de [ExpressaoPorClassificao].
	

____________________________________________________________________________________________________________________________________________________
[Projeto]:
		(x) o fato de encontrar tantas falhas foi devido A MIGRACAO DE [ExpressaoPorGrupos] para [ExpressaoPorClassificao],
			sendo na classe anterior [ExpressaoPorGrupos] ter sido totalmente testada, mas para a  migração, apesar da
			copia dos casos de uso, perdeu-se "alguns" detalhes, como objetos estaticos de nao estaticos...


[EvalExpression][Testes]:

	fixar com base nos testes:

		(x) [TesteParametrosMultiArgumentos]: objA.metodoB(x,1,1,1);
		(x) [TestsSplitFunction];
			-----> (x) utilização de um [WrapperObject] como parâmetro!
			-----> (x) confusao na obtencao de escopos, para construir os parametros da função: deveria ser
			o escopo externo (Escopo.ROOT), para funções importadas, mas estava como um escopo vazio (!),
			pois nao se viu, ao codificar diferenciando funções orquidea de funções importadas da linguagem base,
			necessidade de atualizar os parametros, com os valores de escopo externo...

_________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.02:


[EvalExpression]:
			-----> (x) nao esquecer de fixar o short cuts de ifs.
							----> (x) codificado novamente, pois não esta funcionando os cortes de condicionais.
							----> (x) testes:
										-----> (x) entrou em loop infinito! 
										-----> (x) entrar no calculo de short cuts, o proximo operador conectivo,
										parece que está no conectivo currente...
										-----> (x) há casos de uso a fixar: em processamento mesmo que não correto,
										entrou num dos ifs em que resultou em falha ao fazer o casting de [Expressao]
										para [ExpressaoOperador].
													----> (x) fixar a funcao: [ExecutaUmaExpressaoOperador()];
													----> (x) visualizacao maior, a expressao condicional seguinte
													não depende da expressao condicional anterior, ligado por conectivos:
													tem que de acordo com o conectivo, fazer a operacao logica dos
													resultados anterior e currente. aí retorna o resultado da expressao container!
										-----> ( ) teoricamente, a recursão das expressões condificionais,
										vindo da avaliação de expressoes condicionais divido em partes logicas,
										deveria resultar em expressoes condicionais como: (((a>b)&& (c<1)) || (a>5))
													-----> verificar urgentemente se a funcao [ObtemExpressaoCondicional],
													tem previsão para expressoes condicionais dentro de expressoes condicionais,
													como (((a>b)&& (c<1)) || (a>5));
[EvalExpression][Testes]:

	fixar com base nos testes:
		(x) [TesteAvaliacaoExpressaoCondicional]:
								
		(x) [TesteAvaliacaoAtribuicaoPropriedadesAninhadas];
						-----> (x) falha de processamento de [ExpressaoAtribuicao], para propriedades aninhadas.
										------> mais detalhe na migração de [ExpressaoGrupos] para [ExpressaoPorClassificacao]:
										o objeto caller da propriedade aninhada não estava sendo instanciado!
						------> (x) falha na operação de soma de propriedades aninhadas.
										------> propriedade aninhada sem valor inicial! (falha no cenario de teste). 
_____________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.02:

[EvalExpression]:
		( ) verificacao se há previsao para  [EvalExpression.ObtemExpressaoCondicional()], para (((a>b)&& (c<1)) || (a>5)) 
		(expressao entre parenteses dentro de expressao entre parenteses);
							-----> (x) nao havia previsão, codificada na funcao relatada.
							-----> (x) testes: operadores &&, || acrescentados ultimamente, nao tinham o tipo de operador: BINARIO;
							-----> (x) nao havia previsao de processamento de operadores &&,||,em EvalExpression.EvalPosOrdem();
							-----> (x) modificacoes no codigo para expressoes conectivas complexas quebrou o codigo!
											----> (x) regressao para teste mais simples, para consertar o codigo;
											----> (x) o codigo continua quebrado!
														----> (x) quebra no codigo da funcao: [EvalExpression.ObtemUmaExprssCondifional()];
							-----> (x) codificado novamente, codigo estava funcionando para cenarios sem conectivos entre conectivos.
											----> (x) processamento em sequencia das sub-expressoes, permitindo recursividade em expressoes
											entre expressoes, como p.ex., (((a>b)&& (c<1)) || (a>5)) 
							-----> ( ) testes;


[ExpressaoPorClassificacao],[EvalExpression]:
		(x) verificar se há previsão para mais de 1 chamada de metodo seguidos para propriedades aninhadas.
		parece que há em [ExpressaoPorClassificacao], mas não em [EvalExpression.EvalPosOrdem()].
							-----> (x) nao havia previsão mas a estrutura logica permite essa funcionalidade....
							-----> ( ) implementar propriedade aninhada seguida de mais de 1 chamada de metodo na sequencia.
_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.02:
		
[EvalPosOrdem][ExpressoesCondicionaisConectivas]:
		-----> (x) fez o processamento com conectivos, obteve a expressao condicional final, mas depois falhou! (nao parava, ate gerar erro ou loop infinito,
		mudado para condicao de parada se atingir o ultimo conectivo +1 );
	
[Testes]:	
		-----> (x) expressao condicional simples sem conectivos condicionais, teste passou.
		-----> (x) outro caso mais ou menos simples, sem usu de short cut de ifs, entrou em loop infinito!
						-----> (x) com novo codigo, passou no caso mais ou menos simples, e com SHORT CUT de ifs funcionando.
		-----> o algoritmo é avaliar expressoes condicionais em sequencia, 1 por 1, se for expressao condicional dentre expressao condicional, a sequemcia
		consegue obter essa expressao, e avalia, retornando um resultado que é guardado na pilha. se uma expressao condicional for 1 token conectivo,
		retira da pilha 2 operandos, processa com o conectivo, e guarda na pilha. muito detalhado, o conceito chave é obter expressao condicional em sequencia,
		fazer a avaliação e guardar na pilha o resultado. os conectivos são necessários para encurtar o processamento.
	

	fixar com o cenario:
				(x) [TesteParametrosMultiArgumentos];
						-----> anotação: ou o teste falhou por outro motivo, ou o processamento de classes no Classificador e na TabelaHash de eliminar
						classes de testes anteriores nao está funcionando. nao é grave, apenas a execução de muitos cenarios, pode falhar, porque
						as classes com mesmo nome mas de cenarios diferentes, pode levar a falhas.


[Andamento do Projeto]:
		----> apos os testes de avaliação de expressões, dando andamento com a biblioteca para jogos, com
		expressoes avaliadas com o escopo externo, se for uma função importada (com as funções da biblioteca relatada),
		ou com o EscopoSessaoDoMetodo, se for uma função orquidea.

_____________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.02: tarde:

[ProcessadorIDs][Instrucao Create]:
		-----> codificar a instanciacao de um objeto importado, como [Imagem]. Vai ser preciso
		criar uma propriedade em [Objeto] [isImport= false], e setar para true no caso de classes como [Imagem].
		se importado, a instrução create deverá chamar o construtor do objeto, e armazenar o [Objeto] no escopo currente.
							----> confirmado, instrução [Create()], não tem previsão para instanciar objetos de classe importado.
											-----> (x) classe [Classe] tem um campo isImport=false, sinalizando que a classe é ou não importada,
											-----> (x) classe [Image] herda de Objeto, possibilitando a instanciação por codigo orquidea!
											-----> ( ) codificar em create, a instanciacao de objeto como [imagem].
																----->( ) pensar mais como setar a classe como [isImport=true].
[GameLibray]:
		------> inicio da codificacao de classes base da biblioteca de jogos:
							-----> ( ) Imagem;
							-----> (x) ObjectGame; (processamento de desenho e atualizacao da situacao dos objetos registrados no loop game);
							-----> (x) LoopGame;
							-----> (x) Input;

		-----> (x) teste de instanciacao do LoopGame, criando uma janela, feito!...
		
________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.02:

[Library]:
		-----> (x) planejamento de como setar uma classe importada como [true]. Ou instancia a biblioteca, que faz
		a importação de classes e seta esse campo, ou de outro jeito.
							-----> (x) um caminho foi em [PareserAFile], setar a propriedade isImport=true,
							quando uma library é carregada.
							-----> (x) criar uma classe [KitDesenvolvedorDeGames], que importa as classes da biblioteca
							e as sinaliza como isImport=true;
[KitDesenvolvedorGames]:
		 -----> (x) classe que importa as classes necessária, sujeito a expanções de mais classes, como
		 importada, sinalizando que objetos desse classe podem ser instanciados, por instrucao create() dentre outras coisas,
							----->(x) codificando na instrucao create(), a funcionalidade de registrar objetos de classe importada.
											-----> (x) vai ser preciso modificar a instrucao create no programaVM.
							-----> (x) testes de compilacao;
							-----> ( ) testes de programa VM;
[Escopo]:
		-----> (x)em [Metodo.ExecuteAMethod()], atualizado a funcionalidade de [Escopo.EscopoCURRENT], possibilitando a avaliação de expressoes como [ExpressionBase]. 
		-----> (x)setar em [ExpressionBase], qual o escopo será chamado em expressoes chamada de metodo.
		-----> (x) setar no compilador, o Escopo.EscopoROOT, nao se esquecendo em [SystemInit], setar o Escopo.EscopoROOT=null;


[GameLibrary][Imagem]:
		-----> (x) funcoes de desenho, com  posicionamento da imagem.
		-----> (x) guardar as coordenadas de posicionamento.
__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.02 tarde:

[InstrucaoCreate][GameLibrary]:
		-----> ( ) testes em programa VM, da instrução create.
		-----> (x) importar a classe Vector2. classe Vector2 utilizada em RayLib é System.Numerics.Vector2!
		-----> (x) planejamento de input mouse, gamepad.
							-----> (x) mouse; (funcoes basicas de mouse: mouseDown, mouseReleased, mouseWeel, mousePosition);
							-----> (x) gamePad; (funcoes basicas: padPosition, padDown);
				------> funcoes basicas.

		
[Expressao.ExtraiExpressoes()]:
		-----> (x) lista de expressoes-parametros contem uma expressao wrapper, para evitar de muitos parametros,
		saber de qual é uma sub-expressao.
		-----> (x) testes de create e nova funcao [UtilTokens.FindConstructorCompatible], está levando
		em conta a expressao wrapper. 

_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.02:

[InstrucaoCreate]:
		-----> (x) testes em programa VM, da instrucao create para um objeto de classe importada, como [Imagem].
					-----> (x) nao está instanciando o objeto [Imagem];
					-----> maravilha, isto abre um leque de possibilidades enorme: objetos da Linguagem Base de
					que todo o projeto foi construido nesta linguagem, e que tem uma framework de reflexao,
					possibilita a importação de classes C sharp, podendo ser utilizado no codigo orquidea.
					antes apenas as funções importadas poderiam ser utilizadas, mas agora, objetos de classes importadas
					podem ser instanciadas! Em linguagens atuais, uma linguagem é feita em C++, principalmente
					suas extensões bibliiotecas, em C++. O projeto orquidea faz as bibliotecas em C sharp, e não C++!;
					houve estudos para codificar classes em codigo gerenciado, que permite utilizacao de classes C++,
					mas a API de reflexão permite uma interapobilidade muito mais significativa.

[GameLibrary]:
		-----> (x) funcoes de desenho de texto, cores, tipos de fontes.
		-----> (x) mudança de fontes, setar um tipo de fonte.
						(x) pesquisar como setar uma fonte para desenho.

		-----> (x - nao há, mas há desenho de parte de uma imagem:(x)) uma função para desenhar imagens dentro de imagens. (funcao basica);

[ExpressionBase],[GameObject]:
		-----> (x) testes com expressoes base simples, como escrever na tela um texto, dentro do pipeline do jogo.
		-----> (x) estudos para importacao da classe [TimerReaction], que é um timer automatizado, que 
		permite a execução de um código, quando decorre um lapso de tempo. Possibilidade de incluir em [GameObject],]]
		este timer. apesar que o game roda a 60 fps, (setado para 60fps), o que poderia gerar inconsistencias,
		mas o timer automatizado equilibra as diferenças de delta time decorrido...

[Classe],[Escopo.ROOT]:
		------> (x) todas propriedades estaticas publicas ficam armazenadas a [EscopoROOT], que é o escopo
		inicial, e tem acesso a todas classes, alem do codigo fora de metodos de classes;


_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.02 tarde:

[WrapperData]:
		------> (x) verificar se as expressoes de inicializacao de wrappers data, está sendo avaliada corretamente,
		porque agora toda expressao, vem sob uma wrapper expressao, o que pode não ser avaliado corretamente,
		porque o valor da avaliação é feito com [exprss.Elemento[0]], e nao [exprss].
							----> (x) verificado [Create],[Get],[Set], de cada wrapper data.

[GameLibrary]:
		------> ( ) codificar um programa VM para instanciar o loop de jogo, instanciar expressoes base de escrita na tela,
		e rodar o loop.
						-----> (x) programa VM, que instancia um loopGame, e executa um metodo deste objeto loopGame!
						-----> (x) outro cenario:
									-----> (x) confusao entre parametros de create: nao é preciso entrar em expressao wrapper.
									-----> (x) o escopo currente nao estava setado! (verificar se há possibilidade de
									instanciar o escopo currente em tempo de compilacao, justamente por ser o
									escopo do compilador, inicialmente).

									-----> ( ) verificar a avaliacao de [ExpressionBase], parece que nao está
									demonstrando na tela os textos de prompt. (nao estava setado o tempo do timer,
									o que faz com que as expressoes base sejam avaliadas a cada fps do loop de jogo!);

__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.02:

[GameLibrary][Testes]:
		-----> (x) é preciso instanciar as classes do kit de desenvolvimento na LinguagemOrquidea.
		-----> (x) parametros de metodos estava não o nome, que é curto, mas o ToString() que resultava no nome longo do parametro!
		-----> (x) [ObjectGame] não está sendo inicializada corretamente.
								-----> (x) problemas em como codificar uma string com aspas dentro de texto com aspas.
								-----> (x) não há previsão para setar o valor de uma string com um valor literal (constante!);
								o parser de tokens está separando a literal em 3 partes!
		------> (x) codificado uma funcao que recebe textos de chamadas de metodo, e 1 object game, que tem suas chamadas instanciadas.
								-----> (x) é preciso criar um ObjectGame, quando em compilação da instrucao Create()!
													----> (x) fixado com a instanciacao do [ObjectGame] quando na sua adicao no [LoopGame];

		------> (x) FALHA DE NATUREZA DESCONHECIDO ESTÁ IMPEDINDO A CHAMADA DE UMA FUNCAO ESTATICA [PromptHelloWorld], afim de
		visualizar se o LoopGame está processando as chamadas de metodo draw e update.
								-----> (x) para funções importadas, não havia previsão para parametros do tipo [Objeto], como extendeu 
								o escopo do projeto, com objetos importados como parametros de funções importadas, foi codificado o caso de uso parametro(tipo)==Objeto,
								setando o valor do parametro como o valor do objeto;


		------> (x) [LoopGame] operacional;	
						-----> (x) 2 maneiras de instanciar um [ObjectGame]: 
								(x) 1. instanciando o object game, e em seguida chamar a funcao [LoopGame.AddObjectGame];
								(x) 2. chamar a funcao [LoopGame.SetObjectGame], que retorna o object game instanciado segundo os parametros para esta função.

		-------> (x) jogo [hello world] escrito na tela, feito!

[Instrucao][ProgramVM]:
		-----> ( ) [InstrucaoCreate]:falha ao repassar o valor do objeto actual para o objeto que chamou uma função/variável.


		------> ( ) testes para os pequenos programas VM, feitos anteriormente, mas devido a modificação extensa
				no código, é bom testar para verificar se está operacional. Foi feito testes em ProcessadorIDs, com o código
				atual, e envolvia instruções como for, if, com execução de instruções via ProgramVM.
							-----> fixar os "pequenos" programas: 1, 3, 4.
							-----> falha na atualizacao de classes repetidas! nao está removendo as classes de mesmo nome!
											-----> foi feito exaustivamente o problema de classes de mesmo nome, instanciadas em cenarios diferentes!

_____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.02: (tarde)


[ClassificadorTokens]:
		------> ( ) novo algoritmo mais simples de atualização do classificador e da tabela hash:
		se a classe= "classeB" for RepositorioOO!=null, e que nao seja [classeB.isEstructuralClasse= false] E [classeB.isImport= false], deve ser removida.
							----> classificador: o codigo já estava quebrado! testes com falha de objeto classificador=null;
											----> cenario de testes desatualizado: nao estava com os singleton de [ClassificadorDeTokens] e [TabelaHash];
							----> constatado que o codigo anterior nao estava removendo a classe corretamente
							----> novo algoritmo implementado. testes no [Classificador] feito. MAS... em testes de [EvalExpression], houve falhas em um dos cenarios de testes.
							voltando para o algoritmo anterior.
							----> FALHOU porque a flag [Classe1.isEstructural] não está setado apropriadamente, para [true];



[Instrucao][ProgramVM]:

		------> falha grave no processamento de create, com parametro do construtor passado para uma propriedade do objeto caller...
							-----> () verificar a funcao [Method.ExecuteAMethod].

[ParserUniversao][EvalExpression.Testes]:

		------> (x) codificar um texto de expressao que tenha aspas dentro do texto, indicando um parametro do tipo literal.
							-----> o tokenizador não está funcionando quanto a este caso de uso: "Prompt.sWrite("atualizando")";
							-----> verificação no motor [ExpressaoPorClassificador], está gerando uma literal no parenteses fecha [")"]!
							
							-----> algoritmo de extração de literais: se encontrar um caracter aspas fora do inicio do token literal,
							mais especificamente no final do token, unir os tokens até encontrar um token com outro aspas, ou atingirr um token ponto-e-virgula, ou o final
							dos tokens. VER OS CENARIOS DE TESTES POSSIVEIS, em [ParserUniversal].

											-----> o objetivo é unir literais como "Prompt.sWrite"+aspas+"hello world"+aspas+")",	em um token literal somente.
											-----> observação: em [ParserUniversal], há previsão de literais, mas está sem previsão de sequencias de literais....
								----> depois de verificar o codigo do [ParserUniversal], verificicou-se que era lastIndexOf(), e nao indexOf();			
											-----> TESTES: falha em [EvalExpression], cenários de testes.
											
					------> SOLUÇÃO:
								-----> o texto, sem aspas iniciais: "Prompt.sWrite(" + aspas + "desenhando..." + aspas + ")" foi validado!;
								é so extrair o aspas do inicio e fim do codigo de expressao, e o teste valida...

					-------> O TESTE:
								------> chama corretamente a funcao Prompt.sWrite(), porem o parametro não foi o codificado. mas está chamando a funcao, houve progresso.
								------> ERRO DE NATUREZA DESCONHECIDO ESTÁ SETANDO O TEXTO da expressao para "";
												-----> o problema nao está no ParserUniversal.
______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.02:



(x)[LoopGame]: funcionalidade de compilar todo o codigo do game, ficando objetos no escopo do compilador [EscopoROOT],as classes em [RepositorioOOClasses];


(x)[GameLibray]: 
			2o. esboço de codigo de jogo: demonstrativo das funções Draw,Update, dos objetos LoopGame,ObjectGame, ExpresionBase, numa
			janela que escreve "desenhando", e "atualizando";
			O Daily anterior fixou alguns codigos que nao tinham previsao, como a classe [Objeto] fazer parte de parametros de uma funcao importada.


(x)[Metodo.ExecuteAMethod()]:
			-----> inclusao de constantes para sinalizar e mais legivel, a chamada da funcao [BuildParameters].


(x)[ClassificadorTokens]:
			------> (x) implementar o novo algoritmo de remocao de classes, no [ClassificadorDeTokens], e [TabelaHash], sem remover todas classes dentro destas classes.
			o teste anterior falhou porque o RepositorioOOClasse, estava com classes sem a flag isEstructuralClasse=true.
			------> (x) erro na codificacao dos elementos do classificador: o nome da classe do elemento estavam incorreto.
			------> (x) cenario de teste desatualizado: o cenario em que verificava o reset do classificador, estava sem inicializar o sistema:
			então, quando o cenario estava apos outro cenario com classes a compilar, resultava em erro.
							
[EvalExpression]:
			------> fixar com o teste:
							[TesteParametrosMultiArgumentos] (x); 1 dos casos de uso não verificava se o parametro=null. com a verificacao, o teste passou,
							e com um vetor multi-argumento!


[Instrucao][ProgramVM]:
		-----> ( ) [InstrucaoCreate]:falha ao repassar o valor do objeto actual para o objeto que chamou uma função/variável.
							-----> (x) sem exceções paralisando o cenario, mas os valores não foram os esperados.
							-----> (x) o escopo de parametros, justamente feito para guardar os parametros a serem passados à função orquidea, não estava sendo atualizado!
							os valores dos parametros não foi setado, resultando em null.
							
							-----> ( ) falha em instruções dentro da função orquidea: não está sendo avaliado, ou repassado para o escopo.
													-----> ( ) 1 dos testes, não está sendo construida uma atribuição com um número negativo!
													-----> (x) o valor do objeto [actual] estava sendo removido, então a passagem para o objeto caller que era por referência
													de ponteiros, perdia-se com a remoção!



							------> (NOTAÇÃO): ANTE AS MODIFICAÇÕES DE EXPRESSAO [ExpressaoGrupos] para [ExpressaoPorClassificacao], perdeu-se
							detalhes que já haviam sido testados exaustivamente.. o erros que se está resolvendo, deve-se a esses "detalhes"...


[ExpressaoPorClassificacao]:
		------> ( ) testes para atribuicao de propriedades aninhadas com valor numero negativo., vindo do cenario de [Instrucao][ProgramVM];
							------> multiplicação de objetos [actual]! (ignorar,porque uma expressao nao pode acessar um objeto [actual]
							fora de um metodo de classe!);
											-----> () falha possivelmente em [ExpressaoPorClassificacao.ProcessingOperators];

[ExpressaoPorClassificacao][Testes]:
		------> (x) cirurgia no [ClassificadorDeTokens] e [TabelaHashTokens];

		------> modificações no classificador e tabela hash de tokens, quebrou o codigo com alguns testes:
					-----> (x) possivel falha no [ClassificadorDeTokens], e [TabelaHashClassificador]; muda-se a posicao
					do cenario, e o teste falha.
									-----> (x) as modificações nos elementos de propriedade está errado!
											-----> uma das falhas foi na construcao dos elementos do classificador: nome da classe da propriedade
											confundido com o tipo da propriedade.
									-----> (x) falhas nas previsões da TabelaHash: nome de metodo não reconhecido,
									e retornado como nome de objeto, ou seja: não encontrou classificação na tabela hash.

									-----> (x) repensar na função de Remoção de classes de nomes iguais.
												-----> (x) a verificação de nomes de classes, vinda do processamento
												anterior do classificador, evidenciou quais classes deveriam ser removidas.
												-----> (x) faltando retirar do repositorio de classes as classes a serem removidas.


[ANOTAÇÃO]: a modificação no algoritmo de remoção de classes anteriores levou a uma verificação de que
os elementos da classe a remover não estavam sendo retirados do classificador e da tabela hash! porque o nome da classe
a qual o elemento pertence, foi confundido com o tipo do elemento! não serve para muito esta observação, mas enfim...

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.02:

[Vetor2D]:
		-----> (x) uma classe de vetores 2d, com funções como rotacao, magnitude, add, sub, get x, get y... classe System.Numerics.Vector2
		não permite setar x, ou y diretamente, sem instanciação de um novo vetor... evita instanciação de vetores a cada update().


[ExpressaoPorClassificacao]:
		------> (x) verificação de expressão de atribuição de propriedades aninhadas, com uma expressao de valor de 
		operador binario e unario funcionando como unario, seguido de um numero: falha ocorrida num dos cenarios
		em [Instrucao][Testes], nos testes unitarios de [create()];
						-----> (x)  processamento feito acertadamente.

[Instrucao][Testes]:

		-----> (x) Testes de instrucao [create]: a atualizacao de propriedades, objeto actual, e objeto que chama a instanciacao, foram fixadas no Daily anterior.
		-----> (x) Testes de instrucao [casesOfUse]: sabotagem do grosso, parece que o codigo anterior foi colado ao codigo atual.
		-----> (x) Testes de instrucao [if];
		-----> (x) Testes de instrucao [while];
		-----> (x) Testes de instrucao [for];
						
											
[ProcessadorID]:
		-----> (x) teste de passagem de valor entre variaveis, revelou PASSAGEM POR REFERENCIA ENTRE variaveis numa expressao de atribuicao!
		Todo codigo de atribuicao não está mantendo a atribuicao, se a variavel a atribuir mudar de valor, a variavel a receber a atribuicao muda tambem de valor!!!
		-----> (x) fixar em [EvalExpression], os valores passados em [ExpressaoAtribuicao], e se possivel o valor resultante da avaliação seja um clone, para
		evitar passagem por referência, e sim passagem por valor.

		-----> SEM RESOLVER A COPIA POR VALOR DE UM OBJECT, TODO CODIGO DE AVALIAÇÃO DE EXPRESSÕES ESTÁ COMPROMETIDO.
					----> MAS É UMA QUESTÃO DE INSTANCIAÇÃO DE EXPRESSOES, QUE ESTÁ ATRIBUINDO VALOR QUANDO SE INSTANCIA A EXPRESSAO, INVALIDANDO
					A AVALIAÇÃO DE EXPRESSOES POR EVAL_EXPRESSION...
							-----> (x) copia com casting em [WrapperData].
											-----> EVITAR de atribuir valor em [BuildExpressaoAtribuicaoExpressaoObjeto()], pois está avaliando
											previamente os valores, mas o codigo nao foi fixado! apos a instanciacao de uma expressao, depois
											de compilar, está setando o valor, antes de avaliar!!!
											-----> um atalho em expressao atribuicao, justamente quando for numero ou literal, estava atribuindo previamente
											os valores, na expressao!
															----> um conceito se o valor do objeto a receber for null, faz a instanciacao previa de valor,
															o que faz sentido, porque na compilacao, o valor do objeto é null...

							-----> (x) nao esquecer de setar o valor de objeto estatico, em [ExpressaoPorClassificao].
					-----> (x) trava de copia de valor de Objeto, em [WrapperData.Clone()], retirado, e o codigo continuou a funcionar.
		 -----> nao era um problema de copia por valor, mas de instanciacao de [ExpressaoAtribuicao]. uff.

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.02:

[ClassificadorDeTokens]:
		------> ( ) fazer o seguinte testes: compilar uma clase classe1, e depois compilar uma classe classe1 (mesmo nome), com todos tokens iguais,
		menos instruções de funções das classes. 

[Instrucao][PequenosProgramas]:

		------> (x) testes para os pequenos programas VM, feitos anteriormente, mas devido a modificação extensa
				no código, é bom testar para verificar se está operacional. Foi feito testes em ProcessadorIDs, com o código
				atual, e envolvia instruções como for, if, com execução de instruções via ProgramVM.
							------> testes, fixar com:
 										-----> programa fatorialRecursivo;
															-----> (x) adição de parametro por valor, decoration funcao(:r int a); (:r é o decoration);
															-----> (x) funcao construida corretamente;
															-----> (x) processamento de parametros de funcao com passagem por valor, operacional.

										----> na 1a. recursao, o valor do parametro vai a -1!, e na proxima recursão retorn 3, que
										é o valor inicial...
															-----> falha na avaliação de parametros:
															o escopo não é o certo, em [BuildParameters],
															sem o escopo, retorna o numero da expressão que é: -1!
															------> confusao quando chamar o escopo sessao do metodo, que contem os dados como os parametros.

		----> (x) todos programas testes passaram, um erro de verificação de qual objeto se espera um valor, gerou uma exceção quando se executava todos programas.
		

		-----> (x) as falhas: escopo errado no execute a method, no [BuildParametros]. o sistema de escopos está funcionando, com objetos globais, parametros, variaveis e
		objetos das instruções da função, ....


[GameLibrary]:
		-----> (x) codificar um programa que desenha uma imagem da tela!
									------> (x) testes, a imagem não está aparecendo na tela: tem que ter uma funcao em imagem que carrega o arquivo de imagem.
															---->loop sendo chamado, instanciacao de imagem feita, carregamento da imagem feita,
															adição da objeto jogo sendo feito, chamada a funcao que desenha a imagem sendo feita,
															porem a imagem nao aparece!
									------> pesquisar como se desenha uma imagem em Ray-Lib;
															 -----> tem que instanciar antes do loop, quando o sistema grafico foi inicializado.
															 -----> (x) codificar uma funcao que carrega as imagens registradas, antes do loop do jogo. 
															 -----> ( ) falha na execução da expressao base de desenho!!!
									-----> (x) passando a função de desenho não para a expressao base de desenho, mas diretamente no loop do game.


[Metodo][Construtores]:
	-----> (x) devido a reorganização do código da classe Metodo, os construtores de classes importadas perdeu-se, com passagem de parametros.
									-----> (x) codificar ou importar de versões anteriores do codigo em backup, a passagem de parametros para um construtor
									de classe importada.
									-----> (x) testes: graças a AI do Bing, encontrou-se o codigo que construia o objeto, versão anterior do codigo
									o objeto construido= null! Maravilhas de AI, a maçã é muito grande, grande demais....
			-----> (x) implementado também em [InstrucaoCreateObject];
									-----> (x) testes, falha na execução da instrução: o codigo nao reconhece a classe Imagem.
												-----> obtendo tipos do [Assembly do projeto]: e se não estiver no Assembly da Solução, há caso que pode ocorrer?

[GameLibrary][ObjectGame]:
			-----> (x) reorganizar a classe [ObjectGame], para retirar a [ExpressionBase] Draw, ficando o id da imagem do objeto registrado.
									-----> ( ) ficando a listar as imagens de acordo com o id do [ObjectGame] registrado.
____________________________________________________________________________________________________________________________________________________________________________________________________________
DailyScrum 01.03:

[ClassificadorDeTokens]:
		------> (x) fazer o seguinte testes: compilar uma clase classe1, e depois compilar uma classe classe1 (mesmo nome), com todos tokens iguais,
		menos instruções de funções das classes. 
								-----> (x) os headers nao remove a classe de mesmo nome antigo... mas na instanciação de classes em ExtratoresOO, obtem-se 
								a classe de mesmo nome mais recente;
								-----> (x) remocao logo no inicio de codigo de compilacao de uma classe: remove o header mais antigo de mesmo nome de classe que da
								classe que está sendo compilada.



[Importacao de Libraries Codigo Linguagem Base]:
			------> (x) verificar se há a possiblidade de adicionar classes de Assembly importados, para a Asssembly currente.
								------> (x) é possivel, adicionar uma referencia no Gerenciador de Soluções, como [Prompt.dll], reconstruir o objeto
								e utilizar normalmente as classes de [Prompt]. 
													------> isto significa que quem quiser uma libray externa ao codigo do projeto,
													terá que fazer este procedimento, se quiser fazer um executavel .EXE do Orquidea2023.
													------> há meios de utilizar as classes de um Assembly, porem exige codigo extra,
													toda vez que for utilizar a classe da library.


[GameLibrary][LoopGame]:
			------> (x) listar as imagens de cada objeto do game, não lista de imagens instanciadas. o codigo ficará melhor (!!!);

[GameLibrary][ObjectGame]:
			------> (x) construtor de [ObjectGame] reorganizado, afim de adicionar a imagem do jogo dentro do object game.
[GameLibrary][Imagem]:
			------> (x) codificar o redimensionamento da Textura2D de [Imagem]. chama-se a funcao [DrawTexturePro], com retangulos source e target, para
			redimensiomento de acordo com a [Biblioteca RayLib].

[GameLibrary][KitDesenvolvimento]:
			-----> (x) está faltando uma classe Random(), codificar uma classe Util, que tenha a função Random() (em mais de 1 modo).
								----> funcoes random, clamp. outras funcoes uteis está na classe [Vector2D] do kit (rotacao, normalizacao, magniture, add, sub, etc...).

[GameLibrary][KitDesenvolvimento]:
			
			-----> (x) importado a classe [RayLib], dando acesso a todos metodos da classe da biblioteca [RayLib].
								----> (x) testes iniciais, importação foi feita, mas falha na chamada de objetos estáticos de RayLib.
								----> (x) removida a importacao da classe RayLib, por falha nos metodos estáticos, que não instanciam uma copia de RayLib.

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.03 tarde:

			-----> a falha nos objetos estáticos, está no fato de instanciar um objeto estático, com valor = null! se instanciar o objeto estático, pode
			ser que metodos estaticos importados funcionem, para classe [RayLib].
			-----> (x) um programa com expressao Update(), que incremente a posição de uma imagem, fazendo se movimentar.
								-----> ( ) falha ao setar as coordenadas do objeto, via expressao update....
													----> ( ) as coordenadas estão sendo setadas, o metodo correto está sendo chamada,
													mas a mudança no objeto em jogo não foram mudadas.
													----> ( ) no escopo currente, em vez de setar a coordenada X, está criando uma variavel, não repassando 
													para objeto.
																-----> ( ) pensar mais em chamadas de metodos de objetos importados...
																-----> (x) tinha quase certeza que o codigo de [EvalExpression] tinha quebrado, mas não...

			-----> UMA SOLUCAO: wrapper as funcoes de ScreenWindow, foi possivel inicializar e desenhar cor de fundo, via um programa orquidea.

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.03:

[GameLibrary]:

			(x) fazer as classe do	[KitDesenvolvimentoDeJogos] herdarem [Objeto].	
							-----> classes instanciam e atribuem o [Objeto.valor=this].
			(x) funcao randomica de distribuicao normal.


[Objeto]:

			(x) codificar um casting, estando em [Objeto.Casting()];
			(x) problema de casting, aparentemente solucionado. Pode-se modificar [EvalExpression], para
			em vez de setar via [WrapperData.SetValor], adicionar um hook para [Objeto.Casting], afim
			de solucionar não só objetos orquidea de wrapper data, mas também certos objetos de classes importadas.


[Metodo]:
			(x) em ExecuteAfuncaoImportada(), se o objeto caller for Objeto, utilizar o campo valor do Objeto,
					-----> (x) fazer o casting se o objeto for de uma classe importada.
					-----> (x) permitir a modificação da referencia do objeto caller.
			(x) acertar os escopos em ExecuteAMethod, funcao importada, está repassando os parâmetros para o escopo externo.

[Objeto]:
			(x) codificado a instanciacao de objetos estáticos unicos, evitando perda de dados quando se executa um metodo, propriedade,
			com uma chamada estática.
						------> (x) implementado em [ExpressaoPorClassificacao], a instanciação de um objeto estático,
						que será utilizado em [Metodo.ExecuteAFunctionImportada()], substituindo (a fazer), o objeto [this.caller],
						que tamém é instanciado, mas em nesta função. notar que o objeto estático é instanciado nos dois casos,
						mas o objeto caller se perde ao termino da funcao. Mas o objeto estatico construido, preserva sua estrutura...
										-----> (x) testes em [EvalExpression].
										-----> (x) verificar a instanciacao de objetos estaticos da classes string, e double, a classe não é string, mas MetodosString
										e MetodosDouble. objetos estaticos string e double são feito com suas classes de metodos.
							
			( ) implementar em [ExpressaoPorClassificacao], o pool de objetos estáticos, quando se instancia um objeto estático.



[GameLibrary]:
			(falha geral) testes para mudanca de propriedade de um objeto game.
						-----> (x) o objeto game setado está no escopo root! Tem que tirar do escopo root (e escopo current).
						-----> (x) dificuldade em setar o nome do objeto criado.
									----> (x) o nome nem o tipo apos um invoke, é atualizado. mas pode-se retirar o nome e o tipo do objeto caller.
						-----> (x) dificuldade de obter um [ObjectGame] de um [Objeto] ([Objeto] nao é [ObjectGame]);
			(x) plano b: construir um metodo de desenhar uma textura, e no codigo orquidea, setar as coordenadas.
			(x) voltando para o plano a: um [Objeto] não somente contem um valor, mas [PROPRIEDADES], que podem
			ser setadas, e cair na malha de [Objetos] de Escopo.. 
							----> (x) 1a. parte feita: atualizar coordenadas,
							----> (y) 2a. parte: desenhar as imagens.


			------> (x) wrapper da funcoes: RayLib.DrawTexture(), RaybLib.DrawText, ter um sistema que
			registra as imagens, retornando um  id para o andamento do fluxo do jogo, e desenhe com DrawTexture(int idImagem).
____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.03:

[GameLibrary]:
			-----> (x) funcionalidade de loop, com update por expressoes base, operacional.
			-----> (x) mas desenho por funçoes wrapper de RayLib, direto no código, precisa mais uma olhada..
							----> (x) falha neste 2o. caminho: não está conseguindo carregar a textura!;
											----> (x) a falha estava na string do codigo orquidea: é preciso
											retirar as aspas de um texto literal no codigo! 
			-----> (x) maravilha! dois tipos de loop de games, um mais antigo, vindo de programação de jogos de um jogo anterior,
			mas complicado, envolve propriedades de [Objeto]. Porém, um mais novo, via funções [RayLib] wrapper,
			que mantem a logica do jogo num nivel mais "transparente", e por isso, é o loop a se desenvolver!
											-----> (x) o loop melhor, não precisa de propriedades de Objeto...
											-----> (x) programar com [Objeto] causa problemas, porque [Objeto] é uma
											classe de pano de fundo, dentro do compilador!


[ExpressaoPorClassificao]:
			------> (x) olhar no processamento de uma expressão literal: creio que precise retirar as aspas do texto,
			se tiver aspas, e sem quebrar o codigo.
											-----> (x) olha o desempenho de [ExpressaoPorClassificacao]! dobrou a quantidade
											de tempo!
															---> (x) muito codigo no metodo ExecuteAFuncaoImportada(),
															codificado para compor o Objeto com casting, gerou o gargalo...

[EvalExpression]:
		(x) problema de casting, aparentemente solucionado. Pode-se modificar [EvalExpression], para
			em vez de setar via [WrapperData.SetValor], adicionar um hook para [Objeto.Casting], afim
			de solucionar não só objetos orquidea de wrapper data, mas também certos objetos de classes importadas.

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.03:


(x)[ExpressaoPorClassificacao]: IMPLEMENTAR UM POOL DE OBETOS ESTATICOS:

		Para manter a integridade de objetos estaticos, que podem ter dados parametros de processamento na sua classe,
		CRIAR uma lista de objetos estáticos instanciados. Se precisar de um objeto estatico, obter desta lista! Mantem
		a integridade da classe do objeto estatico! Vamos supor que nesta classe de objetos estáticos, haja listas de objetos estaticos
		de controle interno. Se você instanciar o objeto estatico toda vez que utilizar para uma chamada de metodo,
		p.ex., perde-se estas listas de objetos estaticos do objeto estatico. fica resetado, perdendo todos dados previamente processaados.

[ExpressaoPorClassificacao][Literal]:
		remocao de aspas em ExpressaoLiteral, no codigo desse classe.


[GameLibrary]
			Sem Prioridade: 
					------> (x) verficar se o objeto caller, com seu valor setado em [ExecuteFuncaoImportada()],
					pode servir de um casting para objetos do jogo dentro do loop, transformando o object valor em ObjectGame,
					porque é um ObjectGame, mas como object. O casting capturaria os dados do valor object...
									----> para entendimento do codigo, mas o loop que utiliza esta aproximação não é o a ser utilizado.
					-----> (x) funcao [Loop.DrawTexture] deve ser por [Objeto], porque um int no codigo orquidea também é um objeto.
									----> (x) averigar um pouco mais, a funcao deveria ter parametros Objeto, mas não está.
									----> (x) falha de natureza desconhecido, os parametros estao com o tipo certo...
									----> (x) o codigo orquidea respeita os parametros de funcao! se voce instanciar um objeto do tipo "int",
									pode utilizar como parametro "int" de uma funcao!!!

									-----> (x) e se colocarmos uma expressao complexa, como "x+1", será que os parametros passarão?
												-----> sim, funciona! é que se está dentro do compilador do codigo, as coisas
												não são tão óbvias!
[GameLibray][ProgramaJogos]:
			-----> (x) testes de uma imagem se movimentando. (!) (codigo proximo do normal, utilizando nomeclatura de programacao C Sharp,C,C++,Java);


[GameLibrary][Utils]:
			-----> (x) funcao que converte [double] para [int]: parseInt();
			-----> (x) funcao que converte [int] para [doube]: parseDouble();
	
[GameLibrary][Text]:
			-----> codigo de jogo para desenho de um texto.
									-----> funcionalidade comentarios funcionando!
			-----> ( ) testes, o Texto nao está sendo desenhado! por problemas de tipo de fontes que nao está sendo instanciado.
									-----> (x) literal text sem aspas, feito na confusão de escrever codigo com aspas,
									necessário, mas para uma expressao literal, tem que retirar as aspas, se houver...
									-----> (x) texto desenhado, era um problemas de dimensoes da fonte:
									o tamanho da fonte deve ser em pixels! e um tamanho razoável para desenho.


[GameLibrary][Input]:
			------> (x) planejamento e construcao de codigo orquidea, para processamento de entrada de dados, Input.


[Problema estrutural](x):
			------> (x) funcao construtor está chamando a funcao [Metodo.ExecuteFuncaoImportado], mas
			sem parametros de construtor.
			------> (x) FALHA de natureza desconhecido está impedindo de inicializar corretamente a Tela de jogo.
									-----> problemas de sobrecarga de funcoes.
												-----> parece que ao construir uma chamada de metodo, os parâmetros
												não são guardados, quand se há uma funcao sem parametros!
						----> (x) uma falha na funcao de obter um metodo compativel com parametros, se os parametros do metodo fosse nenhum,
						saia do loop e reconhecia como found o metodo.

[GameLibrary][ObjectGame]:
			------> (x) classe redundante, não necessário, porque as expressoes de update e draw foram descontinuadas,
			o codigo roda diretamente num loop de codigo orquidea. (RETIRADO do codigo)

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.03 (tarde glorioso):

[GameLbrary][Text]:
			------> (x) investigar porque o texto nao está sendo desenhado. (tamanho da fonte é em pixels).

[GameLibrary][Vector2D] (e todas classes importadas!):
			------> (x) toda classe importada, tem que ser derivada de [Objeto]. E no desenvolvimento de classes importadas,
			todas propriedades tem que ter um casting a partir do [objetoInstanciado.valor]. É vitória!
							----> testes feito. TODA CLASSE IMPORTADA DEVE HERDAR DE [OBJETO], e cada propriedade
							tem que ter O CASTING da propriedade [Objeto.valor], seguida do valor da propriedade.
							ficou um pouco complicado para desenvolver classes importadas, mas o resultado é certo...
____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.03:

[Metodo.ExecuteFuncaoImportada]:
			----> (x) chamada com objeto caller correto feito, com execção da classe [string] e [double], que tem suas funcoes em outra classe.
			essa modificação permite atualização da situação de um objeto caller, sem que ter de construir o objeto caller, toda vez,
			perdendo dados anteriores.
							-----> (x) correções feitas com testes de [EvalExpression]. o cuidado é
							com as bibliotecas [string] e [double], que possuem seu codigo em outras classes que nao [string] e [double].


[EvalExpression][Testes]:
			-----> (x) fixar com o teste:
							[TesteAvaliacaoChamadaDeMetodo];


[GameLibrary][Input]:
			------> (x) criar um codigo de jogo com processamento de coordenadas de mouse, p. ex.
							----> (x) eventos de mouse não são eventos, no codigo de [GameLibrary], precisa
							estar explícito no codigo do jogo.
							----> (x) instanciação feita de [Vector2D].
							----> erro de leitura de propriedade [Vector2D];
										-----> (x falha na gravação do codigo do jogo, no path errado)[Vector2D] nao está sendo instanciado!
							-----> ( ) o programa nao está compilando.
										-----> (x) a falha está na atribuicao: vetor2d = Input.GetMousePosition(),
										estando em [EvalExpression.ExpressaoAtribuicao] a investigar.
										-----> (x) retirado o codigo de Vector2D, compila sem erros!
										-----> (x) o codigo compilado está sem a instrução [while]! (x) nao compilava..
							-----> () é parece que na construção de um bloco de instruções, está excluindo o ultimo objeto
							registrado.

							-----> (x) contornando, falha na avaliacao de [positionMouse.XX2D];
										------> (x) propriedade aninhada com atribuicao de int, com propriedade aninhada,
										não está retornando, retorna como null;
														----> (x) falha na instrucao [create]: o valor do [Vector2D] positionMouse
														está retornando null! sem um valor default o valor é null e se propaga!
																		----> (x) a falha está em querer construir um com
																		um constructor no metodo.ExecuteAMethod();

							-----> (x) falha de natureza DESCONHECIDO  está impedindo o processamento de Type.
										------> todos Types estão inoperantes.
														------> por ter mais de 1 matriz com mesmo nome,
														é feito com nomeExtenso Da matriz: namespace.nomeClasse.



(sem prioridade) [GameLibrary][Imagem]:
			------> ( ) investigar: uma imagem está sendo carregado 2 vezes!
							----> é certo que na Instrucao Create, cria-se uma instancia  no codigo de execução de create,
							e o codigo do programa VM jogo instancia 1 objeto: total: 2! 


(Verificar)(sim é verdade) : se o objeto estático está com valor != null, quando uma 2a. passada em diante do loop. A funcao
de objetos importados preve o valor== null, e seta para uma proxima vez o valor do objeto estatico. O objeto
estático estava devolvendo um objeto caller ==  null porque o escopo não foi atualizado com os objetos do escopo
de bloco, mais interno...
				------> lembrei de algo: para chamar um metodo estático, é sem objeto caller!!!!!!!!,
				você chama a função invoke(parameetros), e nada mais.
							------> ()[a decidir] codificar a seguinte situação: se o objeto caller.isStatic= true,
							fazer a funcao invoke(parametros), sem objeto caller! na situação presente,
							a funcao invoke(objCaller, parametros), mas isso é para metodos não estáticos!!!!
							------> (x) funcao estatica conseguiu ser invocada, com o codigo com objeto estatico!


____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.03:

[ExpressaoPorClassificacao]:
				-----> (x) construcao de xplayer=mousePosition.XX2 está inoperante!
								-----> testes, nao está setando o valor para xplayer! 
												-----> certo, por causa de get;set; não estão processando as propriedades
												atraves de API Reflexao, uma solucao testada é em vez de obter a propriedade
												diretamente, obter de uma funcao GetX(), por exemplo, que necessariamente 
												tem que faz os calculos.
												-----> (x) teste feito, com sucesso.

[EvalExpression][ExpressaoPropriedadesAninhadas]:	
				------> (x)  confusão de expressoes, de que recebe a atribuicao e a expressao da atribuicao.

[GameLibrary][testes]:
				------> (x) esboco de jogo, com entrada de mouse, processmento de posicao de mouse, desenho de imagem
				de acordo com a posicao x do mouse, feito.
				------> (x) fixado a expressao de atribuicao de saida do loop do jogo: falha de lógica, estava setando o contrario
				para a tela fechar.
				------> (x) testes para modificação de texto em um objeto [Text], feito;
				------> ( ) testes para modificacao de texto com uma funcao de [FunctiosGame] [parserDoubleToInt()];



[GameLibrary][UtilsGame][testes]: novos cenarios de testes.
							
				-----> (x) funcao ModidfyText operacional.
				-----> (x) funcoe randomica operacionais.
				-----> (x) funcoes FunctionsGame inoperantes, para funcoes de processo de [strings];
									-----> (x) constatação:  confusao em [Metodo.ExecuteAFuncaoImportada]:
									o objCaller.valor deveria ser objCaller.valor= result (resultado do processamento),
									mas está como objCaller.valor= this.caller (o objeto que chamou a funcao).
													-----> fazer a correcao, e testar. teste com avaliação de expressoes.
													verificar no caso de objetos importados que deveriam ser atualizados porque
													chamaram a funcao: obj.funcaoA().
																	----> falha para objetos importados, regressao,
																	e depois codificar a diferenciacao de objetos importados, de objetos de classes base.
																				-----> () modificacao feita, mas inocuo! pensar um pouco mais
																				como diferenciar os resultados.	removido a modificacao.

				-----> (x) FALHA DESCONHECIDO EM CALCULOS DE FunctionsGame.	
									-----> a falha está na compilacao de instrucoes while.
													----> inacreditável! mesmo sem instrução while, os testes continuam!
									
									

			
[LinguagemOrquidea]:
				-----> (x) calculo de expressoes complexas, com numeros e funcoes operacional.

[ExpressaoPorClassificacao]:
				-----> testes com FunctionsGame para strings,feito.

(Verificar): se o escopo de bloco está atualizando os objetos do escopo currente! O objeto estático do programa teste
de jogos não estava aparecendo, porque foi o unico objeto a ser instanciado no escopo de bloco! Não aparecia
no escopo externo, e a não atualização do escopo currente, com os objetos do escopo de bloco...
				-----> vai ser preciso quando entrar no escopo de bloco, atualizar os objetos do escopo fora
				do bloco, com o objetos criados no escopo de bloco...
				-----> e retirar do [InstaciadorDeBlocos], a inserção forçada de objetos do bloco para os objetos do escopo currente..
____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.03:

[ProcessadorIDs]:
		-----> (x) CIRURGIA MARCADA: enxugamento do compilador [ProcessadorDeIDs], handlers de instruções estruturadas (como for,while,if/else,...);
							----> (x) é simples: token de identificacao de um comando estruturado.
							----> (x) codificacao feita, decisao de execução no proximo dia, retirando o bloco comentado.
				-----> comandos estruturados aparecem, com a funcao [Instrucao.ToString()], com o codigo de cada instrução.
							-----> (x) a compilação verifica se os tokens de comandos estruturados estão corretamente. a verificacao de match sequencias era redundante..

[Instrucoes][Testes]:
		-----> (x) fixar com os seguintes testes:
							[TestesUnitariosCreate]

[GameLibrary][FunctionsGame][testes]:
		-----> (x) funcoes random, string, operacional.



[GameLibrary][Input]:
		-----> (x) planejamento para teste de input keyboard.
							----> teclado, com processamento de handlers via [ExpressionBase]!, operacional.
		-----> (x) acrescentar em [Input], um processamento de handler para [KeyPressed].

[GameLibrary][FunctionsGame]:
		-----> (x) de uma hora para outra, o desenho de textos modificados parou de funcionar.
							-----> parece que há duplicação de textos...
										----> instrução create, antes da hora de rodar o programa, já criava um objeto importado, duplicando o texto,
										no compilador [ProcessadorIDs], e na instrucao create em [ProgramVM].
[ProcessadorIDs][ProcessamentoDeBlocos]:
		-----> (x) subir as mensagens de erro de um escopo, para o escopo pai: erros de processamento de um escopo de bloco, não estão sendo registrados!

[Instrucoes][Escopo][Blocos]:
		-----> (x) acertar os escopos de bloco, para adicionar objetos no escopo de bloco, e retirar apos os objetos do escopo de bloco (Load/UnLoad) (Instrucao.ProcessingBloco).
						retirar	os objetos no escopo de bloco em compilacao, que já estavam presentes no escopo pai. (ProcessadorID_2).
												----> (x) não há escopo de bloco! embora fosse uma das primeiras preocupações de bloco: visibilidade de variaveis dentro de um bloco!
															----> (x) há escopo de bloco sim, está como bloco nó filho do escopo acima!
	
												-----> (x) objetos que estão no escopo pai E no escopo do bloco, removidos, preparano para instrucoes com blocos,
												acionar (Load/Unload) de objetos de escopos.

										
												-----> (x) na atual situação, E com não adição de objetos do escopo bloco removida agora, 
												não há como executar um bloco que contenha objetos instanciados dentro do bloco!
									
												-----> (x) escopos-folha são clonados também em [Escopo.Clone()]. 

												-----> (x) funcoes Load/UnLoad escopos (escopo-pai, escopo-no-filho bloco) codificados.

												-----> (x) em instrucoes com blocos, 
														Load(de escopo-bloco, para escopo currente), 
														e Unload(de escopo currente com objetos do escop bloco);
																	----> escopos de [for], [if/else], [while], [casesOfUde], com Load/UnLoad.

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.03:

[Instrucoes][Escopo],[Escopo]:

		-----> 1 cenario de testes, para falha quando se atribui uma variavel em um escopo-folha, para ver se propaga o erro para
		o escopo-pai.
				[ProcessadorIDs] (compilador):
							(x) fixar com testes: 
									[TesteIF_Else]
									[TesteFor]
									[TesteWhile]
									[TesteIF_Else]
									[TesteCompilarCorpoDeMetodos]
								
		------> (x) 1 cenario de testes, para processamento de 1 variavel instanciada dentro de um bloco, para ver se o sistema
		de blocos Load/UnLoad Objects, está funcionando.

	
[ExpressaPorClassificacao]:
		-----> (x) um case para token="=", com 2 ids antes. é muito frequente e pode estar gerando perda de desempenho.
						(x) fixar com o teste:
									[TesteAtribuicaoDeUmaFuncaoPorUmaVariavel];
						(x) otimização diminuiu 7 segundos no processamento, em relação aos cenarios de testes anteriores. cenarios de teste feito.
		
		-----> (x) constatação anterior verificou-se que uma expressao como: umTexto+funcaoRetornoString()  não compilava,
		e na mudança no motor engine de [ExpressaoGrupo] para [ExpressaoPorClassificacao], ficou o "detalhe", de que
		o tipo de expressão de uma ExpressaoChamadaDeMetodo é o tipo de retorno da funcao. cenarios de testes feito.




[GameLibrary]:		
		-----> (x) verificar gargalos de desempenho em jogo: está muito lento! (codigo orquidea, nao da biblioteca de jogos).
							----> (x) foi visto anteriormente que muitas instruções são de atribuição simples, como [int x=1;],
							e a otimização hoje, foi para atender estas instruções.
												-----> (x) otimização diminuiu o tempo de compilação!

[GameLibrary]:

		-----> (x) falha numa chamada de metodo: newText= "contando:  "+ functions.ParseFromIntToString(contador+1000);
							----> (x) isolado a falha, como [Expressao] que está lançando exceção.
							----> (x) falha na instrução de [ExecuteAOperator]: não havia previsão para parametros textos!

[Metodo.ExecuteAOperator]:
		-----> (x) é importante, mas o código aqui passa, de transformar a execução de operador, para um ExecuteAMethod, que tem mais possibilidades
		e cobre muito mais tipos de operandos.
							-----> feito. o codigo estava convertendo os parametros de operador, e muitos casos de outros tipos de operandos foram puladas,
							resultando um erro, justamente porque os tipos de operandos são mais que: numero, texto, ou Objeto!.
						

[ExpressaPorClassificacao]:
			-----> (x)(nao está) verificar se uma expressao como: [x=x+1] está sendo executado, corretamente.
								----->(x) fixar com o teste: [contador=1; contador= contador+1]; 
											----> (x) expressao: [contador= contador+1], está retornando como Expressao Objeto! Devolvendo
											o contador, sem processamento.
														----> (x) a otimização, não no caso principal (expressao atribuicao),
														mas o atalho de retorno do processamento quando o token é ponto-e-virgula,
														um atalho leve, sem muita otimização, estava impedindo
														o processamento de operadores, fora da malha de tokens!
[GameLibrary]:
		-----> (x) programa teste de jogo, com contador transformado em string, está funcionando, mas não está processando 
		o incremento da variavel contador..
		

[Library]:
		----> (x) perquisar urgentemente como um tipo importado em um Assembly externo, com Assembly.LoadAssembly("pathLibrary"),
		pode ser utilizado normalmente.
							----> tem que carregar o tipo importado, a partir do Assembly carregado.
										----> var assembly= Assembly.LoadFrom("nomeDaBiblioteca").
											  var typeClass= assembly.GetType("nomeDaClasseImportada");
							----> então, na instrução [create], tem que carregar de uma lista de assemblies de bibliotecas,
							para então instanciar o tipo desejado.


[Instrucao][if/else][while][for]: 
		----> (x) verificar se a expressao de controle pode ser uma chamada de metodo,
que retorna um boolean. ao que parece, há uma trava verificando se a expressao é condicional. se tirar a trava,
qualquer expressao, mesmo expressao chamada de metodo, pode ser uma expressão de controle (p.ex., while (!tela.close){ };).
					---->verificado, há previsão somente para expressoes [ExpressaoEntreParenteses], e [ExpressaoOperador]!,
					o código é antigo, e foi feito inicialmente, se consciência que poderia ser uma [ExpressaoChamadaDeMetodo].

[ExpressaoPorClassificacao]:
		-----> (x) fixar com testes:
						[TesteWrapperDictionaryText];

[ExpressaoPorClassificacao]:
		-----> (x) fixar com testes:
					[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
		-----> (x) token ";" estava sendo avaliado como nome de objeto!

[Anotacao]:	o interessante é que os erros passavam nos cenarios de testes!

____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.03:

[Expressao][ValidaExpressaoCondicional]:
		-----> (x) fazer um código mais enxuto, com verificação se o tipo da expressão for um booleno.
		a abordagem é clara, simples, e poupa um bocado de código anterior.
							----> se o tipo for bool, então é uma expressão condicional válida, ou
							se o tipo de retorno da expressao for [typeof(bool).Name]. veja que
							os operadores condicionais listados no codigo anterior retornam um bool.
		-----> sem previsão de operador unario "!"; pode ser feito com comparacao da expressao condicional com [false].

[EvalExpression]:
		-----> (x) fixar com o teste:
					[TesteAvaliacaoExpressaCondicionalComplexaDeConectivos].
							----> (x) expressao condicional com conectivos quebrou com a modificação de operadores condicionais.

		
[ExpressaoPorClassificacao]:

		-----> (x) expressao condicional sem tipo de expressão!


[Instrucao create]:
		-----> (x) criar uma lista estática de assemblies de bibliotecas importadas, para então instanciar
		o tipo importado desejado. verificar se há outros pontos a serem checados, se um MethodInfo não for encontrado,
		por exemplo. (um método tem um MethodInfo, verificar como se obtem este MethodInfo).
							-----> (x) confirmado, na ocasião de importar uma classe, instancia-se um [MethodInfo] 
							no metodo, que é chamado toda vez que se chama uma chamada de metodo.
							-----> (x) função [ExecuteAFuncaoImportada] precisa do construtor da classe importada,
							mas é obtida a partir do [MethodInfo], que é registrado no método!
		------> (x) lista de assemblies bibliotecas está em [LinguagemOrquidea.libraries].
							-----> instrucao "importer" carrega a biblioteca externa, importando propriedades, metodos (com
							o MethodInfo cruscial para chamadas de funcao importada).

[WrapperDataVector]:							
		-----> (x) está faltando em [Vector], a capacidade de executar uma chamada de metodo, a partir de um de seus elementos. 
					----> ( x ) planejamento em [WrapperDataVector], a capacidade de processar propriedades
					de um elemento do vetor.
									------> (x) em [WrapperDataVector.GET_Element],	após os tokens GET, se há um operador ".", seguido de tokens
									um elemento, seguido de um "=". é importante que a funcao de processamento GET seja antes de SET, porque o operador ["="] é utlizado para verificar se é SET Element.
					-----> (x) pode ser preciso fazer uma atribuicao do vetor temporario ao vetor que chama a chamada de metodo/propriedade aninhada.

[WrapperDataVector]: 
				(x) na extensão, pode ser preciso instanciar o vector temporario com uma anotação [WrapperDataVector].
									------> ( ) criado um objeto [Vector] temporario.

[WrapperDataVector]: 
				------> (x) alteracao do vetor temporario para um objeto temporario Vector.tipoElemento.
				------> ( ) pode ser necessario retornar o valor da expressao para o elemento temporário.

[ExpressaoPorClassificacao]:
				(x) ajuste com teste, de extensoes de [WrapperDataVector].
				(x) testes para [Vector] com extensão.
							(x) tem previsão, mas os testes novo não chegou a serem feitos novamente, ante a modificação extensa do codigo.
				(x) vai criar 2 expressoes! pausa para pensar em como instanciar 2 expressoes em 1 passada de tokens somente.
							(x) criada uma variavel que informa a quantidade de expressoes independentes processada, a ser utilizada na instrucao [ExpressionValid].
											(x) valor default para a variavel: 1 expressao independente.
[WrapperDataVector]:
				( ) fixar o caso de propriedades aninhadas associado ao Vector: está retornando 1 expressao, tem que have 2 expressoes.
							(x) expressao atribuicao está limpando a expressao de retorno!
							(x) agora a 2a. expressao está grudada!
							(x) confusão entre expressao de Atribuicao e expressao que recebe atribuicao, possivel falha em:
											(x) ----> [BuildExpressaoAtribuicaoExpressaoPropriedadesAninhadas].
											(x) ----> falha no calculo da 1a. expressao de propriedades aninhadas.
															----> (x) lista de tokens da expressao propriedades aninhadas não estava listados, resultando em perda de visibilidade do processmento!
											(x) ----> falha na inserção de operador ";", resultando em imprecisão no calculo da malha de tokens.
				(x) teste passou, mas para o restante do codigo...


				

[Projeto]: Pausa para pensar, em como impacta no ademais codigos.
______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.03:

[InstrucaoCreate]:
				modificar urgentemente como se dá a obter o Type da classe importada: vai até o ultimo operador dot, e obtem o nome da classe.
				do jeito que está, classes importadas tem que estar no namespacee [parser]! (classe importadas são bibliotecas).


[ExpressaoPorClassificacao]:
				(x) verificar o teste unitario de [ExpressaoPropriedadeAninhadas].

[EvalExpression]:
				fixar com os testes:
					(x) [TesteAvaliacaoExpressaoCondicionalComConectivos]
					(x) [TesteAvaliacaoExpressaCondicionalComplexaDeConectivos]
									-----> os objetos da expressao estavam com numeros em string!
									-----> processamento, mas não resultou no esperado.
									-----> a configuração para o cenario de teste estava errado.
					(x) [TestsSplitFunction]
					(x) [TesteAvaliacaoExpressaoCondicional];
									-----> outro cenario com configuracao errado, sem um parenteses na expressao do teste.


					(x) [TesteAvaliacaoExpressaoCondicionalComConectivos];
									-----> acabado de fixar, mas novo teste e falhou!
									-----> cenario com expressao incorreto.	
		[ExpresaoCondicional]: a modificação de expressao contendo operadores lógicos, feita logo anteriormente, invalidou os testes de [EvalExpression].
		não é por causa da modificação de [WrapperDataVector], extendendo o codigo, com modificações em [ExpressaoPropriedadeAninhadas] (em outra parte do codigo),
		não resultou em falhas.


[WrapperDataVector]:
				(x) pensar na possibilidade de atualizar o elemento que invocou a chamada de metodo, ou propriedade aninhada.
				(x) se tiver esta possibilidade, atualizar as funcoes de [ExpressaoPorClassificacao.SetProperty()], e [BuildExpressaoPorAtribuicao],
				que preve apenas no maximo 2 expressoes independentes!
									----> a formulação na ExpressaoAtribuicao é simples: as 2 ultimas expressoes
									formam a expressao de atribuicao, devendo ser removidas:
												exprssRetorno.RemoveRange(exprssRetorno.Count-2, 2); // é a formulação para a remoção de expressoes que entrarão para a expressao de Atribuição.
																									 
[ProcessadorIDs]:
				(x) em instrucao [InstrucaoValidExpress], atualizar no caso de processamento de duas expressoes independentes, numa unica chamada a [ExpressaoPorClassificacao].
				porque não havia mais 1 expressao independente por processamento, mas EXTENDEU O CODIGO, agora havendo a possibilidade de 2 expressoes independentes.

[ProcessadorIDs][Instrucao ValidExpress]:

				(x) atualizar a instrucao [ExpressValid] para adicionar 1 ou mais expressoes validas resultantes do processamento de uma expressao.
				isto porque com a EXTENSÃO DO CÓDIGO, PARA PROCESSAMENTO DE VECTOR COM CHAMADA DE METODO, OU PROPRIEDADE ANINHADAS, há este caso previsto.
									  -----> pensar como acessar a variavel [QUANTIDADE_EXPRESSOES_INDEPENDENTES].

[WrapperDataVector]:
				(x) em [extensao], adicionar +1 instrucao, para atualizar o objeto elemento, após a chamada de método,  ou propriedade aninhada.
				do jeito que está, o elemento que invoca a função ou variável, pode não ser modificado, pois está dependendo de uma passagem por referência
				de objeto.
										-----> (x) processo exato em 3 expressoes independente, só que na 3a. expressao, não é o [SetElement].
										se o processo falhasse, não resultaria em 3 expressoes esperado!
															----> 2o. cenario, processamento correto, mas a 2a. e 3a. expressoes estão unidas!
[ExpressaoPorClassificacao]:
			 (x) fixar a funcao [GetListExpressionsParamters()], ao que tudo parece está errado esta função.	
										(x) funcao com parametros dentro do aceitável: é uma função estática string, que inclui como primeiro parametro
										o próprio objeto caller.
			  (x) removido a variavel de contador de expressoes: inutil porque o calculo é automático.	
			  (x) verificar urgentemente se a funcao [ProcessGetSetWrapperData] comporta multiplas chamadas GET/SET.
										(x) removido a 3a. expressao, o codigo valida.
										( ) nao está funcionando com multiplas chamadas de metodos GET/SET.		
									
______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.03:

Tarefas:
[ExpressaoPorClassificacao]:
		(x) para construir varias expressoes independentes, que é o caso de [WrapperDataVector] expansão, foi criado uma funcao que
		extrai expressoes atraves do token ";". verifica-se se há mais de 1 token ";", se tiver faz o processamento, se não
		continua o processamento normal..

[GameLibrary]:
		(x) pendente a função de processamento de string, veja o programa de jogo currente.
							-----> (x) isolando a expressao, está processando normalmente, com um operando um texto e outro operando uma funcao imprtada, e operador de concatenação "+".
							-----> (x) falha na construção da expressao de atribuicao.
											-----> (x) a expressao de atribuição estava sem expressao wrapper!


[ExpressaoPorClassificacao]:
	-----> (x) fixar com os testes:
				(x)[TesteWrappersObjectVector];
							(x) problemas com tokens ";" duplicados, então caia na funcionalidade de extrair expressoes independentes, no entanto somente havia 1 expressao independentes!

				(x) [TesteWrapperObjectJaggedArray];
				(x) [TesteTipoDeExpressaoCondicional];
												

[WrapperDataMatriz], [WrapperDataDictionaryText]: 

				(x) acertar os tokensProcessed= tokensOriginais, porque pode haver tokens ";" nao contabilizados.


[ExpressaoPorClassificacao][chamada de metodo estatica]:			   
			   		----> (x) deixe-me explicar o que ocorreu: a contagem da malha de tokens falha, porque os parametros são alterados,
					devido a funcao exigir um token a mais, o proprio objeto caller...
									-----> falha invisivel nos testes, porque a função estática na classe string nao foi testada nesta classe! e porque
									só havia anteriormente apenas uma expressao independente, a malha de tokens era incrementada, passava da contagem de tokens
									mas parava porque havia chegado no termino da expressao. com mais de 1 expressao independente, o incremento a mais pesou...

					-----> (x) fixar com base na observação.
									-----> fixado, mas testai. (testes com cenario relatado acima neste Daily Scrum).

[GameLibrary][KitDesenvolvedorGames]:
					------> (x) importado classe [RayLib_cs.Color], no lugar de [System.Drawing.Color].
					------> (x) importado classe [RectangleCollision], para testes de colisão.

[EvalExpression][ExpressaoEntreParenteses]:
			-----> (x) ainda bem que houve uma expressão que seria utilizado num codigo de jogo, permitiu fixar
			uma falha no processamento de expressões matemáticas com expressoes entre parenteses, inclusive.

[Metodo.FindACompatibleConstructor]:
			-----> (x) tipos de pontos-flutuante: é [Single] na linguagem base, não [double] no projeto.
			-----> (x) tipos de inteiros: é [Int32] na linguagem base, não [int] no projeto.		

[GameLibrary][ProgramasTestesJogos]:
			-----> inicio de codigo de jogo funcional.
					-----> (x) jogo de colisoes: pensar em como implementar teste de colisão, com um [Rectangle].
					-----> (x) criado classe [RectangleCollisions], que encapsula a funcionalidade de colisões por bordas de retangulo.
									----> funcionalmente operante, detectou colisão conforme esperado.
[GameLibrary][Imagem]:
			-----> (x) implementar a funcionalidade de obter as dimensões da imagem.
__________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.03:

[GameLibrary][Imagem]:
			-----> (x) implementar a funcionalidade de obter o id da imagem, as coordenadas x,y da imagem, por metodos Get().
			a razão é diminuir as linhas de codigo, afim de diminuir a taxa de erros de codificação.

[ExpressaoPorClassificacao]:			
			-----> (x) problemas em Setters/Getters, não compoe com chamada de funcao + numero. p.ex., SetX(GetX()+1.0);
							-----> (x) nao havia previsão para parametros que são chamadas de funcao!
											-----> falha em expressao: imagem.GetX()+inc.
														-----> teste para esta expressao: nao está processando o token "+"!!!
							-----> (x) a nova funcao de obter parametros nao está conseguindo extrai parametros!
											-----> (x) o problema é como segue: ao extrair tokens de parametro, extrai
											apenas até o parenteses fecha de [imag.GetX()+1.0], deixando [+ 1.0] nao dentro dos tokens parametros.
														-----> saiu do loop infinito, mas nao está processando o operador "+", ainda..
																		-----> a falha está na atualizacao da malha de tokens,
																		quando se extrai uma chamada de metodo!
																		-----> (x) no caso de parametros=0, a malha de tokens falhava,
																		mas isso nao tinha importancia ANTES, porque terminava, 
																		ultrapassando o contador de malha. mas com esse caso
																		de uso, faz diferença, porque  há mais tokens após a 
																		chamada de metodo de instanciada.

							------> (x) com fixar este caso, quebrou o codigo! Entrou em loop infinito!
											----> (x) regressao para o codigo anterior mais estável.
											----> (x) verificar se o codigo nao foi alterado.
											----> (x) a falha estava em outra parte do codigo: quando se atualizava
											a malha de tokens, indo o indice de malha alem da contagem de tokens.
											para versões anteriores isso não fazia diferença, porque o codigo de expressao
											terminava com uma chamada de metodo, nao indo alem, como [img.GetX()+inc],
											o "+inc" não estava sendo processado, devido a contagem de tokens falha.
[ExpressaoPorClassificacao]:
		----->	nova bateria de testes.
		-----> [ProcessadorIDs]: compilado entrou em loop infinito!
							-----> ( ) uma falha grave: chamada de um metodo dentro do construtor da classe, o compilador entro no infinito!

[ExpressaoPorClassificacao]:
		-----> Verificar gargalo de processamento;
					(x) desempenho alterado ante a mais compilação de classes, em vários testes passado a limpo, sem 
					atalhos como instanciar objetos diretamente em um escoppo.
		-----> fixar com testes:
					[TesteOperadorIgual];
							----> (x) é preciso quando instanciar objetos, passar o codigo pelo compilador [ProcessadorIDs].
							----> ( ) não está retirando as sub-expressoes, durante a construção da expressão de atribuição!
										----> (x) confirmado, falha na extração de sub-expressoes anteriores.
														-----> ( ) fixar em [BuildExpressaoAtribuicaoExpressaoObjeto].
														-----> (x) falha ocorrida durante a contagem de expressoes independentes,
														na funcionalidade [WrapperDataObject]+[Funcao]/[Propriedade].

					[TesteChamadaDeMetodoSeguidaDePropriedadeAninhada];
							----> (x) expressao está cortando tokens!
											-----> (x) contagem de tokens mais uma vez, incorreto!
											-----> (x) parece que está faltando um pedaço do código!
											-----> (x) lembrei: propriedade após uma chamada de codigo nao tem! cenario de teste removido.


		-----> (x) fixar em [BuildExpressaoAtribuicaoExpressaoObjeto]. contagem de remoção de expressoes falha.
							----> modificacoes para compor com [WrapperDataObject].funcao/propriedade, alterou o codigo,
							que passou para esta funcionalidade, mas levou a falha colateral em outros codigos.

[ExpressaoPorClassificacao]:
		-----> (x) operacoes com [Getters/Setters] fixado.

[ExpressaoPorClassificacao]:
		-----> (x) retirar a função [CountTokensParametros()], sujeito a erros, e bem mais facil se obter a lista de tokens
		dos parametros, para depois fazer a contabilidade de tokens consumidos de parametros.

[ExpressaoPorClassificacao]:
		-----> (x) termino da funcionalidade de função sem objeto caller, a partir de processamento dentro de metodos de uma classe,
		se não tiver objeto caller, mas tiver dentro de uma classe, é previsto fazer o processamento de expressoes.
__________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.03:

[ExpressaoPorClassificacao]:
		------> (x) compilador entrou em loop infinito!, quando dentro de um metodo de classe, e chamada de metodo sem objeto caller.
							-----> (x) uma falha grave: chamada de um metodo dentro do construtor da classe, o compilador entrou em infinito!
												-----> a falha acontece se o metodo não tem parametros!
							-----> (x) é certo que a seção a investigar é justamente a seção de função sem objeto caller,
							porque a implementação de [Escopo.ClasseCurrente] foi prevista, mas não implementada.
												----->falha fixado, com o contador de parametros a partir de uma lista de tokens,
												nao uma lista de expressoes-parametros.

		------> (x) falha grave ao tentar acessar uma propriedade da classe, dentro de um metodo da classe!
							-----> (x) nova extensão do código: se encontrar uma propriedade sem objeto caller, e dentro de um metodo da classe currente,
							constroi um objeto [actual], para processamento.

		------> (x) falha fixado, mas não está havendo processamento de [actual.propriedade=5], no programa.
							------> (x) a falha está na construcao de [ExpressaoAtribuicao], no [ExpressaoPorClassificacao].
							------> (x) outra falha está na construcao da propriedade aninhadas com o objeto [actual].
												-----> (x) está calculando corretamente o valor da propriedade porem se perde no processamento em [EvalExpression].
															----> (x) objeto [actual] instanciado, se não havia no escopoSessaoMetodo, mas o correto é [escopoCorpoDoMetodo].

[ExpressaoPorClassificacao]:
		-----> fixar com testes:
					(x) [TesteChamadaDeMetodoSeguidaDeChamadaDeMetodo]. (x): tarefa cumprida, com cenario de teste fixado.
					(x)	[TesteObjetoActualEFuncaoSemObjetoCaller].	 teste com cenario incorreto: expressao com funcoes sem objeto caller, somente dentro da classe currente.

[ExpressaoPorClassificacao]:
		-----> (x) falha em operações aritméticas com objeto [actual].
						-----> problemas na construção de uma expressão válida.
										----> todos operadores sinalizados corretamente, mas ao construir a expressao de atribuição, falha.
					
						-----> a confusao: na construcao de uma ExpressaoAtribuicao,  o indice do operador [=] não é da lista de tokens,  mas do indice de dadosOperadores de [=]! 
						porque este indice diz respeito a sub-expressoes, não de tokens...
						
[projeto]:
		 -----> (x) expressoes com objeto [actual], para propriedades fixado.
		 -----> (x) expressoes aritimeticas com objeto [actual], fixado (com foco no código de classes orquidea, nao funcoes importadas), é importante operacoes dentro dos metodos,
		 de propriedades de classe dos métodos.
		 -----> (x) chamada de metodos dentro da classe, sem objeto caller, fixado.
		 -----> (x) chamada de metodo seguida de chamada de metodo, fixado. verificacao se a 2a. ou mais chamadas de metodo, se é do tipo de retorno da chamada de metodo anterior,
		 verificado. poderia ser como Javascript, que permite chamadas de função sem verificação do objeto caller modificado, e de varias chamadas de funções,
		 de funções sem retorno. preservando POO, mais parecido com C Sharp, dentre outras linguagens.
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.03:

		 ------> (x) o classificador está funcionando..
		 ------> (x) funcionalidade de reportar erros quando metodos de classe são compilados. as falhas sobem para o escopo maior.
		 ------> (x) jogo com vetores e funções, simular a função update, com um dos elementos do vetor (tipoELemento="Entity");
										----> primeira classe orquidea para jogos: [Entity], escreve na tela "Atualizando", "Desenhando", com uso de vetores de Entity!
		 ------> (x) incremento: desenho de uma imagem. falha na instanciacao da imagem da classe [Entity].
										----> ( ) falha de natureza desconhecido está impedindo a instanciacao da imagem do [Entity].
															-----> (x) construtor sendo chamado. mas falha na instanciação da imagem.
															-----> (x) uma falha estrutural está impedindo o correto instanciacao
															do objeto imagem.
															------> ( ) imagem sendo criada, mas o construtor está sempre sendo chamado.
																			----> e não chega até o loop do jogo, estando no construtor em loop infinito.
																			----> uma falha nao coberta nos testes, em Metodo.ExecuteAMethod(), na parte de instrucoes de uma classe orquidea, está gerando o loop infinito!
																			-----> o que ocorre é o seguinte: não tem como obter o nome da classe do objeto a ser criado, quando utiliza-se o [actual] objeto.
																							----> (x) contornado com  utilizacao do repositorio de classes, que tem propriedades registradas!
																							----> (x) indice de construtores de objetos importados, o indice do construtor é recalculado, para lista de parametros com mais de um parametro.
															------> (x) o metodo [FindACompatibleConstrutor] está quebrado!
										  ----> construtores em ordem, mas o programa currente nao roda.
															------>  ( ) falha na construcao da instrucao [while].
																		----> apesar de medidas foram tomadas, como DESINSTALAÇÃO
																		DE PROGRAMAS INSTALADOS HOJE, COMO O CHROME,
																		QUE NÃO INSTALEI, MAS É PORTA DE ENTRADA PARA A SEGURANÇA
																		DO CÓDIGO..



		  -----> falha na instrução img=v1[0].imageEntity.
						----> o problema é como segue: a instanciacao de v1[0] não foi instanciada, em tempo de compilação!
						então, quando se tenta acessar a imagem [imageEntity], resulta em null!
						tipos [Objeto] são instanciados em tempo de compilação! 
											----> um metodo [Entity.DrawEntity()], parece promissor.
											----> quando o codigo em [WrapperDataVector] não havia quebrado, a instanciação
											e compilação de [Entity.Draw()], [Entity.Update], funcionou para v1[0] (um Entity).
											
						---->(x) o codigo quebrou, com cenario em [WrapperDataVector]!						
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.03:

		   -----> (x) o que dá para fazer, e o que não dá, para vetores de classes:
						----> vendo a montagem de v1[2].funcaoClasse(), isto é possível, por que o conjunto de instruções é:
									----> objetoClase v11= v1.GetElement(indice); (com os nomes do que foi validado em [WrapperDataVector]);
									----> v11.funcaoClasse(parametros);
									----> v1.SetElement(indice, v11);
									
						o que se tira é: não dá para fazer algo como: loop.draw(v1[2]), porque esta montagem não dá: são 3 operações
						independente, não tem como fazer o loop.draw()!
						 
						mas... é possivel fazer v1[2].Draw(loop), porque preserva a montagem e a definição desta funcionalidade.
						
						-----> perdeu-se tempo e modificações no código, que inclusive quebrou o código do cenário em [WrapperDataVector],
						de tentar chamar por loop.draw(v1[2]), que está impossibilitado, porque v2[2] são três instruções!
			
		  -----> (x) compilado sem erros, porém.. a função [Loop.Draw()] nao está sendo chamada, falha no objeto estático.	
						-----> (x) suposta falha na passagem de parametros, como objetos importados.
										----> (x) classificador não está conseguindo identificar o objeto [actual]!
														----> (x) não estava identicando porque [actual] não 
														é nome de objeto, na tabela hash:é nome palavra chave. acrescentando
														[caller] token no processamento de objetos, o código funcionou.


		 ----> (x) na tentativa de uma lista com tres parametros no constructor, falha: os parametros estão todos no mesmo sub-expressão.
						 ----> tem que manter o foco, agora, para metodos,  propriedades, oquidea. a falta deste foco
						 deixou passar falhas como o ocorrido...



		  -----> (x) nosso primeiro jogo com classes orquidea! e com desenho com loopGame como parametro!
						-----> caracteristicas de linguagem empregado:
									-----> passagem de parametros de objetos importados.
									-----> passagem de 3 parametros para o construtor orquidea.
									-----> uso de vetores de classe, para escalar industrialmente muitos objetos [Entity].
									-----> uso de objeto [actual]!
									-----> uso de Getters/Setters, para setar propriedades de Entity.
									-----> uso de parâmetros no construtor.

		  -----> (x) jogo com classes orquidea, com processameno de teclado.
							-----> (x) falhas de compilação fixado.
							-----> (x) falha no processamento de teclado.
									-----> (x) fixado, mas expression base com chamada de metodo de [Entity] não está funcionando,
									tanto um set de propriedade de classe, quanto para chamada de metodo de classe!

		  -----> (x) uma falta de previsão foi o caso se o objeto caller for [actual], em [EvalExpression], devidamente fixado!

		  -----> (x) é valido o código, porque agora o foco está na linguagem orquidea, que não foi totalmente coberto com cenarios de teste.


[Input]:
	----> (x) menos codigo: em handlers de teclado, ao inves de construir com uma expression base, construir com o codigo em texto
	do handler, retirando a instanciação de expression base, que é instanciado apenas para parametrizar o handler de teclado.
		 
__________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.03:
 
[InstrucaoCreate]:
		----> QUANDO INSTACIAR UM OBJETO ORQUIDEA, setar o ob].valor=objInstanciado, porque o compilador só trabalha com o objeto [valor];
[ExecutaFuncaoImportado]		
		-----> this.caller= objCaller.valor, E SE this.caller=null, então permitir um construtor instanciar um novo objeto.
		
 [GameLibrary]:
		-----> novo jogo: instanciar muitos [Entity].
						----> (x) codigo limpo, sem falhas na compilação. só que não mostra as imagens.
						----> (x) depurador recuperado!
						----> (x) problemas de multiplicação de objetos, na execução de um programa VM.

						
[WrapperDataVector]:
		-----> possivel falha, fixada em [Vector.Clone()]: sen clonagem do campo valor! e também a funcao [Vector.SetElement]!
						-----> (x) verificar em outros WrapperDataObject, a função Clone();


[WrapperDataVector], [Vector]:
		-----> fixar a inicialização de [Vector], está como 10, mas no cenario é 20.
						-----> (x) encontrado a falha: na funcao ExecuteFuncaoImportada, há o construtor que instancia o vetor com size=10,
						nao size=20!
						-----> (x) funcao [Vector.SetElement()] está alterando as dimensões do [Vector]!
										----> (x) falha na seguinte funcao: WrapperData.CastingObjeto();

						-----> (x) elementos em [Vector] não estão sendo setados!
										 ----> (x) propriedade valor está contendo o vector atualizado!
															-----> tem que trazer o valor do objeto para o objeto Vector.


						-----> (x) SetElement/GetElement agora utilizando o campo valor, para operações,
								porque o compilador somente entende processamento com o campo valor.
						-----> (x) acesso a elementos de vector, com atribuicao, operacional.



[EvalExpression]:
		----> fixar com os testes:
							[TesteAvaliacaoChamadaDeMetodo]; (x)
							[TestesFuncoesClasseString]; (x)
							[TestesWrapperObjectsExpressaoAtribuicao]; (x) os vetores estão atualizados no campo valor que é um object Vector.


[InstrucaoCreate]:
		----> (x) se o objeto a criar for do tipo [Objeto], ou seja um objeto orquidea, instanciar mesmo se já tiver sido instanciado,
		porque há problema de referencia de ponteiros.
		

[todos WrapperData]:
		-----> (x) modificar as funções [SetElement/GetElement], para funcionar com o campo [valor].
						---->(x) Vector;
						---->(x) Matriz;
						---->(x) JaggedArray;
						---->(x) DictionaryText; 
									----> GetElement/SetElement, atualiza o objeto, e o campo valor.
[Vector]:
		----> (x) fixar com testes:
					[TesteInstanciacaoVector];



[ExecuteAMethod]
		-----> (x) vazamento de objetos de escopo, para o escopo externo.
						-----> por algum descuido quebrou o codigo: remoção/inserção de escopos, causou a multiplicação de objetos!

[InstrucaoCreate]:
		-----> (x) setado a propriedade valor.
[WrappersData]:
		-----> (x) removido o campo WrapperData.valor, mantendo Objeto.valor (confusão de propriedade).

[Metodo.ExecuteAFuncaoImportado()]:
		-----> (x) o objeto [this.caller], é senão o proprio objetoCaller.valor! lembrando disso quando chamar
		o construtor (não deveria, mas para não paralisar o código), e setando o objeto.valor= this.current.valor.


__________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.03:

[GameLibrary]:
			-----> () testes para esboço de programa de jogos com muitos objeto [Entity];
						-----> (x) as imagens não aparecem!
						-----> (x) coordenadas de imagens todas para [0,0];
					------> falha generalizada para coordenadas em  todos esboços de jogos!
								-----> mantem a coordenada do construtor.

			------> voltou ao mesmo problema de ontem, fixado: o vetor está sem seus elementos!	
			porém em outros cenarios, está funcionando perfeitamente!
					------> falha de natureza desconhecido, ou está sabotando o depurador, não setando elementos do vetor,
					e não modificando as coordenadas de imagem.

					------> removeu-se a atualização do escopo externo para método importado, impossibilitando a 
					alteração no [Vector] de [Entity]! [Vector.valor] está com os dados dos elementos dos [Vector]!

[GameLibrary][LoopGame][Imagem]:
					------> (x) problemas de elementos em [Vector], sanados.
					------> (x) problemas de parametros passado ao construtor de [Entity], sanados.
					------> ( ) imagem de desenho está resultando em null!
								------> (x) parametros no construtor de [Imagem] correto.
								------> (x) instanciação de Texture2D sendo feito.
								------> ( ) conforme observado, a lista estática de imagens está vazia!
								------> (x) vetor carregado. A imagem de [Entity] está em [Imagem.valor]
								------> (x) lista de imagens estatica sanados. não está carregando porque
								na [Imagem] já faz a instanciação. experiencias passadas isso não deu certo...(imagens
								com width:0, height:0).


[Vector]:
			-----> [Vector] de [Entity] com elementos instanciados corretamente. propriedades de [Entity], com [GetElement]
			carregados corretamente. imagem estocada em [Entity.image.valor].

[WrapperData]:
			 -----> verificar se há mais funcoes dos WrapperData que precisem do acesso [valor].

__________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.03:

[projeto]:

			-----> (x) o problema das coordenadas: viu-se que as coordenadas estão todas com o ultimo valor.. por que? porque está
como passagem por referência, não por valor!! Ou se acrescenta o atributo :r (read only), ou se define que parametros
que são numeros ou strings a passagem é por valor, setando o campo de passagem, para passagem por valor!


[GameLibrary]:
			------> (x) verificar o carregamento de [imagem], porque está estocado em [valor].
						----> ao instanciar um objeto de classe importada, um [Objeto] é instanciado,
						e a unica diferenca é que o [Objeto.valor] contém os dados do objeto importado!
			------> (x) desenho fixado (com campo object.valor). verificando as coordenadas da imagem...
			------> (x) coordenadas não estão sendo atualizadas!  
						-----> (estão sendo atualizadas, mas o desenho não muda de lugar)..
						
[LoopGame]:
			------> removido a funcao Draw(Imagem), ficando a funcao [DrawTexture].
						-----> SEM DEPURAÇÃO NÃO DÁ!! O CODIGO É MUITO EXTENSO.

[Metodo]:
			------> (x) Fixado a passagem de parametros por valor, não por referência.

[GameLibrary]:
			------> () todos Getter/Setters estão inoperantes!! SEM OS GETTERS/SETTERS os jogos não poderão ser feitos,
			não sem estender o codigo em muito, com variaveis para cada objeto!


[RectangleCollision]:
			  ------> (x) metodo estático de colisões funcionando.


[GameLibrary][sendo feito]:
			 -----> CONSTRUÇÃO de uma classe ORQUIDEA, não classe importada, para processamento de dados de um jogo, como leitura de teclado, chamadas de funções
					  de colisão, de objetos do jogo, etc.. (FOCO EM CLASSES ORQUIDEA, como foi requisito nesta manutenção aditiva).
									----> seria interessante ter um objeto singleton de [LoopGame], setado na construção desta classe, afim de acesso
									dentro de classes de um jogo...
__________________________________________________________________________________________________________________________________________________________________________________________________________________
[GameLibrary]:
			-----> falha de natureza desconhecido é setando todas coordenadas para uma mesma coordenada.



	------>	(x) copia por valor para int,double, e string, explicatamente,
	mas as coordenadas insistem em ficar clonadas por referencia!
				-----> (x) não é problema de valores int,double ou string, mas no objeto entity que está sendo utilizado.
				-----> (x) um problema de [ExpressaoAtribuicao]!, quando se diz v1[i]= e1, é uma expressão de atribuição!
				e se não me falhe, é com cópia por referência!
									-----> metodos de atualizar a posição de entities estão funcionando: porem 
									para todos enities (2 no atual cenario).
				-----> (x) não é´problema de cópias de uma mesma textura.
				-----> ( ) o problema é no construtor na instrução [InstrucaoCreate].



	-----> sem os vetores de entity não é possível criar um jogo como [Sokoban], que tem  paredes de entities, muitos objetos.
	[Sokoban] é o jogo que pretendo finalizar a manutenção.
__________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.03:


[Objeto actual]: objeto com propriedades atualizadas.objeto actual é cópia do objeto caller, depois da função do construtor,
o objeto actual é clonado para objeto caller, atualizando o objeto caller das instruções do contrutor que chamam [actual].
						(x) o [Metodo.ExecuteAMethod()] estava criando propriedades de classe do objeto caller, deveria
						ser os dados do objeto caller.
						(x) fixado o codigo de objeto actual, para propriedades aninhadas. para funções, é permitido instanciar
						se objeto actual.

						(x) objetos instanciados corretamente, mas falta a atualização no Vector.
						(x) atualizacao dentro do [Metodo.BuildParametros], obtendo o valor do objeto-parametro, no escopo.




[Vector]: (x) construir um cenario com uma classe orquidea, com dados no construtor a serem passados às propriedades da classe.
		  (x) isolado a falha, todos elementos do vetor contem os dados do ultimo elemento,um problema de referencia de ponteiros.
		  (x) os valores do vector está no campo [Vector.valor.VetObjects], não no [Vector.VetObjects]
		  
[Vector][cenario mais complexo]:
		  -----> (x) faltando setar o valor de entity-propriedades, numa malha de for.	


[EvalExpression]:
		 -----> fixar com os cenarios:
						(x) [TestsSplitFunction];
									(x) (Revisar todo codigo de funcoesString que tenha como um dos parametro um Vector, setar para Vector.valor);

						(x) [TesteAvaliacaoChamadaDeMetodo]; (codigo feito na tentativa de obter parametros em [Vector] de classes);




[Metodo.ExecuteAMehod]:
	------> (x) arrumado o codigo do objeto actual, e também a atualização dos parametros-objeto, com valores atualizados do escopo.
	------> (x) removido escopo de classe, o objeto caller contem todas propriedades de sua classe. já foi feito na construcao do objeto no construtor,
	que obtem todas propriedades de classe do objeto.

[Metodo.ConstructorOrquidea]:(já feito)
	------> (x) no construtor, não se está criando as PROPRIEDADES DO OBJETO! Não é sabotagem nem erro exotérico,
	quando no construtor, criar as propriedades do objeto, lendo a DEFINIÇÃO DA CLASSE no repositorio de classes,
	e criar as propriedades.
			----> (x) verificar se as propriedades de classe, do objeto [actual], está lendo o objeto correto, digo as propriedades
			corretas.
			----> (x) por que somente agora se verificou o construtor? porque o foco não estava em [Objeto], 
			mas funções e objetos importados...

[MapaDePixels]:
			------> (x) pesquisar o GetPixel em RayLib.
						----->(x) a classe Bitmap, BitmapData, foram classes bastante utilizada anteriormente, por mim. E GetPixelColor em RayLib_cs
						está sem informação de metodos sobrecarregado..


[Metodo.ExecuteFuncaoExportada]:
			------> (x) como objetos [Objeto] são da infraestrutura da linguagem , não faz sentido passar um [Objeto] como parametro,
			e sim o que o Objeto guarda como valor. Setado parametros [Objeto] como [Objeto.valor].
	

[Gamelibrary]:
			------> (x) esboço de jogo para instanciar várias entities, resultou em [Vector.Elements] como esperado. 

__________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 27.03:


[Escopo.Current],[Escopo.ROOT]: são copias por referencia indicando o escopo na instrucao que está sendo avaliado. para expressoes que não precisem de escopo para avaliar, como [ExpressionBase].


[GameLibrary]:
			-----> (x) [EsbocoEntities]: objetos Entity instanciados corretamente.
			-----> (x) cortaram a instanciação de imagens! a lista de imagens está vazia!, e as coordenadas de desenho estão (0,0);
								-----> (fixado) [Imagem.valor] está sem .valor!=null;
								-----> (fixado) Vector está sem elmentos!
											-----> (fixado) falha na funcao [ExecuteFuncaoImportado()], estava setando um valor de parametro, como [Objeto.valor], mas [valor era null!].

[Metodo.ExecuteAMethod()]:
			------> ou É SABOTAGEM, OU há problema de passar os parãmetros para uma função orquidea!
						-----> o objeto [actual] não está com valores de propriedades atualizados!(null na verdade);
											-----> o objeto caller da função está sem valores atualizados, e também não há valores atualizados no escoopo!
						-----> (VEJA ISSO) uma pista: quando se chama um entity, chama-se um elemento de um vector! e o elemento
						de vector carrega valores atualizados!
											------> será que a função [Vector.GetElement] está carregando os valores reais do elemento?
														----> o resultado da operação de retorno de Vector.GetElement() está correto, mas o valor não está sendo repassado.
														----> resultado da atribuição está sendo repassado também, mas o valor de retorno não está correto.
																	-----> o objeto de retorno da [ExpressaoAtribuição] não está no escopo!!! se tiver, os valores de propriedades de objeto
																	serão repassados!
																					----> (fixado) O ERRO: FIXOU quando o objeto de atribuição for uma [ExpressaoPropriedadeAninhada],
																					e não em [ExpressaoObjeto]!
														-----> valores atualizados VISUALIZADO! está no escopo, no campo [Objeto.valor] do objeto caller!

[GameLibrary]:
			------> a falha no desenho das imagens permanece! está em (0,0)!
								-----> por culpa de propriedades de [Entity] não é: os valores estão diferenciados e não nulos.
								-----> veja problema relatado acima: valores desatualizados de [objeto caller], e [objeto actual].


[InstrucaoCreate]:
			------> (x) removido o processamento de classes herdadas, porque quando se herda, soma-se as propriedades e metodos herdados, como se fosse da classe herdeira.




[MapaDePixels]:
			-----> (x) testes com uma imagem de um mapa, e um conjunto de cores que representam tiles.


[LinguagemOrquidea]
			------> (x) testes para herança de classes.
						-----> metodos e propriedades sem nome longo, como especificado no começo do projeto, mas cancelado porque o programador tinha que adivinhar se era nome curto ou longo.

__________________________________________________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 28.03:

[Metodo.BuildParameters]:
			------> (x) deixar para o avaliador de expressões calcular um [ExpressaoObjeto], o atalho está invalidando a cada mudança de cenários de classes.
			

[Escopo]:
			------> (x) lista de escopos de bloco de [Instrucao] criada, e setadas em [ProcessadorID_2.BuildBlocos];
						-----> (x) precisa agora para instruões while, for, if/else, acessar os escopos de bloco. a solução anterior não estava funcionando,porque acessava o escopo externo,
						não o escopo dentro de função.
			
[EscopoBloco][Constatação]:
			------> o Escopo de bloco não está funcionando! por isso é que os objetos [Entity] dentro da malha
			while, presente cenario de teste, não estão registrados!
						-----> (x) confirmado, o escopo de bloco registra os objetos dentro da malha, mas por design de instrução, estão registrados no bloco de instrução.
						ou o escopo de bloco não está sendo registrado, ou não está sendo copiado para o escopo externo, escopo currente, escopo raiz...

											
											


[Metodo.ExecuteAMethod()]:
			------> (x) atualizar o objeto caller, para os valores do escopo, com o nome do objeto caller, campo [Objeto.valor], se o objeto caller for um [Objeto]!.
						-----> fixar. verificar se ao fixar o escopos folha, também fixa esta falha.

[resumo]:
			------> vetor com unidades fixado.
			------> escopo de bloco fixado.
			------> atualização do objeto caller feito.
			------> remoção da instanciacao do objeto da atribuição, ante aos dados do escopo de bloco, que lista o objeto da atribuição.
			------> (x) fixar a passagem de parametros para vector element.

[Esboço de Jogo]:
			------> (x) 1 das imagens está sendo instanciadas e posição atualizada, mas outra imagem não aparece.	
							-----> () o objeto actual.valor estava com nome do objetocaller, deveria ser [actual.nome="actual"].
											-----> está havendo 2 objeto [actual], um no escopo externo, outro no escopo do metodo.
[Vector]:
			
			------> (fixado) retrocesso! elementos do [Vector] não atualizados corretamete, está em NULL.
							------> (fixado) objeto caller com propriedades NULL. (atualização invalidante de passagem do objeto [actual] para o objeto instanciado).

[Metodo.ExcecutaAMethod()]:
			------> o problema está em volta do objeto [actual]: se no escopo do corpo do metodo, se tiver 
			listado um [actual], é então apos a execução da função tem que atualizar o objetocaller. 
			------> e também acertar o [Objeto.valor], de [actual], que está com o nome do objeto caller (o campo valor).
			------> VERIFICAR URGENTEMENTE TAMBÉM se o objeto que recebe atribuição de GetElement(), está sendo 
			atualizado, no escopo, e também no objeto diretamente.

[Instrucao]:
			-----> (x) removido muitas funções que não estavam sendo invocado, relacionado a instrucao CreateAnObject, que não eram necesárias porque o objeto criado já tem
			todas propriedades herdadas ou não.						
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.04:


[Vector]: instanciacao de Vectors.Unidades está com 1o. propriedade com valor nulll!
		
			------> (fixado) não está havendo processamento de tokens do corpo do metodo.
			------> aparentemente está tudo funcionando, mas de dailys anteriores, a instanciação de objetos estava funcionando.
			sem a instanciação correta, não há como fazer o processamento de vetores. isso é visto EM VÁRIAS LINGUAGENS, NÃO É MARCA REGISTRADA
			EM C SHARP, JAVA, C++,...
							-----> (fixado) agora não está havendo processamento da instanciação de objetos, instrução create.
											-----> (fixado) insiste que no construtor está com falhas.
											-----> (fixado)  os objetos iniciais não estão atualizados!
											-----> (fixar) os valores do objeto [actual] não estão sendo repassados!


[Objeto][TabelaDeValores]:
			-----> (x) problema na visualizacao do conteudo dos objetos.
									-----> FALHA DE MAL MODIFICOU A CONFIGURAÇÃO DO DEPURADOR.
									-----> vê-se não dana tudo novamente!



[Metodo.ExcecutaAMethod()]:
			-----> (x) verificar a situação do objeto [actual].
						----> (x) atualizado certo, a copia do [objetoCaller] para o objeto [actual], se [actual] tiver presente no [EscopoDoMetodo].
						----> (x) está sem atualização em função orquidea, de passagem do objeto [actual] para o [objetoCaller], SE TIVER UM [actual] no [EscopoDoMetodo].
										----> (fixado) verificar se há necessidade de atualizar o objeto caller, com o objeto [actual], se tiver no escopo.
													------> (fixado) há vários objetos [actual], em diferentes escopos. nenhum deles está com propriedades atualizadas.
			-----> (x) objeto caller atualizado, apos retorno de uma funcao orquidea, que tem objeto [actual]. é possível fazer coisas como alterar xxImage (coordenada x de imagem),
			e repassar para o objeto caller, o que chamou a funcao.

 OBJETO ACTUAL tem propriedades! E essas propriedades podem ser objeto importado, estocado em [actual.objImportado.valor.
 e pode ser um objeto orquidea (nao importado), com um [Objeto], como valor, podendo ser estocado DIRETAMENTE no objeto caller
 aninhado, que é um Objeto também.
			-----> (fixado) objeto atual sendo instanciado mesmo se no codigo do metodo não tiver citação de objeto [actual]!
			-----> (fixado) dois objetos actual!: um nao estava sendo removido.
			-----> objetos de propriedade aninhada está com objeto.valor=null.
	----> VERIFICAÇÃO Se a propriedade aninhada está setando o valor do objeto da atribuição.


	----> (fixado) ao sair do processo de funcao orquidea, o objeto actual está com os dados atualizados da instanciação,
	em suas propriedades.
			-----> quando retorna da funcao orquidea, retorna o objeto_caller, está instanciado corretamente.
			no codigo anterior, o retorno era um objeto qualquer, não entrava no processamento.
			quando voltou o objeto criado, todo processamento de vetores de objetos voltou a funcionar.

___________________________________________________________________________________________________________________________________________________________________________________________________________________ 
[Projeto]:
			------> ( ) entre um de dois jogos: Space Invaders, ou Sokoban.
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.04:

[Metodos, Constructors]:
			------> (x) por modificações no processamento de construtores orquidea, fez-se o retorno do metodo.executeAMethod
			como sendo o objeto caller, mas isso é valido para construtores, não para funções que retorna algum valor.
								-----> modificar o construtor orquidea, para carregar o objeto, executar as instruções
								orquidea, e retornar um valor, que não é o objeto caller.
[Vector]:
			-----> (fixado) fixar a instanciação comm 1 parametro.  não está criando o objeto unidade com todas propriedades não nulas.
								------> (fixado) resultado do 1o. parâmetro não está sendo repassado.
								------> (fixado) duas propriedades aninhadas não estão sendo processado corretamente.
												------> (fixado) problemas ao atualizar o objeto actual.
[Metodo][BuildParameters()]:

			-----> (fixado) acertar o nome do objeto, de [actual], para [nomeDoObjeto].
								------> a verdade é que não é necessário o nome do objeto caller, porque haverá processamento
								por indexação, não objetos particulares, no caso de vetores de classes orquidea.
								mas é bom investigar porque o objeto caller está se perdendo durante o processamento.

___________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.04:

[Propriedades]: completar a implementacao de propriedades estáticas: ao encontrar uma propriedade estática, adicionar a escopo.escopoROOT.
quando um corpo de metodo tiver um objeto estático, carrega o campo valor da propriedade estática contida no scopo.ROOT.
apos o processamento do metodo, atualizar os valores de propriedades estáticas.

[Propriedades Estaticas]:
			------> (x) FileHeader faz processamento de propriedades estaticas.
			------> (x) ExpressaoPorClassificacao faz o processamento criando objetos estáticos.
			------> (x) completar em ExtratoresOO o registro de propriedade estatica, no escopo root.
			------> (x) completar em Method.ExecuteAMethod, a atualização de propriedades estática.
						-----> (x) implementação aditiva sem afetar outros casos de uso.
			------> testes:
						-----> (fixado) processamento correto, mas há problemas de setar a propriedade estatica com um  valor.
									------> (fixado) ao setar o objeto, pára aí. 
									------> (fixado) caso de uso nao testado com cenarios!
			------> propriedades estáticas operacional.


[ProgramasDeJogos]:
			------> inicio de planejamento e implementação do jogo Space Invaders, contém Vectors de classes, propriedades estaticas,
			e KitDevenvolvimentoGames.
									-----> implementacao com validação de cada funcionalidade com teste unitario passo a passo.
													-----> coordenadas do ship, setadas.
													-----> texto de nome do arquivo de imagens, não está sendo setado!
																-----> a imagem está sendo criada, mas há perda
																de dados ao seta ao objeto actual.
																		----> faltou no create de objeto importado,
																		a atualização do objeto [actual]!.
																		em objetos orquidea, havia atualização de objeto actual.
[atualizacao de objeto caller]:
			-----> nao está havendo atualizacao do objeto caller a partir do objeto actual!
							-----> (fixado) está, mas ao remover o objeto actual, os dados do objeto caller são perdidos!
													----> faltou atualizar o objeto actual.

[Objeto invader1] instanciado, com os parametros solicitados.							


[objeto actual]:
			-----> (fixado) está notificando um erro, na compilacao do objeto [actual]. durante a COMPILAÇÃO! 
						-----> objeto [actual] nao tem tipo! quando na compilação.


[jogo space invaders]:
			-----> falha nas coordenadas de desenho de um ship.
							-----> O objeto caller é [LoopGame], mas os dados para desenho estão em [invader1]!
													-----> o objeto [actual] está presente, mas seus dados também está desatualizado!
							-----> objeto actual contem todos dados, mas está registrado para atualização, o que perde-se os dados!
													-----> solução encontrada: importar do objeto [actual], para
													os parametros de mesmo nome das propriedades de actual.
													um pouco arriscado, porque e se tiver um [actual], E parametros
													de mesmo nome do actual?

													-----> tem procedência: o objeto actual guarda o objeto que
													faz a chamada da função importada! antes de chamar a função importada!
													sem riscos de efeitos colaterais.
																ship.funcaoImportada(): objeto [actual]=ship.

			------> primeiro desenho completo, com coordenadas e imagens atualizados.



A PASSAGEM DE PARÂMETROS, CHAMADA DE MÉTODO, COM DADOS do objeto actual: (SOMENTE SE O OBJETO CALLER FOR O OBJETO CALLER da expressao).

	Numa chamada de metodo, com parametros como actual.x, tem que carregar os dados
	do objeto [actual]! Foi a solução experimental de extração do dados, mas é algo
	arriscado.. com os dados da chamada de metodo, com parametros de [actual] é
	viável, e sem riscos de efeitos colaterais, como carregamento de parametros de
	outros objetos!
	
	implementar em evalExpression(), o carregamento de dados quando o(s) parametro(s) for
	do objeto [actual], extração dos dados actual, sai limpo e livre de efeitos colaterais!

[EvalExpression]:
		-----> (x) mais uma extensão do código: o objeto actual. 
		-----> (x) a partir de [EvalExpression], atualiza-se o objeto [actual];
		-----> com a atualizacao no EvalExpression, tratamento do objeto actual, em proprieades aninhadas,
		permitiu dados atualizados nos parametros da chamada de metodo.


___________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 05.04:

[jogo space invaders]:
		-----> deslocamento de ship, indo horizontamente, quando atinge a borda, desce um pouquinho assaz, e indo horizontalmente na outra direção.
						------> deslocamento sem condicional if/else funcionando. com if/else houve falhas.
						------> (fixado) há propriedade duplicada! [xxImage:actual], que não está com tipagem certo, e está confundindo com o real xximage.
						------> (fixado) a funcao de update ship, está sem corpo de instrucao! 				

		-----> objeto actual possui os dados atualizados em funções orquidea.	

		-----> implementar um campo em [Objeto]: objetoCaller: string, para o objeto [actual] informar o objeto caller.
[instrucoes com expressoes condicionais]:
		-----> informar se expressoes condicionais pode-se compor com objeto actual.



___________________________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 08.04:

O OBJETO [actual]:
		-----> funções importadas não utilizam o objeto [actual]. esse objeto é para controle interno de uma função orquidea, que é não importada.
		-----> então, a extração de [actual] deve ser feito quando se souber que a função é orquidea!
						-----> seria util se um [Objeto] tivesse um campo string, como [Objeto.nameCaller], que guarda
						o nome do ultimo objeto caller, que fez uma chamada de função orquidea. o campo teria que estar em [actual].
						
						
		-----> (verificar e debater) vai ser preciso uma pilha de [Objeto] para [actual], porque pode dentro de uma função orquidea, uma série
		de funções orquidea, que pode perder dados na passagem de uma funcao orquidea a outra.
						-----> a pergunta a ser feita é: e se tiver um [actual] no escopo externo, E no escopo corpo do método,
						E/OU como parametro da chamada de função?
						-----> vai ser preciso a pilha de [Objeto] [actual].
						
		-----> não foco em funções da linguagem orquidea, levou a encarar problemas com o [Objeto] [actual]: não se fazia idéia
		da importância de [actual], na coordenação de propriedades/metodos. TAÍ A JUSTIFICATIVA...
		
		-----> se num escopo externo, já tem menção de [Objeto] [actual], não se substitui por um outro [actual].
			   se o escopo do corpo do metodo, tiver menção de um [actual], E for uma função orquidea, então copia-se o
			   objeto caller, para o objeto [actual]. Se for uma função importada, não tem porque gerar um objeto [actual]:
			   o [actual] é para funcionamento interno da função, a função importado não tem instruções orquidea, é código C Sharp, ou C++!
			   


[Method]:
		-----> (fixado): muitos [actual], porque não foi removido o [actual] do escopo externo.
		-----> implementar a pilha de objetos [actual];
							-----> (x) melhorando o codigo, porque há muitos dados, em diferentes niveis de abstrações, atrapalhando
							a analise de eventuais falhas.
							-----> (fixado) e segue o calvario: de uma hora para outra, os valores passaram a sumir.
									-----> SABOTAGEM!!!!!!!!

[GameLibrary][SpaceInvaders]:
		------> (x) função de atualização de posição, operacional.
						----->(x) verificar se instruções if/else valida com expressões condiciionais, com objeto [actual].
									-----> (fixado) falha na codificação do jogo: em vez de numero [double], codificou-se com um numero [int] (sem operador dot).
									-----> (x) construção das instruções if/else feito.
													------> (x) verificar se a função está sendo executado adequadamente.
																		-----> (x) erro no cenario de teste: equeceu-se de diferenciar um int de double, e
																		também E a não colocação de ponto-e-vírgula após uma instrução, o que invalidou
																		a próxima instrução.

[LinguagemOrquidea]:
		-----> (x) implementar uma função: isNILL(objeto), que retorna [true] se [objeto] for null. A função deve estar na classe [Objeto].


[GameLibrary]:
		------> (x) codificar uma função que retorna o ID de uma imagem.

___________________________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 09.04:


[ExpressaoPorClassificacao]:
				(sem efeito)[TesteGettersSetters];
					-----> getters/setters de imagem com falha na construção. Foi decidido anteriormente não utilizar getters/setters para imagem.
									-----> getters funcionam, mas setters não!
									-----> cenario de teste removido. o processamento
									de coordenadas de posição de imagem é feito externamente,
									em função orquidea apropriado.



[GameLibrary][jogo SpaceInvaders]:
		-----> testes com dois invaders.
						
		-----> modificar a função de desenho, para compor com o ID de identificação da imagem. na atual situação,
			   está setado manualmente o valor, na chamada de desenho de textura (função importada).
						-----> falha em obter o id da imagem. está resultando valor=null, enquanto todas outras propriedade estão atualizadas.
										-----> (fixado) falha grave: uma propriedade aninhada seguida de chamada de metodo,
										não está funcionando muito bem.
														-----> a extensão de código para [actual], não passa
														para o processamento de chamadas de metodo seguida. No modo
														normal, tem previsão, apenas a extensão por falha na logica de programação.
												



		-----> desenho do segundo ship.
				----> falha no desenho e continuidade do movimento. o chato é que ontem funcionava direito.
				----> o problema é o seguinte: há chamadas de SO inicializando um serviço que tem vulnerabilidade!
										-----> SABOTAGEM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				----> todas propriedades setadas de acordo.
										-----> A SABOTAGEM ESTÁ GERANDO UMA DIREÇÃO CONTRÁRIA! SABOTAGEM DO GROSSO....

		-----> FALHA DE NATUREZA DESCONHECIDO não está atualizando as modificações no código de jogo.
		

[Metodo]:
		-----> (não funciona) implementar a pilha de Objeto [actual].
					-----> não esquecer de quando desimpilhar o [actual], atualiza o [actual] do escopo. Só há um [actual],
					tem que ficar alinhado com o escopo da função orquidea.
									-----> veja o caso: uma funcao orquidea:
												actual.fnc1();
												actual.variavel1= actual.variavel1+1;
												actual,fnc2();
												
											se não atualizar o [actual], terá problema de permuta de objetos [actual].	

__________________________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 10.04:
										
						
(x) [ExpressaoPorClassificacao][acessors][public, private]:
				-----> tratar urgentemente a diferença de propriedades PUBLIC, PRIVATE E PROTECTED.
								  -----> (x) distinção entre acessores [public] e [private], para funções, codificado. 
								  -----> (x) distinção entre acessores [public] e [private], para propriedades, codificado.
												-----> sem falhas colaterais ante a extensão do código.  (sem registro no backlog, mas seria implementado porque há previsão
												para acessors public, protected, private, seria implementado posteriormente, ou seja, hoje).



(x)[Erros anteriores] em [ExpressaoPorClassificacao]:
				-----> fixar o codigo com os testes:
								(fixado)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
												-----> objetos criados deveriam ser [public], mas em [instrucao Create()], estava como [private].
												-----> acessor de propriedade obtido de FileHeader.
							
		
(x)[Metodo][Sobrecarga De Metodos]:
		-----> (x) tratar urgentemente também da SOBRECARGA DE FUNCÕES, parece que não está havendo a escolha de funções de mesmo nome,
		mas com parâmetros diferentes: se duas funções tiverem quantidades diferentes de parâmetros, E não tiver parâmetro multi-argumento,
		deve-se passar para outra função compatível, com lista de tipos dos parâmetros correpondentes.
									-----> cenario com supresa, funcões com numero e nome, gera erros. 
									-----> testes em [ExpressaoPorClassificacao], [GameLibrary][jogo SpaceInvaders];




(x)[ExpressaoPorClassificacao][acessors][public, protected]:
				-----> codificar teste de verificação para propriedades, métodos, para acessor [protected].
				processamento semelhante ao de [private], mas com regras: se acessor for [protected] e a 
				classe for a classe da propriedade/metodo for a classe da propriedade, OU classe herdada, valida o processamento.
				caso contrario, não.
								 -----> (x) validação de metodo protected codificado.
								 -----> (x) validação de propriedade protected codificado.
											-----> (x) implantar as validações.
								 



[ExpressaoPorClassificacao]:
				----> fixar com os cenarios:
								    -----> [TesteFuncaoOperacoesAritmeticasComObjetoActual];
									-----> SE FIXAR COM ESTE TESTE, O PROBLEMA VISTO no jogo [SpaceInvaders] seja solucionado.
									este teste é sobre aritmeticas com [acutal].


(x)[nomes com numeros inclusive]:
		verificar urgentemente a compilação de nomes de objetos terminados com números: ante a constatação 
		de que números são separados de nomes, pode ser que objetos com números em nomes, estejam dando incorreções.
		mas até agora não houve problema, mas num cenário de testes em [UtilTokens] acusou a diferença. 
								

(x)[Objetos todos private]:
		setar todos objetos como [private] (x), inclusive os de instanciação otimizada (x). Então quando instanciar um objeto
		por [ExpressaoPorClassificacao], se a classe currente em [Escopo.nomeClasseCurrente] for [global], setar para [public] (x).
		cuidar também de instanciação de propriedades aninhadas, em [ExpressaoPorClassficacao], para setar como
		public, DE ACORDO com o acessor da definição da propriedade! (x).
				-----> (x) fazer testes especificos de falha ao acessar uma propriedade [private] fora da sua classe.	


[Analise]:
		O Classificador pode retornar o nome da classe, quando dois objetos tem o mesmo nome, então qual retornar?
		Verificar urgentemente, na prática foi percebido confusões com nomes de objetos iguais, em programas como jogos.
		


[Objeto actual]:
		Quanto ao objeto [actual], na função orquidea em execute metodo, tem que primeiro remover o actual do escopo externo, se tiver,
		DEPOIS atualizar o [actual] com a pilha de objetos actual. Porque o escopo externo depois da função orquidea, tem um [actual].		
____________________________________________________________________________________________________________________________________________________________________________________________________________			
Daily Scrum 11.04:


----> (x) O PROBLEMA DOS SETTERS DE CLASSES IMPORTADAS:

	Ah, entendi! O setter numa classe orquidea é geralmente assim: actual.objetoImportado.SetProp(valor).
	o que acontece é que o actual não é atualizado após a chamada, e o resultado é que o objetoImportado é atualizado
	com o actual, se tiver um [actual] no escopo de sessão do método.
			A solução: se tiver um objeto [actual] na função importada, ATUALIZAR também o objeto [actual].
			O que eu vi: o objeto importado era atualizado tanto no objeto real, quanto no campo [Objeto.valor],
			mas em seguida, que não acompanhei, é que o objeto não era atualizado: claro o [actual] estava atualizando
			passando o objeto caller, que é o objeto que é atualizado quando se chama um SETTER.
							----> dificuldade em visualizar qual metodo será atualizado: actual e ...
											-----> (fixado) 2 ou mais objetos [actual];
											-----> expressao actual.img.SetX(50.0) corretamente formado. mas na execução de SetX() os valores se perdem.
											no construtor, os valores estão atualizados, mas no termino da instrucao chamada de metodo, os valores não estão validados.
																	-----> apos a chamada: actual.img.SetX(50.0), o valor de [objetoCaller] está atualizado,
																	mas o objeto [actual] não está atualizado.
																	-----> descoberto a dupla chamada de [actual.img.SetX(50.0)]: estava processando com o objeto
																	actual, E sem o objeto actual: um continue faltou.
																	-----> faltou atualiza o escopo, com o novo valor do objeto [actual], em EvalExpression,
																	parte de processamento de propriedades aninhadas seguida de chamada de objeto.


----->	(x) EXTENDENDO A FUNCIONALIDADE DE GETTERS/SETTERS: aritmetica com os valores a seta/obter. o SETTER está operacional.
					-----> a expressao de Setter/Getter está mal formado. melhor porque não é um erro na avaliação de chamada de metodo, nem formou 
					os parametros da chamada de metodo.
					-----> testes:
								----> falha na obtencao de expressoes parametros, com [Expressao.ExtraiExpressoes], para um parametro: "actual.GetX()+5.0";
								----> (x) modificações no código quebrou a funcionalidade SETTER!
												----> (x) fixado o contador de tokens, para ajuste da malha de tokens, quando se processa uma chamada de metodos.
												no entanto o resultado do cenario nao foi validado..
												-----> (x) funcionalidade SETTER operacional novamente. 

													
					-----> um pequeno problema: o tipo do objeto caller está modificado: de MyImage foi para Imagem!
								----> compilação perfeito, para somente SETTER.
								----> falha na compilacao de SETTER combinado com GETTER.



-----> (x) ARITMÉTICA DE SETTERS/GETTERS: O operador aritmetico +, de image.GetX()+5.0, não está sendo processado!
								----> um problema de indices de malha de tokens.
								----> o operador está agora sendo processado, porém não está construindo a expressao de operadores.
												----> tipo da expressao [ExpressaoChamadaDeMetodo] está com o tipo errado.
																----> fixado, com uma extensão, que cuida de expressao de propriedades aninhadas, composta ou não com ExpressaoChamadaDeMetodo.


[ExpressaoPorClassficacao]:
			-----> (fixado) ficar com as expressoes de chamada de metodo. Todos wrapers data estão com inicialização com uma sub-expressao a mais!
									-----> contagem de ajuste de indices, um inferno de aritmetica...
			-----> (fixado)  fixar o processamento de classes,  com expressoes de atribuição em propriedades aninhadas.

[ExpressaoPorClassficacao](objeto [actual]):
			-----> (fixado) compilacao validada, mas na execução do codigo em ProgramVM não está funcionando direito, com objeto "actual".
							-----> (fixado) compilação sem falhas. mas na execução do programa, está gerando falhas.



[ExpressaoPorClassficacao][acessors][propriedade][metodo]:
				-----> codificar cenarios de testes.
									-----> fixar com cenarios: (modificação de validação de acessors):
												[TesteFuncaoOperacoesAritmeticasComObjetoActual];
												[TesteChamadaDeMetodoSeguidaDeUmaChamadaDeMetodo];
												[TesteExpressaoOperadoresEmParametros];
____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.04:


(x)[objeto actual]:
				-----> o objeto actual é do mesmo tipo do objeto caller! Quando  mudou o tipo de expressao quando é o caso
				de propriedades aninhadas seguidas de chamada de metodo, uma nova modificação seta o tipo da expressao
				para o tipo de retorno da chamada de metodo! isto faz com que o tipo do objeto actual seja diferente do objeto caller!,
				como foi percebido 1 dia antes, em que uma chamada de metodo em GameLibrary mudava o tipo (nome de classe)
				do objeto caller, E actual.
				

(x)[ExpressaoPorClassficacao][propriedades/funcoes]:
				-----> remover os calculos que levam em conta a contagem da malha de indices interna (calculos com -1 unidade),
				porque pode falhar, em propriedades aninhadas >2. E RETIRAR a correção de indice de malha, DENTRO das funções
				de SetPropriedade, SetChamadaDeMetodo. na maioria dos casos não se percebe, porque geralmente é [nomeObjeto.propriedade],
				ou [nomeObjeto.metodo(parametros)], mas quando se tem 2 propriedades aninhadas, seguida de 1 chamada de metodo,
				vai para este caso em que se tenta ajustar.
								------> (x) quando calcular uma chamada de metodo DEPOIS de uma propriedade aninhada,
								setar o tipo da expressão propriedade aninhada para o TIPO da chamada de metodo.
								Isto evitará a correção no processamento de operadores, que está com correção somente em 
								operadores exclusivamente binarios. VEFIFICAR o relato em seguida sobre [actual] mudando 
								o tipo do objeto caller.
								------> testes: em cenarios:
											(x) 1 propriedade aninhada;
											(x) 1 chamada de metodo;
											(x) 2 propriedades aninhadas;
											(x) 2 chamadas de metodo;
											(x) 2 propriedades e uma chamada de metodo; (importante para biblioteca GameLibrary, em que há casos como [actual.propriedade1.metodo1()]);


									
(x)[ExpressaoPorClassficacao]:
				(x)Não esquecer de setar o tipo da expressao, quando acrescentar uma expressao propriedade ou expressao chamada,
				na primeira expressao propriedade ou primeira expressao chamada.
						-----> (x) NÃO ESQUECER de setar o tipo de expressao de uma sequencia: obj1.propriedade1.metodo1(), para o tipo de retorno de metodo1.
						-----> (x) NÃO ESQUECER se retirar de processinOperators, a funcao que faz isto. porque está apenas um dos casos (operado exclusivamente binario).
					


[ExpressaoPorClassficacao][acessors]:
-----> CODIFICAR e testes de cenarios de propriedades/metodos [private],[protected]. os cenarios estão até agora para propriedades/metodos [private]--->[public].
				(x) [ExpressaoPorClassficacao][acessor private]:
							-----> falha na logica de programacao. tem que ser a classe onde o objeto caller está, não a classe currente.
										----> (x) em [FileHeader], há um campo para o nome da classe onde está [classNameProperty],
										porem não está implementada completamente.

										----> (x) implementar o [classNameProperty] para propriedades, em [ExtratorOO].

				[ExpressaoPorClassficacao][acessor protected]:
										----> falha no cenario de teste de validação protected para propriedades.
													-----> falha de natureza desconhecido está não propagando a falha do cenario
													para um escopo resultante.


(x) [UtilTokens.WriteErrorMessage]:
			-----> verificar se todas mensagens estão sendo registradas, pode ser que não encontre os tokens do trecho de codigo, e por isso
			não consegue encontrar a linha da falha, e nem registro do erro porque não conseguiu encontrar o trecho de codigo entre os tokens totais do programa vm.

(x)[ExpressaoPorClassficacao][fixar com cenarios]:
			-----> cenarios de chamada de metodo.
				(x) [TesteChamadaDeMetodoSeguidaDeUmaChamadaDeMetodo];
						-----> (fixado) problemas na validação de acessors!
						-----> (fixado) falha grave na determinacao da classe da funcao.
						-----> (fixado) falha na procura do proximo objeto caller em [SetChamadaDeMetodoFirstChamadaDeMetodo()].
										----> (fixado)  falha grave na compilação de métodos. a falha está nos Headers;
													----> sem previsão para o tipo de retorno de metodos!!! 
													(ainda bem que me lembrei como o processamento de [FileHeaders] funciona,
													extraindo tokken de metodo até passar para o proximo metodo).

						-----> (fixado) agora não está reconhecendo a 2a. funcao!

(x)[FileHeader]:
		-----> (fixado) verificar urgentemente O TIPO DE RETORNO de metodos, parece que está tudo como "void"!!!


____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.04:


[ExpressaoPorClassficacao]:
			----> fixar o codigo com os cenarios:

									(x)[TesteSetterEGettter];
												----> (x) isolado a falha: em expressoes de actual.prop1.metodo1()+6.0, não está registrando o operador "+".
																-----> emendado, para nao gerar falhas em outros casos de uso.
																-----> dificuldades para enxergar o nome do metodo1(), como no exemplo explanado.

												----> expressao de getter com operador, fixado; MAS é preciso verificar:
																-----> para fixar com o cenario vai ser preciso VERIFICAR:
																			-----> PROPRIEDADE ANINHADA, SEGUIDA DE CHAMADA DE METODO, em EvalExpression.
																							-----> Um dos operandos é uma chamada de metodo, o 2o. operando é um numero,
																							e está numa expressao de operador aritmetico "+", dentro de uma expressao de atribuicao.
												-----> codigo fixado.

									(x)[TesteSETTERsFuncaoImportada]

									(x)[TesteObjetoActualNoConstrutor]
												-----> (x) a parada quando não há tokens de nome de propriedade, operador ";", ou operadores aritmeticos, não havia sido feito corretamente.

									(x)[TesteFuncaoOperacoesAritmeticasComObjetoActual]
												-----> (x) o problema enfrentado é o seguinte: os acessors deveriam serem validados no primeiro objeto caller da 
												sequencia de propriedades aninhadas, ou chamadas de metodos.




----> [ExpressaoPorClassficacao][acessor protected]:
										----> VERIFICAR A REGRA PARA METODOS PROTECTED, é Escopo.nomeClasseCurrente ou metodo.nomeClasse?
													-----> seria metodo.classeAQuePertence, e Escopo.nomeClasseCurrente, e tb
													lista de classes que herdam metodo.classeAQuePertence;
													
														
										----> (x) falha no cenario de teste de validação protected para propriedades.
													-----> não está propagando a falha do cenario para um escopo resultante.
													problemas de referencia perdida ante a instanciacao do escopo no [ExtratorOO].



----> (x) implementar o [classNameProperty] para metodos, em [ExtratorOO].

----> (x) verificar se o objeto [actual] deva ser retirado do escopo externo, no caso de uma função importada, que não
precisa utilizar [actual], já que este é de funcionamento para o corpo do metodo, e o corpo da funcao importada nao é acessivel.
										----> não deve retirar, porque pode haver funções orquidea que chamam a função importada.
										
----> (x) verificar se a instrução create tem previsão para objetos importados pela instrucao [importer],
ou seja uma biblioteca extensivel... não havia previsão porque bibliotecas antes eram tratado como um conjunto de funções
estáticas. e agora, a instanciação de objetos é válida...
										----> validação de tipos para bibliotecas importadas feito, como
										uma 3a. tipo de validação, se as 2 anteriores não encontrarem o tipo do objeto registrado.


----> em [ValidaAcessorPrivate,Protected], talvez seja preciso validar todas propriedades, e não apenas a primeira propriedade.


SEM PRIORIDADE:
		[codigo unsafe]: unsafe permite o uso de ponteiros, e a tradução é de *propriedade, para &propriedade,
		permitindo o casting automático, por referência!!!

___________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.04:

		(x)-----> verificar porque não está lançando textos de erros para o escopo de compilação.
		propagação de erros na classe [ExtratorOO] no escopo de [ExtrairMetodos] não estão sendo capturado.
					(x)-----> criar uma area onde se possa guardar mensagens de erro, e falhas, numa lista de textos,
					em [UtilTokens.WriteErrorMessage()], que guarda as mensagens no escopo onde o erro ocorreu.
						----> a lista estatica está em [SystemInit], e é inicializada quando se instancia um [SystemInit].
						


		(x)-----> testes de instrução create para bibliotecas importadas, cenario de testes importando uma biblioteca,
		e então instanciando um objeto da biblioteca, através da função [create].
												-----> instrucao importer adiciona a biblioteca para o repositorio de classes,
												e então o processamento é o padrão (na compilação), verificando o repositorio.
												-----> (fixado) testes tanto na compilação quanto na execução do programa.
												o processamento é feito verificando a lista de assemblies de bibliotecas,
												obtendo o tipo do objeto a partir desta lista. construtor de uma classe
												de biblioteca feito.
												


		
		(x)-----> UM PROBLEMA DO OBJETO [actual]:
		
					-----> se tiver [actual] em duas funções orquideas aninhadas (uma chamando a outra no seu escopo),
					vai falhar, porque o [actual] de um vai se sobrepor ao outro [actual].
								-----> verificar se no escopo externo tiver um objeto [actual]:
								se tiver, e for uma funcao orquidea, EMPILHAR o actual numa pilha de objetos.
								Ao termino de uma função orquidea, atualizar o objeto caller, e se a pilha
								de objetos não tiver vazia, desempilhar o objeto [actual] no topo,
								e SETAR no escopo externo o [actual] que está nele!
								E SE a pilha estiver vazia, remover o objeto [actual] que está no esopo externo,
								QUANDO TERMINAR A FUNÇÃO ORQUIDEA!
								Não retire o objeto [actual] se for uma função importada! o objeto [actual] não trabalha
								com funções importadas!
											-----> criação do sistema de pilhas de [actual]s, se o escopo externo tiver
											um [actual].
											-----> desempilhamento de [actual], se a pilha nao estiver vazia, restaurando
											o escopo anterior.
											----->  removido a codigo que removia o [actual], se a função for importada,
											porque a funcao importada não há [actual], seu corppo é de código da Linguagem Base.

											-----> sem alterações colaterais, com o acrescimo de pilha de [actual].
											-----> testes em [ExpressaoPorClassificacao] feito, contendo objetos [actual], funcoes orquidea, e funcoes importadas.


	(*)------> codificação do [MapLevelPixels];
				-----> com o codigo unsafe de GetPixel(), é possível implementar o MapaDePixels.
				-----> codificar funcoes de conversao do vetores de items, em [MapLevelPixels], para coordenadas e id de tiles.
						pode ser vetores para: coordenadas x , y, id_cor_tile, id_name-tile.


	
	(x)----->[Castings]:
				criar em [Objeto] funcoes estaticas de conversão de elementos [object], para tipos como [int],[double],[string],[char],[float],[bool].	
						-----> classe [Castings], com metodo estáticos. Se [object] for um [Objeto], faz a conversão com o campo [Objeto.valor].
											-----> funções de conversão: intToText, doubleToText, floatToText, charToText, booleanToText;

	(x)----->[ExpressaoPorClassificacao]:
			------> fixar com os cenarios:
							(x) [TestesPropriedadesAninhadasEchamadasDeMetodo]; 
							(x) [TestePropriedadeProtected];
							(x) [TestePropriedadePrivate];


	(x)----->[ProcessamentoDeInstrucoes][PequenosProgramas]:
					-----> (x) codificar o programa demonstrativo de utilizacao de classe orquidea, com objetos [actual] fazendo operaçoes, e escrevendo da tela
						os números resultante do processamento.
					

	(x)----->verificar se classes sinalizadas como importadas (classe.isImport=true) estão funcionando,
	além das classes do kit de dev de jogos.
						(x)----> testes em [EvalExpression].
						(x)----> testes em [ExpressaoPorClassificacao].

					
[CONSTATAÇÃO]:		
		-----> não se imaginou a extensão e pesadelo do objeto [actual], até começarem os testes
		para esboços de programa de jogos! Tinha chamadas de objeto: 2 propriedades aninhadas, +1 chamada de metodo,
		e objeto [actual] costurando as propriedades de classes do jogo. e lembrando que o objeto [actual]
		só faz falta em funções orquidea, em funções importadas não, porque uma função importada
		não tem seu corpo com instruções da linguagem orquidea, apenas código na Linguagem Base.
			
____________________________________________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 17.04:


[ProcessamentoDeInstrucoes][PequenoPrograma Contador]:
		-----> realizar os testes, desse programa.
						----> não está processando uma expressão: actual.contador_int=1;
									(x)----> a melhor coisa foi ter criado uma lista de erros estática! porque
									os erros registrados nos escopos, está perdendo dados.
									   ----> falha no processamento de objeto estático, está sem tipo de expressao correto.
												(x)----> foi por isso que os programas de jogos não estavam funcionando:
														havia erros que não foram vistos, justamente pela perda de dados por referencia
														nos [Escoopo].
										
													----> inacreditável! está sem previsão de chamadas de metodos estático!


[ExpressaoPorClassificacao]:
		-----> implementar o caso de uso: chamadas de metodo estático, como [classeB.funcao1()];	
							-----> codificado. a espera de cenarios de testes.
							-----> verificar os cenarios de testes de [EvalExpression];

		-----> com a implementação, houve efeitos colaterais. fixar com cenarios:
						[TesteTextExpressionBase];



(x)[Instrucao Importer]:
		-----> (x) verificar se classes sinalizadas como importadas (classe.isImport=true) estão funcionando,
		além das classes do kit de dev de jogos.
							----->verificado em [EvalExpression]: quase todas funções utilizado são funções importadas.

(x)[Expressao][Tetes]:
		-----> (x) executar os cenarios de testes em [Expressao].
					----> fixar com os cenarios:
								(x)[TestesExpressoesMaisDe1ElementoWrapper] 1a.,2a. assercao;
												----> dificuldades em setar o tipo da expressao Vector.Get,
												e composicao exprss= chamadaDeMetodo1+chamadaDeMetodo2.
												----> uma modificação na tentativa de encurtar o processamento,
												estava gerando falha agora.

								(x) [TestCreateSetElementGetElementMatriz] 3a., 4a., 5a., acessercao;


(x)[WrapperData]: implementar em TODOS WrapperData.GetChamadaDeMetodo() o indice de começo dos tokensOriginais, afim
de compor com algo como: a[1]+b[1]==> a.GetElement(1)+b.GetElement(1);
						-----> implementado em:
									[WrapperDataVector];
									[WrapperDataMatriz];
									[WrapperDataDictionaryText];
									[WrapperDataJaggedArray];


[ExpressaoPorClassificacao][Testes]:
			-----> com a implementação, houve efeitos colaterais. fixar com cenarios:
						(x) [TesteExpressaoMatematicaEntreParenteses];
						(x) [TesteExpressaoTexto];
						(x) [TesteAtribuicaoPropriedadesAninhadasObjetoImportado];
									----> fixar o positionMouse.GetX(), na ocasiao de processamento de esboços de jogos.
						(x) [TesteTextExpressionBase];
						[TesteTextExpressionBase];
						(x) [TesteFuncaoOperacoesAritmeticasComObjetoActual];
						(x) [TesteAtribuicaoDeUmaFuncaoPorUmaVariavel];
			----> (fixado, ficar longe) problemas em [FileHeader] antigo aplicativo retornou!											

(x)[ExpressaoPorClassificacao]: 
			-----> na funcao [SetPropriedadesAninhadas()], tirar o tipo do objeto caller do aninhamento, do tipo da propriedade aninhada.
			e o tipo de expressao da propriedade aninhada é o tipo do ultimo objeto do aninhamento.

[ExpressaoPorClassificacao]:
(x) (verificado, está no conforme)[ExpressaoPorClassificacao][2 ou + propriedades aninhadas, seguida de uma chamada de metodo]:
			-----> o tipo da expressão (inicial expressao propriedades aninhadas), é o tipo de retorno da ultima
			chamada de metodo aninhado a propriedades estáticas. Não há previsão porque não houve demanda, mas se houver,
			sera possivel fazer, algo como: obj1.prop1.prop2.funcao1()+ obj2.prop3.funcao2().
							-----> não vai causar efeito colateral porque não foi testedo com expressões como o relatado acima..não
							foi testado, mas está certo.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.04:

[Anotação]:	 foi providencial criar uma lista estática de erros: programas esboços de jogos não estava funcionando
por causa de erros na compilação! 
			
[Anotação]: analise de diferencial:
			-----> linguagem de programação orientada a objetos
			-----> interpretador Prolog
			-----> Wrappers 
			-----> sistema de bibliotecas da Linguagem Base, via API Reflexão.

[ExpressaoPorClassificacao][Testes]:
			-----> um teste mais complexo, codificando testes como validação de expressões como:
						x = obj1.prop1.prop2.funcao1(1,1)+obj2.prop3.prop4.funcao();
						ou seja, chamadas de método aninhados em propriedades estáticas.
						-----> cenario de testes, falha: o objeto da atribuicao não está com valor acerto.
								-----> a ultima propriedade aninhada tinha que ser inicializada, mas nao está ocorrendo.		
										---> melhor solução: construir uma expressao de atribuicao, 
										na instrucao create, e em vez de instrucao create, retornar uma instrucao validExpress!
											O objeto instanciado em create passa a ser o objeto da atribuicao,
											e a propriedade aninhada é o objeto que recebe a atribuição.
													----> remover o processamento na instrucao create,de propriedades aninhadas. e construir e retornar uma instrucao
													validExpress, se o objeto da atribuicao for uma propriedade aninhadas.
										---> faltando como INSTANCIAR E ACESSAR o objeto da atribuicao, afim de criar a instanciacao da propriedade aninhada.

(x)[ExpressaoPorClassificacao][Testes]:
			-----> fixar com os testes:
							(x) [TesteWrapperObjectJaggedArray];
							(x) [TestePropriedadePrivate];
									-----> teste mal codificado. mal formulado porque no escopo global, os objetos são publicos,
									e o nome da classe a que pertence é [Escopo.nomeClassePertence].

(x) [ExpressaoPorClassificacao]: emm [SetPropriedadesAninhadas()], e [SetChamadaDeMetodo(), setar
o proximo objeto caller, a propriedade do objeto [.classeAQuePertence], para o nome da classe da propriedade a que pertence (propriedade.nomeClasseCurrente).
						
(x) [ExpressaoPorClassificacao][Chamadas de Metodos Estáticos/PropriedadesAninhadas Estaticas]:
			-----> (x) Chamadas de Metodo Estaticos recodificado, alterando a ordem no processamento da malha de tokens. testes!
			-----> (x) codificar urgentemente o caso de uso: EXPRESSAO PROPRIEDADES ANINHADAS ESTÁTICAS.
							-----> NÃO foi validado até agora, porque não houve cenarios de teste para propriedades estáticas,
							apenas para chamadas de metodo estática, que estava em outro trecho de codigo.

(x) [Classes Importadas][Castings]:
			------> verfiicar porque a classe [Castings], tem metodos que retornam [Castings].
			talvez seja preciso converter as funções estáticas como funções não estáticas....
							-----> (x) verificar em [FileHeader] o que está acontecendo.
							Porque há um 3o. elemento na definição do método: a palavra [static]!
							verificar também o que está acontecendo com propriedades estáticas,
							que está sem implementação, e também tem o token [static] em sua definição.


[objeto actual](TALVEZ NUMA PROXIMA MANUTENCAO, o sistema de [actual] foi validado, até agora):
			----> uma solução alternativa para o objeto [actual]: na malha de tokens principal,
			acrescentar: TABLE.isNomePropriedade(tokens[x]), e TABLE.isNomeFuncao(tokens[x]):
			se econtrar: verificar se a propriedade ou função pertence a classe que está sendo compilada:
			Escopo.nomeClasseCurrente, se validou, então em Metodo.ExcecutaAMethod(), carregar as propriedades
			do objeto caller, no escopo externo! vai evitar o objeto [actual] e a problemática de empilhar
			e atualizar objetos actual! olha que maravilha! (e ao final da função orquidea, atualizar
			o objeto caller, com as propriedades carregadas no escopo externo). muito alívio na dor de cabeça
			causado pelo objeto [actual].
					---> E não esquecer: se a propriedade já estiver no escopo externo, NÃO CARREGAR 
					a propriedade na ocasião da entrada em [Metodo.ExcecutaAMethod()], e partir para o abraço,
					porque modificações em todas funções orquidea aninhadas, vai atualizar a propriedade
					no escopo externo. E no final de Metodo.ExcecutaAMethod(), descarregar as propriedades
					no escopo externo (não antes de atualizar o objeto caller, por favor...).
			
			----> vai dar até para conseguir funções sem classe! se encontrar o nome da função no escopo 
			externo (fora de qualquer classe), acrescentar como classe: [global.funcao()], p.ex.,
			e criar uma classe ficticia, como [global], [universal], ou [externo], e carregar no 
			escopo ROOT as funções dessa classe externa! vai agir como uma função sem POO, que maravilha!...
			
			
(x)[EvalExpression]:
			-----> verificar os cenarios de testes de [EvalExpression];
			
(sem prioridadee) [INTERPRETADOR PROLOG]: verifiquei o codigo, e parece que é possível acrescentar o conjunto de classes prolog,
como classes orquidea.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.04:

(*)[funcoes importadas: GETTERS]:
		-----> os getters de função importada não estava funcionando porque o TIPO DE RETORNO DESTAS FUNÇÕES
		estava setado para o TIPO DA FUNÇÃO, E NÃO O TIPO DE RETORNO! Coisas como int x= MousePosition.GetX()
		não estava funcionando por causa desta falha! é quase certo que com a correção na importação de classes
		conforme relatado, validará os GETTERS de funções importadas!
					----> testar com GETTERs que retornam um [Objeto int] ao invés de [int variavel].
									-----> testes, o construtor do Vetor 2D está sem parametros, mas no codigo estava com parametros!
													-----> (fixado) falha em SetterX, e construtor de Vector2D.
																----> (fixado) uma linha de codigo fora de bloco.
													-----> (feito) a melhor solucao é criar uma propriedade em Objeto, int indexConstrutor,
													que guarda o indice do construtor.
																----> (fixado) o construtor é chamado, as propridades do objeto são setado,
																mas..
									-----> Getters funcionando. sem efeitos colaterais, em outros trechos de codigo.
									-----> Setters funcionando. (tem que pegar valores com o objeto [Vector2D.valor]);



(x)[EvalExpression]:
		-----> testes para funcoes importadas.
			
[ExpressaoPorClassificacao][Testes]:
		-----> fixar com os testes:
				(x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
				(x)[TestesPropriedadesAninhadasEchamadasDeMetodo];
				(x)[TesteSetterEGettter];
							-----> funções GETTER,SETTER funcionais!
				(x)[TesteFuncaoOperacoesAritmeticasComObjetoActual];


				[TesteSETTERsFuncaoImportada];
							-----> falha na copia de propriedades de objetos: está retirando propriedades de objeto caller!
										-----> a falha está no construtor de objetos orquidea!


(x)[Objeto] ----> falhas graves em  [Objeto.UpdateObjetoCallerFromActual()], e [Objeto.UpdateActualFromObjetoCaller()]:
				  o campo valor estava alterando também os objetos a copiar! isto causava um erro de tipo e valor  no objeto a copiar!





[ExpressaoPorClassificacao][Testes Propriedades Aninhadas]:
		-----> um teste mais complexo, codificando testes como validação de expressões como:
						x = obj1.prop1.prop2.funcao1(1,1)+obj2.prop3.prop4.funcao();
						---> melhor solução: construir uma expressao de atribuicao, 
						na instrucao create, e em vez de instrucao create, retornar uma instrucao validExpress!
						O objeto instanciado em create passa a ser o objeto da atribuicao,
						e a propriedade aninhada é o objeto que recebe a atribuição.
								----> remover o processamento na instrucao create,de propriedades aninhadas. e construir e retornar uma instrucao
								validExpress, se o objeto da atribuicao for uma propriedade aninhadas.
								----> faltando a criacao de uma instrução Create, para o objeto da atribuição,
								no conjunto de instruções formado pela [Instrucao ExpressaoValida(ExpressaoAtribuição)+ Instrucao Create(objeto atribuicao)].
											-----> aí é garantia que funciona, pelo menos neste teste.
_____________________________________________________________________________________________________________________________________________________________________________________________________________

	----> importar as classes já prontas, de [TimeCopilot]: MyImage, MyRenderDX, configurado para SharpDX.
		  possibilidades de desenhar imagens dentro de imagens. AS CLASSES JÁ ESTÃO PRONTAS!	

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.04:
	
	
(x)----> com a sequencia de expressões chamadas de metodo saneado, vai ser possível fazer encadeamento de chamadas
de metodo, como m1[1,1].tan()... sensacional, não é preciso acrescentar nada (nem mesmo o calculo do token ponto-e-vírgula,
nos tokens de retorno), pelo contrário, vai poder cortar o trecho de código, em [WrapperDataVector], GETChamadaDeMetodo(),
a parte que trata de extensões detectado com operador dot de POO.
			-----> só verificar se as chamadas de metodo aninhadas estão operacional, porque os testes
			cobriram: 1 chamada de metodo, 1 propriedade aninhadas, 2 ou + propriedades aninhadas,
			e 1 ou + propriedades aninhadas seguida de 1 chamada de metodo,
			mas é certo que a validação de 2 ou + chamadas de metodos é possível (conforme relatado, o saneamento 
			feito recentemente). Vai ser preciso criar um objeto caller depois da 1a. chamada de método.
							-----> problemas de referência, no caso de wrappers, está inviabilizando esta idéia.
							Se o objeto caller fosse atualizado. E SE os objetos [actual] guardassem os dados dentro da chamada de metodo?
							objeto caller da 2a. chamada de metodo?  PODERIA TRANSFERIR OS DADOS do [actual]
							para o [objeto caller] da 2a. chamada de metodo?
											-----> objetos [actual] são de funções orquidea! em funcoes importadas,
											não há... mas vetores de classe orquidea podem utilizar,
											e assim um [vector] de [entity] poderiam utilizar o objeto [actual] (deve,
											precisamente)
															------> com o [actual], o 1o. objeto caller poderia ser
															atualizado!!!
															------> é isso: o objeto caller sobrevive sem
															estar no vector! se for uma chamada com indice constante
															se for wrapper; funciona! É só atualizar o objeto caller
															apos a chamada da função orquidea.
															-----> não vai ter jeito, porque os indices de elementos
															raramente não varia. O jeito é um adendo na
															composição de chamadas de metodos aninhadas:
															se a primeira chamada for um GetElement() de um wrapper object,
															tem que acrescentar uma 3a. chamada, SetElement()
															para atualizar o elemento indexado wrapper.
															Mas é melhor que três expressões, com 1 objeto como ponte.
															Fica 3 chamadas de métodos! Com o saneamento relatado,
															as chamadas de metodos aninhadas são possíveis.
															Vale um teste para ver.
															A 3a. chamada sera SetElement(actual, indice1aChamada),
															e não há concatenação lógica: se não bater os tipos,
															outro adendo terá que realizar a chamada mesmo assim.
			----> A MELHOR SOLUÇÃO: em funcoes com retorno [void], retorna o objeto caller!
			na concatenação de funções não existe, porque há funções de retorno [void],
			e na POO não há objeto [void]. Então é um artifício concatenar funções; Em Javascript
			há concatenação de funções, mas não é POO, é programação funcional. e neste caso também
			é um artifício. 
						-----> retornando [objetoCaller] em vez de [void]:
								
						m1[1].hash(), 
						fica 
						m1.GetElement(1).hash().SetElement(1);
								
						se hash() retorna m1, então na proxima chamada fica m1.SetElement(1), ou seja o objeto caller
						retorna e atualiza a situação! melhor seria se retornasse m1[1], não m1.
								
								
(x)[ExpressaoPorClassificacao][WrapperData]:
				-----> com poucos ajustes, o wrapper [Matriz] (extender os tokens para passar alem dos tokens processado),
				ganhou uma funcionalidade que somente tinha em [WrapperDataVector]!
								-----> faltando o ajuste de acrescentar um SetElement(), se tratar da 1a. chamada de metodo 
								for uma chamada GetElement de um wrapper object! Esta terceira funcao atualiza o elemento acessado por [GetElement()],
								apos a funcao extensao.
											-----> (x) extensao implementada em: Vector, Matriz, DictionaryText, JaggedArray
											-----> em jagged array o tipo do elemento ("Object"), está impossibilitando
											a validação da funcao extensao.
																----> mas mudando o tipo de elemento, para qualquer tipo 
																de elemento, como [string],[double], qualquer funcoes
																destas classes de tipo elemento validará a implementacao.
																----> [JaggedArray] é multi-objetos, pode ter qualquer tipo de elemento,
																diferente de [Matriz] (que é semelhante, mas pode inserir linhas e colunas),
																que somente aceita como tipo elemento a classe [double].

(x)[WrappesrData]:
				-----> fixar o tokens de retorno, para retornar a extensão também.



[ExpressaoPorClassificacao][ExtensaoWrappers]:
				-----> (removido) AJUSTAR URGENTEMENTE A 3a. chamada de metodo, para parametros: indices, e GetElement(indices).
									-----> com a tecnica de aninhar chamadas de metodo, é possivel implementar qualquer
									tipo de função atualizadora, a 3a. função [SetElement].
				-----> pode ser que se a funcao extensiva de wrappers, seja uma função orquidea,
				e se for, com objetos [actual], seja capaz de atualizar o elemento do wrapper de GetElement(),
				se for assim, não é preciso a 3a. função, [SetElement], até porque não vai atualizar o elemento do wrapper.
				se não for wrapper, a chamada de metodos aninhadas, vai conseguir retornar valor com as funções concatenadas!
									-----> removido a extensão que gera a 3a. função aninhada, na esperança de atualizar
									com objeto caller.


(x)[EvalExpression]:
				-----> verificar ou implementar avaliação de chamadas de metodo aninhadas, quando encontrar uma chamada de metodo.
				nesta expressao, se tiver aninhado em [Expressao.Elementos], mais chamadas de metodo, fazer o processamento
				destas chamadas também.
							-----> extensão para função [void] retornar o objeto caller, feito.

[ExpressaoPorClassificacao][Testes]:
				----> fixar o codigo com base nos cenários:
							(x) [TestesPropriedadesAninhadasEchamadasDeMetodo];
							(x) [TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
							(x) [TesteExpressaoMatematicaEntreParenteses];
							(x) [TesteExpressaoTexto];
							---> [TesteSETTERsFuncaoImportada];
											-----> SETTER de classe importada não funcional!
							(x) [TesteFuncaoImportada];

				----> ao que parece, os cenarios de testes atingiu a capacidade maxima de memoria, que paralisou o processamento de mais cenarios.

[Metodo.ExecuteAConstructorOrquidea]:
				---> fixar com cenario 	[TesteSETTERsFuncaoImportada];
								-----> verificar 2 expressões aninhadas seguidas de 1 chamada de metodo.
												-----> GETTER/SETTER operacionais! o problema é no construtor da classe orquidea.
															-----> outro cenario de teste validou o GETTER/SETTER de uma classe importada,
															nao classe orquidea.
												-----> construtor orquidea QUASE operacional! Retorna um objeto do cenario, com as propriedades
												devidamente construidas! (1 [Imagem], setando a propriedade X da [Imagem]);

[Metodo.ExecuteAConstructorOrquidea]:
				-----> fixar com cenario 	[TesteSETTERsFuncaoImportada];
				-----> construtor: retorno das propriedades vem por escopo! O retorno da função do construtor
				não tem nada a ver! constroi com as propriedades contidas no escopo...
				-----> o problema é como segue: as propriedades do objeto construido não são passados, pois
				estariam no objeto [actual]!
								------> codificado no contrutorOrquidea, um objeto [actual], que é passada
								para o escopo. depois do retorno da funcao que implementa o construtor, os dados
								da inicialização estão no actual!

											
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.04:

Atividades do dia:
				(x)-----> fixar a instrucao create, que está setando o actual para o objeto criado, deveria
				ser uma das propriedades do actual, mesmo nome!

				(x)-----> refatorar a funcao [ExecuteAFuncaoImportada()];
								(x)----> os objetos que chamam essa funcao não pode ter objeto.valor=null;
												-----> objeto caller valor=null, por isso a falha.
														-----> falha grave, um objeto actual somente tem propriedades.
														-----> na parte de [actual.img.SetX()], não está obtendo o [img], deveria ser do actual.
														-----> foi brutal, mas corrgiu-se: a passagem de objeto instanciado, como propriedade do objeto actual,
														várias falhas de não atualizar os objetos com dado do escopo, e refatoração da função [ExecuteAFuncaoImportada].
								(x)----> [Metodo.ExecuteAConstructorOrquidea]:
											----> cenarios de teste para validar o escopo orquidea.
											-----> o construtor está instanciando objetos, mas os objetos importados, e valor atualizado,
											não está repassando por entre os escopos!


				(x)----->[InstrucaoCreate]:	
						----> em create object, para objetos orquidea (classe Objeto), rever a parte que seta o campo valor para
						[objetoCriado.valor=objetoCriado], e [actual.valor=actual], porque se perde o valor object instanciado...
									----> em [Objeto].valor, se for o  Objeto de uma classe orquidea, pode ser qualquer valor, menos null:
									este Objeto de classe tem apenas uma lista de propriedades, que podem ou não ser null.
									O que conta é a lista de propriedades,não o valor do Objeto que representa a classe orquidea como um todo.

	

					
				(x)-----> [EvalExpression][Testes]:
										-----> ante a modificação extensa na execução de chamada de metodos, testes com avaliação de expressões em [EvalExpression].
														----> fixar o codigo com os cenarios:
																	[TesteParametrosMultiArgumentos];
																				----> instrução [return 5], no Parser, processado como [return5];
																								-----> ultima atualizacao no Parser, de nomeSemNumero+nomeNumero,
																								não verificava se o nomeSemNumero era um termo-chave (como return),
																								ou nome de operador.
														-----> levantando a questão, o Parser pode falhar se nome de operador, fora da lista, mas
														composto de 2 ou + nomes de operadores, pode falhar. Mas nomes de operadores listados,
														como os de operações aritméticas, ou mesmo nome de operadores como tokens [Dot], [Maior], [Menor],
														valida, porque não é operador, mas um nome id.



				(x)-----> [ExpressaoPorClassificacao][classes: double, string]:
										-----> objetos estáticos, construidos com valor de classes de funções string, double.
														------> apesar de verificar em [ExpressaoPorClassificacao] a construção
														de objetos estáticos para classe [double] e [string], na execução da função
														importada, os objetos estáticos estão com valor null!
																	-----> falha na inspeção do codigo: o trecho de construção de objetos estáticos
																	estava em outro trecho do codigo, e também o construtor utilizado estava com falhas.


			
[ExpressaoPorClassficacao][chamadas de metodo aninhadas]:
				----> atualizar o objeto de retorno como o objeto retornado na 1a. expressao chamada de metodo.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.04:

Aividades:
		(x)-----> [Extensoes de metodos wrapper]:
						Melhor solução:
								----> a 3a. chamada de metodo é: UpdateFromActual(indice, objetoWrapper, objetoAtual),
									  que atualiza o objeto caller
									  com o objeto [actual]! pensar um pouco mais sobre isso. se não tiver [actual],
									  como se fosse uma chamada de metodo sem atualização, tudo certo, porque verifica-se se há [actual].
									  e veja, cobre as extensões de [Vector]+[classe orquidea], porque a atualização 
									  vem via [actual].
													------> função criada, está em [WrapperData], podendo ser acionada
													com a instanciação de qualquer tipo de objeto wrapper.
													------> função de inserção codificado, precisa inserir a entrada desta funcao no retorno da 1a. expressao chamada de metodo.
										-----> se por acaso falhar a atualizacao, modificar a extensão com 1 chamada de metodo que abranja mais o processamento.



		(x)---->[WrapperDataVector]:
				-----> fixado os tokens processados de retorno, da funcao [GetChamadaDeMetodo()];

									
		(x)----->[EvalExpression]:
				-----> modificações no codigo causou falhas colaterais.
				fixar com os cenarios:
						(x)[TestesWrapperObjectsExpressaoAtribuicao];
						(x)[TestsVectorAtribution];




		(x)---->[WraperDataVector][Testes]:
				------> teste para expressao de metedo aninhadas.
						-----> (fixado) incompatibilidade de parametros: parametro numero é Int32, teria que ser Objeto.
									------> o indice tinha que ser um objeto numero, nao um valor de numero. mas foi modificado a 3a. chamada de metodo,
									para compor com um indice [Objeto].

									------> valor para elemento do vector está null! nao deveria.
									-----> mesmo com explicitamente o objeto do elemento está construido, insiste em resultar null!
											----> MAIS UMA VEZ, O PROBLEMA DE ATUALIZAÇÃO COM DADOS DO ESCOPO! Quando se codificou,
											não se esperava que um [Objeto] mudasse o seu valor!
															-----> objeto elemento instanciado corretamente, inclusive
															com as propriedades setadas de acordo com o construtor,
															mas na parte principal, onde se atualizava o elemento atraves de um metodo,
															não funcionou.
															-----> 3a. chamada, que é o coração da extensão, não está atualizando
															com SetElement!
												
											----> (fixado) OBJETO [ACTUAL] não está sendo instanciado como parametro!

											----> instanciacao de indices parametros está correto. só falta o 
											objeto [actual], que não está com valor!

									 -----> não sei se foi boa medida utilizar como parametros [ExpressaoObjeto], perde-se
									 muito poder de fogo ao converter a expressão indice para uma expressao objeto. melhor
									 seria se os parametros da 3a. expressao chamada de metodo, fosse não [Objeto],
									 mas [Expressao], que seria avaliada dentro da função da 3a. chamada...

						-----> o problema é como se segue: o objeto [actual] está sem valor!
						
						-----> boas noticias: a 3a. chamada de metodo está setando um valor para o elemento,
						e é no mesmo vetor, SÓ QUE o valor do objeto não está atualizado!!!
									------> o [actual] deveria ser atualizado em [EvalExpression.ExpressaoChamadaDeMetodo].



		(x)---->[A 3a.chamada de metodo]
				-----> não sei se foi boa medida utilizar como parametros [ExpressaoObjeto], perde-se
						muito poder de fogo ao converter a expressão indice para uma expressao objeto. melhor
						seria se os parametros da 3a. expressao chamada de metodo, fosse não [Objeto],
						mas [Expressao], que seria avaliada dentro da função da 3a. chamada...
		------> o [actual] deveria ser atualizado em [EvalExpression.ExpressaoChamadaDeMetodo].
						----> tem um objeto [actual], o 2o., que está com valor atualizado!
									-----> (fixado) proliferação de objetos [actual]! tem 2 objetos [actual], somente o segundo é válido!
												----> tinha que atualizar o [actual], não adicionar ao escopo. o actual
												verdadeiro é o [actual] que surje na instrução [InstrucaoCreateObject].
									-----> em algum lugar do código, perde-se o valor do objeto [actual].
												----> está apos [SetElement].
															-----> o salva-guarda de conflitos de [actual] estava 
															atrapalhando o processamento. 
												----> validou, manualmente. mas não tem como verificar o resultado,
												justamente porque a classe orquidea é uma classe de linguagem orquidea,
												não tem como verificar via codigo C Sharp.
								
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.04:

(X)---->  [ExpressaoPorClassificacao][Teste 3a. chamada de metodo]:
				  -----> encontrar como validar o teste, manualmente validou, mas está sem validar automatizado, que é necessário
				  para verificar se o codigo quebrou ou não.
				 -----> solução: extrair o [Objeto] do [vector], e deste objeto, verificar a propriedade
				que se quer validar.


[o problema do [actual]:
	  ----> se mudar de objeto caller, vai falhar o actual que está como objeto unico em todo codigo.
	  a solução? guardar no proprio objeto caller, seu [actual]! então, depois de atualizar o [actual],
	  guardar no objeto caller. se entrar numa função orquidea, retirar o [actual] do objeto caller.
	  E TAMBÉM: quando se instancia um objeto na instrução CreateAnObject, guardar o [actual] do objeto instanciado,
	  no próprio objeto instanciado. aí, quando se acessar um objeto caller, seu [actual] estará o valor
	  do objeto instanciado....
	  
	  -----> o problema de [actual] aninhados, creio que vai ser solucionado com esta medida de codificação.
	  
			------> e se modificar uma propriedade de um objeto orquidea, fora de seus metodos? como obj1.prop1=x;
			não tem jeito: tem que haver SETTERS/GETTERS para cada propriedade num objeto orquidea.
			Então, há um meio termo entre POO/programação funcional: um Objeto tem estados internos,
			mas regidos por um conjunto de funções!	
						-----> posteriormente, chamadas de propriedades fora do objeto, como obj1.prop1=1,
						poderia ser substituidos por um template: obj1.SetProp1(1), numa combinação feita
						em tempo de compilação, e sem o dev perceber a chamada SETTER, e x= ob1.prop1,
						poderia ser substituidas por x=obj1.GetProp1(). e claro, a geração de funções SETTERs/GETTERs,
						quando se constroi uma classe orquidea!
								-----> MELHOR SOLUÇÃO para SETTERS/GETTERS: a cada atribuição e acesso a propriedades aninhadas,
								atualizar também o [actual] do objeto caller. Por que qual é o problema: atualizar o [actual]!
								Este é o problema. Se atualizar o [actual], o codigo funcionará, sem funções SETTERS/GETTERS 
								explicitamente.
										------> vai ter que diferenciar [Objeto de classe Orquidea], de 
										objetos importados: int, float, double, string, char, boolean,
										e objetos importados de bibliotecas.
						-----> com estas medidas, e o fato de cada objeto caller tem seu proprio actual,
						resolve os problemas de [actual], um objeto que foi sendo percebido apenas recentemente...

						
(x)----> implementação:
						-----> codificado como propriedade de um objeto, o objeto [actual], em [Objeto], CLone(),Copy().
    ---> testes: em algum lugar do codigo, o ojeto objcaller.actual perde seus dados.
						-----> mais uma vez, o objeto caller no escopo não estava atualizado, era preciso atualizar o escopo.

	---> por enquanto, propriedades de uma classe orquidea seria melhor com getters/setters. a parte do objeto actual está
	feito, com exceção da atualizacao quando se modifica propriedades.



(x)----> [ExpressaoPorClassificacao]:
	 ------> modificar a função [UpdateFromActual], de indices [Objeto], para [Expressao], que seria avaliado
	 dentro da funcao, com possibilidade de: v1[i+1*y].Hash(), na atual situação, somente v1[i].Hash(), e v1[1].Hash() é possivel.
	 não é dificil neste codigo, a avaliação seria feito com o escopo estático [Escopo.escopoCurrente].

	------> melhor solução:
			(x)------> FAZER os parametros como int, e deixar a avaliação das expressoes-indices quando
			se carrega os parametros.
			(x)------> agora é possivel faz algo como: v1[x*5+y].Hash(), porque "x+5*y" é uma expressão de indices.


[WrapperDataDictionaryText]:
			fixar [UpdateFromActualObject] o nome da chave está incorreto.

[ExpressaoPorClassificacao]:
			fixar o codigo com os testes:
					[TesteSetterClasseImportada];
								----> O calculo de parametros está retornando um valor single, deveria ser double.
								mas single é float, mas na tipagem de tipos de classe C Sharp..
												----> o codigo teima em nao aceitar o parametro [Double], mesmo quando é double,
												a não ser que o codigo mudou: um [object] como [Double]?

					(x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
					(x)[TesteFuncaoOperacoesAritmeticasComObjetoActual];
								----> o problema é que no construtor, o objeto [actual] não é inteiramente instanciado, faltando
								seu valor, que é conseguido após o construtor instanciar o objeto caller.
								----> falha na construção da expressão de atribuição: o objeto que recebe a atribuição está como null!
												-----> arquitetura maldoso: previu apenas um tipo de objeto
												que recebe a atribuição: quando o objeto for [Objeto], mas faltou
												quando o objeto for uma [PropriedadeAninhada]: quando nos cenarios,
												mais uma vez, deixou-se de cenarios validarem quando o objeto da atribuição for
												uma propriedade aninhada. E FALTOU TAMBÉM: atualizar o escopo, tanto o objeto 
												[actual] quanto o objeto da propriedade aninhada, em questão..
												é quase certo que propriedades aninhadas esteja sob testes em outro conjunto de testes:
												o da classe [Expressao].

					[TesteAtribuicaoPropriedadesAninhadasObjetoImportado];
					(x)[TesteAtribuicaoDeUmaFuncaoPorUmaVariavel];
								----> objetos estáticos que não [double] ou [string], nao tinham valor!

[ExpressaoPorClassficacao][chamadas de metodo aninhadas]:
				----> atualizar o objeto de retorno como o objeto retornado na 1a. expressao chamada de metodo.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.04:


(x)[ExpressaoPorClassificacao]:
			fixar o codigo com os testes:
					(x)[TesteSetterClasseImportada];
								----> O calculo de parametros está retornando um valor single, deveria ser double.
								mas single é float, mas na tipagem de tipos de classe C Sharp..
												----> o codigo teima em nao aceitar o parametro [Double], mesmo quando é double,
												a não ser que o codigo mudou: um [object] como [Double]? (os parametros em reflexao API 
												são sempre objects, mas com tipo compativel)
												----> verificar se o objeto que chama a função de reflexão, é de tipo compativel,
												porque o que se verificou foram os parametros da função...
				
					(x) [TesteAtribuicaoPropriedadesAninhadasObjetoImportado];
				
		    nova bateria de Testes: fixar com cenarios:
					(x) [TesteClasseElementoVector];
												----> incompatibilidade de tipos de object: esperava [Objeto] mas é [Vector].
															-----> mudança da funcao: espera agora [Vector];
															

					----->o actual.valor= dado anterior, actual= dado atualizado, apos sair da funcao orquidea metodoB.
												----> tentativa de atualizar o [actual] falhou.
												----> FALTOU UM DETALHE: atualizar o escopo externo, com os dados do escopo de SESSAO!.
															-----> nome do objeto instanciado impede a atualizacao!
												


(x)[ExpressaoPorClassficacao]:
		------> fixar o codigo com os cenarios:
				(x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
				(x)[TesteFuncaoOperacoesAritmeticasComObjetoActual];
		-----> UM PROTESTO: MUDA-SE A ORDEM DOS CENARIOS, E FALHAS ACONTECEM! algo de muito podre está fora de casa.

	

(X)[Projeto]: (fixado) TODOS getters/setters importado estão quebrados. a função [ExecuteAFunctionImportada] quebrou!
				-----> o objeto caller não estava sendo atualizados com dados do escopo.



[EvalExpression]:
				----> estudo de como atualizar o objeto [actual], tanto na Expressao de ATRIBUIÇÃO quanto na Expressao CHAMADA DE METODO,
				e também na Expressao PROPRIEDADE_ANINHADA. a atualização do [actual] nestas expressões é vital para correto
				de como proceder quando se está no interior de um objeto [Objeto] orquidea. Já foi atualizado em 
				propriedades aninhadas, e checar se também em expressao de atribuição.
							-----> sem esta atualização, não é possível sem getters/setters, o gerencimento de propriedades
							de um objeto orquidea. em objetos importados, não há objeto [actual] (com exceção se o objeto 
							actual entrar como parametro de função, como a 3a. expressao chamada de metodo do processamento
							de wrappers com função de extensão).

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.04:


[Instrucao for]:
				------> fixar com o cenario de teste em [WrapperDataVector], 1o. teste
				
[objeto actual]:

implementação aditiva de [actual]:
				(x)------> instanciar um [actual] no inicio da função orquidea, e atualizar e remover do escopo no final da funcao orquidea.
				se no inicio, no escopo já tiver um [actual], empilhar, e carregar o actual currente criado no inicio da funcao,
				no final, se tiver [actual] na pilha, desempilhar e update no escopo.

				(x)----->(a fazer) uma propriedade interessante no [actual] seria o nome do objeto caller do [actual],
				então quando se modifica o actual, o caller pode também ser atualizado.

(x)[ExpressaoPorClassificacao]:
				------> (x) teste com funcao orquidea no construtor, validou com a atualizacao do objeto actual.
				------> (fixado) teste com vetores com classes orquidea, só não validou porque o objeto caller mudou de nome.
										------> chamada de funcao orquidea validado, mas com 3a chamada de metodo,
										o objeto caller não é atualizado.
						-----> (x) criação de um campo: nomeObjetoCaller, para actual atualizar automaticamente o objeto caller.
		-----> o problema é como segue: na 3a. chamada de metodo, há como parametro o objeto [actual],
		mas o actual somente vive na execucao de funcao orquidea. Na construção de parametros, falha na atualização
		do parametro do objeto actual. tentativa de criar um campo para sinalizar que o objeto é objeto caller, ficou confuso.
				-----> (x) removido o campo [Objeto.isObjectCaller], não fez efeito.

		
				----> QUASE: o actual está atualizado, o objeto caller está atualizado...
							-----> SABOTAGEM! um monte de armadilhas: nos processos do SO, em browsers instalados, em entradas no firewall,
							o cretino quer inferno, e o Universo vai voltar para ele o inferno!
				-----> rever o codigo, para somente instanciar o [actual] quando estiver em uma funcao orquidea.
							-----> remoção de actual quando sai de uma funcao orquidea feita, mas foi preciso
							criar uma pilha de actual, para propagar [actual] para uma função importada, caso tenha
							como parametro um objeto actual.
							-----> um pouco melhor: o objeto actual praticamente tem seu ciclo de vida dentro da execucao
							de funcao orquidea, mas para propagar alem, para funcoes importadas que tem como parametro um objeto actual,
							foi codificado uma pilha de objetos actuais. funciona para funcoes aninhado, como a 3a. chamada de metodo de extensão de 
							funções em wrapper objects.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.04:

(x)[actual]:
		-----> rever o codigo dos objetos actual.
				 -----> melhoria: o objeto actual tem ciclo de vida até a proxima funcao importada, alem, é removido do programa.
				 -----> ciclo de vida de objeto actual: durante a execução de funcao importada, e alem ate depois de
				 uma execucao de funcao importada, se esta tiver o objeto actual como parametro.
		-----> bom seria se não fosse o objeto actual PARAMETRO DE UMA FUNCAO IMPORTADA: daria para limitar o ciclo de vida
		para durante a execucao de funcao orquidea. para isso, tem que obter o objeto feito na 1a. chamada de metodo,
		funcao de extensao de funcoes para wrappers.

(x)Planejamento:
		-----> (melhor o REMENDO) vendo as vulnerabilidades do objeto [actual] como parametro, uma nova funcao aninhado:
				v[1].hash() --- > Objeto v11= v1.GetElement(1).hash().SetElement(1, v11).
		utilizando a tecnica de template que faz possivel os wrappers, pode inserir esta 3 chamadas de metodo,
		para implementar a ideia de vetores chamarem funcoes orquidea, e atualizar o elemento do vetor que chamou a funcao Hash().
						-----> codificacao feita, faltando inserir o "gancho" de desvio para processamento,
						após encontrar as condições para as 3 expressoes seja feita.

(x)[ExpressaoPorClassificacao][REMENDO]:
		-----> qual era o problema? utilizar o objeto [actual], que tem outra função: acesso as propriedade de um objeto,
		dentro do escopo do objeto. se inserirmos um objeto elemento instanciado, a funcao do actual passa para este objeto elemento!
						-----> quase! o objeto elemento nao está sendo atualizado.
										-----> criado um campo indicando que um objeto deve ser tratado como objeto caller.
										mas há um trecho do codigo que está resetando este campo.
						-----> alguma funcao clone nao está copiando o campo isCaller.
										-----> a ideia é boa: transferir as responsabilidades do actual para um objeto instanciado.
						------> quase! está retornando um valor, porem não é o valor esperado...
										-----> por razao misterio, uma das funcoes em [Objeto] estava setando
										o Objeto.isCaller=false, atualizado todas funcoes clone, incluindo de wrappers.
										-----> e também, uma funcionalidade postergada, mas agora implementada,
										foi a 3a. chamada de metodo, para todos Wrappers, NAO APENAS [Vector].
						------> apenas uma mudanca de objeto elemento a atualizar, de [actual] para [objeto elemento instanciado],
						mais um campo [Objeto.isCaller] para sinalizar que o objeto deveria ser tratado como objeto caller,
						fez o remendo dar certo, e mantem a funcionalidade de [actual] para 1 responsabilidade apenas,
						o acesso às propriedades de um [Objeto]. ficou melhor..

(x)[ClasseString]:
		-----> implementado quase todas funções de uma lista de funções strings.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.05:

(x)[ExpressaoPorClassificacao][cenarios de testes]:
		-----> executar todos cenarios de testes.
(x)[actual]:
		-----> a solução encontrada é fraco! pode falhar, mas uma coisa é: chamadas de metodo aninhado não tem
		objeto caller! Então, se setar o objeto resultante de uma chamada de metodo anterior, e setar O NOME do
		objeto caller, não precisará do campo [Objeto.isCaller], que pode falhar!
					------> procedimento:
								(x)-----> cria um campo em [expressaoChamadaDeMetodo], [nomeObjetoResultante];
								(x)-----> setar como objeto caller para 2a.3a. chamada aninhado, o objeto da extensão;
								(x)-----> quando se executa uma chamada, se tiver um resultado!=null,
								criar um objeto, que será o próximo objeto caller, e setar seu nome como [nomeObjetoResultante];
								-----> se a 2a. e 3a. chamada aninhado tiver este objeto caller, será atualizado,
								e o problema de v1[1].Hash() fica resolvido;
								
								(x)------> remover o campo [Objeto.isCaller] porque pode falhar.
											------> modificacoes extensas, mas apenas no caso de 3 chamadas de metodo aninhado,
											evitando efeitos colaterais, apenas este caso é utilizado o objeto caller como 
											o caller da 2a, e 3a. chamada de metodo aninhada.


					------> nao havia previsao para elemento resultante funcionar como objeto caller:
					era calculado e guardado na pilha, porque faz para de expressoes como: b=a.funcao1();
					as chamadas de metodo aninhadas não estava previsto;


(x)[WrapperDataVector][cenarios de testes]:

		-----> executar cenarios de testes envolvendo vetor com classes orquidea.

[GameLibrary]:

[SpaceInvaders]:
		----->(x) verificar se o esboço de jogo  está funcionando, porque não é o jogo ainda, apenas testes...		
					  ------> varias falhas, regressando para um esboço menos complexo.
									-----> (fixado) falha na expressão de controle, entrou num branching que retorna null.
									-----> a imagem nao aparece!
												----> falha na compilar instrucao create: a extração de parâametros para o construtor, nao ]
												estava correto.
												----> apagou-se a instrução que cria o objeto da classe orquidea.
												----> nao é grave: um objeto orquidea, nao está sendo instanciado, dai o nao aparecimento de imagem.
															-----> uma funcao para apenas 1 trecho de codigo, não vale: funcoes
															são para economizar codigo escrito, e além não serve como desculpas
															para "aumentar o nivel de abstração"! e a funcao estava incorreta ainda por cima!
		-----> if/else, actual, instanciacao de classe orquidea, instanciacao de imagens dentro do escopo da classe orquidea,
		update, draw, GETTERS de classe importada, tudo operacional!


(x)[esboço contador com textos]:		
		-----> programa com texto, randomizacao, e casting operacionais.
		-----> falha em desenho de imagens.
					----> (fixado) em esboço de colisões, apareceu a imagem, porém apenas 1 imagem, são duas.
									-----> duas imagens, o id funcionando (via GETTER!);
(x)[Method.ExecuteAMethod()]:
		-----> funcao ExecuteAMethod tinha codigo redudante, fazendo busca de funcao compativel: ja foi feito em compilação.

(x)[GameLibrary][LoopGame]:
		-----> mudar as funcoes de [DrawTexture], para [Draw] simplesmente: tá certo que RayLib é a biblioteca importada,
		mas manter os mesmos nomes não pega bem.
		-----> esboços de jogos modificado a funcao [DrawTexture], para [Draw].

[GameLibrary][SpaceInvaders]:
		-----> continuar o codigo do jogo.
				-----> falha no GETTER id (falha no construtor orquidea).
							----> as imagens dentro do codigo Linguagem Base, estão com id correto, porem no codigo do jogo está sinalizado como 0! 
										-----> uma propriedade estática fixaria...
										-----> mesmo com id setado manualmente, só aparece uma imagem!
				------> falha grave na logica dos objetos [actual]: está considerando como se fosse um [actual] somente!
										-----> confirmado.
										-----> O [actual] está sem as propriedades do objeto caller.
										a um loop, o actual perde suas propriedades, e passa para o objeto caller!
								----> o actual no começo da função orquidea, TEM QUE COPIAR OS DADOS do objetoCaller,
								apos o termino da funcao, o actual passa as modificações para o objeto caller...
								-----> NO CONSTRUTOR, o objeto actual obtem os dados inicializados..

								-----> falha grave: confusão de objetos quando instanciados!
										-----> o construtor orquidea deveria copiar apenas os parametros, antes de chamar
										a funcao orquidea, que executa o codigo.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.05:	

(x)[Metodo.ExecuteAConstructorOrquidea]:
				(x)------> falha na passagem de parametros para o objeto instanciado.
				(x)------> objetos orquideas construidos, o construtor está validando.
				(x)------> no construtor, bem que deveria dar uma limpa nos objetos propriedades do actual (ou objeto caller),
				mas não modificar o actual, ou o objeto caller. (inviavel ante a logica de instanciacao da linguagem, precisa
				de cada objeto mesmo sendo propriedade sem objeto que guarde).


(x)[Metodo.ExecuteAMethod()]
				(x)-----> fixado o construtor, mas está falhando numa passagem de parametros para a função [Draw].
						------> sem previsão para objeto [ExpressaoPropriedadeAninhada], em [Metodo.BuildParametros]!
									-----> feito o codigo, porem está retornando um valor [Objeto], para
									valores de propriedade aninhada. problema de logica de programacao, o processamento
									de parametros estava com erro de if/else em blocos de casos de parametros.


(x)[GameLibrary][SpaceInvaders]:
				------> verificar se os objetos ship estão com suas propriedades, na instrução while.
						------> objetos com propriedades inicializadas, presentes no escopo da instrucao.
				------> falha de natureza desconhecido está igualando as coordenadas de desenho, aparecendo apenas uma dos ship.
				variacao da imagem para desenho está sendo feito.
				------> tem que setar as coordenadas com o objeto caller da propriedade, ou atualizar tais propriedades
				com dados do objeto caller ship.
								-----> é meio estranho instanciar todos objetos em tempo de compilação, abarrotando
								a lista de objetos dos escopos, e ter que atualizar com dados dos objetos caller. mas está operacional.
								-----> claro, o numero de objetos não é grande: instancia 1 objeto somente, para o objeto currente.
								se tiver um bloco que executa 1000 vezes, NÃO VAI INSTANCIAR UM OBJETO 1000 vezes! (como
								nos compiladores normais, colocando na pilha).


(x)[GameLibrary][SpaceInvaders]:
				(x)------> utilizar um [Vector] de [SHIP].
								------> a imagem aparece, mas as coordenadas estão em (0,0);
								------> o objeto resultante em [GetElement] está como [invader1], deveria ser [obj13]!
				(x)------> os termos é como segue: os objetos SHIP estão sendo instanciados, e atualizados no escopo, corretamente,
				porem na atualização do updateVector, as coisas não estão funcionando corretamente.
				É JUSTAMENTE a chamada de update do vetor.

				(x)------> funcionou? Sim! Mas é preciso entender porque o ship currente está voltando como resultado de GetElement.
				mudando o nome do objeto caller, invalida, mas neste caso o nome do caller mudado NÃO FAZ DIFERENÇA, porque
				é um objeto a ser inserido num array. Mas como tem um objeto no escopo com o nome do objeto caller modificado,
				algumas propriedades estão null!!!
								------> sabe porque volta como o ship currente? PORQUE O REGISTRO DO ELEMENTO NO VECTOR
								TEM O NOME DO ELEMENTO do ship currente! Volta um elemento, MAS ESTE ELEMENTO TEM NOME,
								e é o nome de que registrou quando na instanciacao de elementos!!
											------> caso resolvido.
											
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.05:

*--->[ExpressaoPorClassificacao][3a.chamadaDeMetodo]:
				------> verificar a construção da 3a. chamada, funcao extendida. não está claro.
						----> ESTÁ FUNCIONANDO.

*--->(talvez numa proxima manutencao)
						[mudança]:	
						(x)-----> na 3a. chamada, remover o objeto que fará a ponte;
						(x)-----> remover este objeto dos parametros da 3a. chamada;
						(x)-----> fazer 3aChamada.isIncludeCallerAsFirstParameter=true;
									-----> isto incluirá o objeto caller  como 1o. parametro da 3a.chamada;
						(x)-----> no metodo que implementa no wrapper, mudar os parametros, sendo o 1o. parametro o objeto caller,
						que conterá a atualizacao no elemento do wrapper;
				(x) tudo feito bonitinho, mas a funcao insiste em seta o isIncludeCaller= false;
						  -----> (x) a 3a. chamada sumiu!
						  ------>(x) inserção do objeto caller feito corretamente, todos parametros estão lá.
						  porem o objeto caller não é o objeto caller da 3a. chamada.
										(x)-----> o caller é [vector], mas mudou-se para [SHIP]!, por força em
										EvalExpression.
														(x)------> inviabilizou a 3a. chamada de metodo! porque o 
														caller deveria ser o 1o. parametro, mas [SHIP], nao [Vector];
														(x)------> mudanca para o [objetoUpdate].
																	-----> está atualizando com dados nao nulos, porem
																	não está mudando de valor!
														(x)------> modificacoes feitas quebrou o codigo!

							-----> o objeto de updateDeFuncao não está sendo modificado!
										(x) -----> (fixado) o problema é como segue: o objeto update não foi inicializado, e retorna null porque não tem as propriedades do objeto caller.
										-----> os valores nao mudam!
														(x: constatado)-----> é na 2a. passada, que o valor é resetado! (está pegando o objeto errado, a função GetElement());
										(x) -----> o vetor do cenario nao está atualizado!		
														-----> precisa atualizar o vetor NO ESCOPO!




						
*---->(ANOTAÇÃO)[GameLibrary][SpaceInvaders]:
				------> falha na tentativa de utilizar um loop para atualizar e desenhar os ships. este procedimento
				é cruscial para o processamento de muitos SHIP, no jogo é preciso +20 SHIPs.
						-----> se nao utilizar a variavel do loop, atualiza, mas apenas 1 nave aparece.
									-----> nao está havendo atualizacao dos [ships] paraa o [vector] de ships.
				------> há outra maneira: passar o SHIP para uma função que atualiza os valores, sem necessidade de 3 chamadas de metodo aninhadas: NAVES.Update(Ship umaNave){umNave.funcaoUpdate();};

*--->[PROJETO]:
		(x)-----> desculpe, MAS É SABOTAGEM!!! 1o., a propriedade double teima em ser int32. 2o., o valor não é repassado para o
		lugar onde deveria estar!!!
						-----> escrito uma funcao em Castings, que trata justamente para isso.



[GameLibrary][SpaceInvaders]:
	
	[Metodo]:
				*----> Em Metodo.BuildParametros, se na expressao objeto pegarmos o valor, o codigo passa, mas se pegarmos o objeto, o codigo
			não passa, mas o valor está atualizado neste caso.
						*----> procurar no codigo quando há o processamento do objeto update (obj13), que o valor está diferente
						do valor de face.
				*----> o problema é que o valor de objetoCaller.valor, e actual.valor, estvam desatualizados.
			COMO DO TIPO [OBJETO], o campo valor tem que ser preenchido com obj.valor=obj.

	

	*----> voltou a funcionar, pela fixação de obj.valor= obj.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.05:

*-----> [EvalExpression]:
			----> (x) removido um monte de codigo que nao fazia nada.

[OBJETO]:
			*----> (x) procurar todas passagens de objeto do tipo [ÕBJETO], para preencher o valor com o proprio objeto em questao.
							-----> modificacao feita na fonte: na instanciacao de [Objeto].


[GameLibrary]:
			-----> cenario de teste para loop com vector, sucedido.

			-----> verificar a perda de desempenho do jogo cenario.
							-----> não há ploriferação de objetos, estão apenas os objetos em 1 instancia para cada objeto.


[GameLibrary][RectColision]:
			-----> nova funcao para detecção de colisões entre dois objetos, com coordenadas e dimensoes obtidas do jogo.



[GameLibrary][Biblioteca alternativa]:
			*----> ImageSFML;
			*----> LoopGameSFML;
			*----> InputSFML;


[GameLibrary][Biblioteca SFML alternativa]:
			*----> (x) cenario de teste de desempenho.
			*----> (x) implementar a entrada de teclado.
		*----> pesquisar o tratamento de eventos SFML.
		*----> acertar o desenho de textos, precisa instanciar um Text toda vez que for desenhar um texto (perda de desempenho);


[GameLibrary][Biblioteca SFML]:		
		*----> escrita do esboço de game SpaceInvaders, feita para SFML, sucedido. Porém, há perda de desempenho, o temor não esperado.
				----> diminuição das dimensoes das imagens aumentou o desempenho.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 8.5:

[Otimizações]:
		-----> econtrar gargalos de desempenho.
				----->o gargalo está no processamento de classes orquidea: para classes importada, o desempenho foi melhor.
			
*---->[EvalExpression],[Metodo.funcoesExecute]:
		-----> teste de stress: 
				expressao.GetType()==typeof(ExpressaoChamadaDeMetodo), versus
				expressao.type==Expressao.ExpressaoChamadaDeMetodo (uma constante de numero int);
						-----> testes de desempenho sobre isso: o constante int é 99% mais rapido que o getType!!!!!
				------> IMPLEMENTAR URGENTEMENTE A verificacao do tipo de expressao, utilizar uma constante inteira,
				substituindo GetType()+typeOf();
						------> substituicao feita em: [Exrpessao], [EvalExpression], [Metodo];

*----> [Metodo]:
		(x)-----> um if estava com logica errado, chamando toda vez quando era funcao importada.
		(x)-----> em BuildParametros(), logica errado no processamento de parametro do tipo [Objeto], e expressoes como: x+y;
		(x)-----> verificar o carregamento de função, via UtilTokens.FindMethodCompatible(), toda
				  vez que se executa uma função orquidea (função não importada); (remoção, codigo antigo no caso de nao haver escopo uma funcao orquidea,
				  mas toda funcao orquidea tem escopo do corpo da funcao);
		

		-----> teste de Carregamento de Escopos, em Metodo.ExecuteAMethod();
		
*----> [Resumo de GameLibrary]:
				*-----> pensando em perda de desempenho por incompatibilidade de library de jogos, mudou-se para outra library de jogos.
				mas o gargalo está no processamento de classes orquideas.
				*-----> dá para fazer um jogo, mas por enquanto sem classes orquideas.


		
*----> [GameLibrary]:
		(x)----> acertar o desenho de textos, precisa instanciar um Text toda vez que for desenhar um texto (perda de desempenho);


*----> [ExpressaoPorClassificacao][WrapperDataVector]:
			(x)----> acertar a funcao: [UtilTokens.FindMethodCompatible], para compor com parametros que seja WrapperObject.
			no esboço de jogo, é preciso instanciar uma imagem sfml, para então passar para a funcao de desenho.
			quando acertado, chamar a função com o vector de imagens diretamente, sem instanciar uma imagem temporaria.
						----> a falha estava no [WrapperDataVector], que não estava retornando os tokens apos a anotação wrapper.


*----> [GameLibrary]:
			(x) nova funcao de desenho de imagens: com o objeto de [ImageSFML], não precisando acertar os ids, pela ordem de criação
				das imagens,o que pode ser incomodo, e sujeito a falhas.
			(x) nova funcao de desenho de textos: com um objeto [TextSFML], nao precisando do ids, que pode gerar falhas,
				se não observar a sequencia de instanciação de textos.

			(x) fechamento de janela operacional, com tratamento de eventos sfml, especificamente o evento de fechamento de janela.

			(x) eventos de janela paraa pressionamento/despressionamento de teclas operacional, com tratamento de eventos sfml,
				para teclado.

[Jogo Invaders]:
			(x) agora é possivel manipular as imagens do jogo, por elemento de vetor, passado como parametro para uma função!


_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.05:


(x)[Resumo do Projeto]:
		*-----> a ideia é corrigir e fixar o codigo a medida que o jogo vai sendo desenvolvido, ante
				a quantidade enorme de testes que deveriam ser feitos, para encontrar tais falhas.



(x)[GameLibrary]:
		*-----> novas classes de sons e musicas, com SFML;
						(x)------> classe Sound;
								(x) sounds;
								(x) musics;

						(x) ------> remover a library Sound.dll, que estava utilizando outra library base.

		*----> classe [MapLevelPixels] reformulada para compor com SFML. eu não sabia que a biblioteca SFML tinha
		um modo de obter a cor de 1 pixel...


(x)[Biblioteca de Games]:
		*-----> utilização da biblioteca SFML, em vez de RayLib, por problemas de compatibilidade com o projeto.
		ate a um proximo projeto!! O problema é no projeto, não da biblioteca..
		
		*-----> rescrever a classe MapPixels, compondo com  SFML.

(x) GameLibrary:
		*-----> nomes de classes importadas da biblioteca de desenvolvimento de jogos, mudadas para nomes mais realistas,
		não fica de bom tom nomear classes importadas com a biblioteca grafica utilizada.


(x)[Objeto]:
	    *-----> Nova ideia para ler campos de uma classe importada: como deriva de [Objetos], em [Objeto.propriedades],
				setar para A PROPRIEDADE da classe importada!
				*-----> implementado. testes com uma classe importada, resultou em dado validado para uma propriedade!
				*-----> com esta ideia, é possível codificar SETTERs/GETTERs para classes importadas.
							*----> cenario de teste mais codigo orquidea, para uma variavel int captando o valor de GETTER de imagem,
							validou.
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.05:

[Jogo Invaders]:
		------> continuar com a codificacao do jogo.
					
					*-----> inclusão da nave do player.
					*-----> codificacao de funcoes de controle de teclado mais consistentes, sem handlers, tratado
					diretamente dentro do jogo. os handler foram utilizados em outro jogo proprio, mas para a linguagem
					orquidea, fica um  pouco dificil testar, validar.


						(x)-----> falha numa expressao: [window.Draw(images[i],coordsXInvader[i], coordsYInvader[i])], regressão para
						cenarios de expressao.CONSIDEREI imprencidivel chamadas de metodos com elementos de vetores como parametros.

									[CONSTATAÇÃO]: com uso amplo de vetores, é possível criar um jogo sem recorrer a classes orquidea,
									paralisado temporariamente devido a problemas de perda de desempenho.

						

		(x)-----> modificacoes em [ExpressaoPorClassificacao] quebrou o codigo!
					(x)fixar com os cenarios de testes:
									 (x)[TestesPropriedadesAninhadasEchamadasDeMetodo];
									 (x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
									 (x)[TesteChamadasDeMetodoAninhadasComWrapperObject];
													-----> falha justamente no codigo para fixar a expressao com vetores.
															-----> codigo anterior a fixação gerou a falha.

					 (x) verificar outros cenarios, a depuração terminou antes de completar todos cenarios.
										----> a depuração não termina, atingiu a capacidade maxima de memoria, ou recursos.
										mas até onde deu, validou os testes, com exceção de [TestesPropriedadesAninhadasEchamadasDeMetodo],
										que é um cenario exemplar, e toda vez que muda de posição, falha, vai lá testar e valida....

					  (x) testes com cenarios de [EvalExpression] feito.

		(x)----> com a descoberta de que classes que herdam de [Objeto], as propriedades dos itens do [MapLevelPixels], foi modificado
		com adição de [Objeto.propriedades], tornando possivel o processamento de items diretamente com suas informações.



(x) falha justamente no conserto para multiplos wrappers objects!
						


(x)---->[Vector]:
	(x) testes com processamento de [Vector] numa malha for, para validar funções como v.size(), dentro de uma malha for.
		em ultimo momento, fixou-se uma falha em [WrapperDataVector.SetChamadaDeMetodo], que não é igual ao processamento
		de [WrapperDataVector.GetChamadaDeMetodo].


[Jogo Invaders]:
		(x)----> fixar com os erros de compilação.
				(x)----> a falha está na construção de uma instrução if, que não está validando a expressão condicional.
							-----> o erro na construcao  de blocos de instruções, que codigo antigo removia os objetos
							que estavam no escopo pai.

				(x)----> o jogo está sem erros de compilação, mas há falha na logica de propgramacao.
	

		
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.05:


(x)---->[WrapperData]:
		(x)----> fixar em todos wrappers data, com exceção de [WrapperDataVector], o ajuste feito para processamento de multiplos wrappers objects.


(x)---->[GameLibary]:
		(x) ----> verificar o jogo invaders.
					----> (x) falha no processamento do vector [CoordXInvaders];
								----->(x) a falha está no processamento de SetChamadaDeMetodo, de [WrappersDataVector];
											----->(x) instrução SetChamadaDeMetodo, não podia ter mais de 1 wrapper object!
														-----> (x) codigo especifico para este problema. quantos mais problemas irão aparecer?


					----> A falha continua.
								-----> na expressao problematica, cortou o sinal de +, inviabilizando a conta!
											-----> uma falha: a lista de tokens nao pode mudar (dentro da funcao GET/SET wrapper objects),
											porque se mudar, inviabiliza.
											-----> a falha está no processamento dos operadores! (+,-,*,/,...), para este caso.
															------> modificação arriscada, no processamento de chamadas de metodo.
																			----> contornado, o processamento de chamadas de metodo anterior, não contava
																			com mais processamento que não funcoes a mais.

		(x) perda gritante de desempenho.



(x)*---->[Metodo.ExecuteAMethod],[Instrucao]:
			*-----> verificar se há necessidade realmente de carregar os escopos de corpo de metodo, e escopos de bloco.
						(x)-----> escopo de bloco é essencial, a não ser em expresssões de atribuição, verifica
						se o objeto da atribuicao está ou não instanciado. mas ainda há o problema de passar
						para o escopo externo um objeto do escopo corpo do metodo.
						(x)-----> escopos ROOT, e PARAMETROS, removidos.

			-----> (x) escopo ROOT, escopo externo (este é necessário sim) e escopo de propriedades estaticas, 
			não são necessários para funções orquidea! porque o escopo externo 
			está fora do escopo do corpo do metodo, e por questão de visibilidade, um objeto dentro do escopo do corpo do metodo
			não pode acessar um objeto no escopo global. e o escopo root não precisa.
						------> retirado o Escopo.ROOT, e escopoPARAMETROS, melhora de desempenho.


_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.05:

*----->[ExpressaoPorClassificacao]:
			-----> fixar com os cenarios:
					(x)[TesteTipoDeExpressaoCondicional];
					(x)[TestesFuncoesAninhadasJaggedArray];
							-----> nao foi feita a atualizacao de extensao de funcao.
					(x)[TesteFuncaoOperacoesAritmeticasComObjetoActual];

			 -----> estimativa de término de todos cenarios de testes: 4,5 min.


[Escopos]:
			(x)-----> VERIFICAR URGENTEMENTE os escopos para funções importadas, e se possivel, otimizar.
							-----> clonagem de escopo externo sem necessidade, melhou um pouco o desempenho.

			(x)-----> verificar se há mais escopos a retirar, ou modificar o codigo, no caso do EscopoCorpoMetodo.
							-----> removidos o Escopo.ROOT, e EscopoParametros.
			-----> verificar também os escopos de blocos, em instrucoes;
							-----> verificar os escopos de blocos.

			-----> o escopo corpo de metodo poderia não ser instanciado, SE em eval expression, não houver registro
			do objeto de atribuição, instanciar?



*----->-[Metodo.ExecuteAMethod()]: otmizações.
			-----> otmização para funções wrapper, como [Vector], para melhorar o desempenho.
							-----> funções otimizadas: SetElement, GetEleement.

*------>[Jogo invaders]:
			----> para melhorar o desempenho, a coordenada y dos invaders, foi resumida numa só variavel.
							-----> algumas falhas de logica de programacao, mas sem resultar em falhas na execução do jogo.



[chamadas de metodos aninhados]:
			-----> o objeto caller das chamadas de metodo aninhados são o resultado da chamada anterior!
			Então, se pegarmos o endereço do 1o. retorno de chamada(um ponteiro), e na chamada de metodo seguinte,
			utilizarmos este endereço como objeto caller, e depois atualizarmos o objeto da 1a. chamada com o endereço
			do 1o. retorno, e SE TIVER O RESULTADO NÃO CLONADO, É POSSIVEL POR PASSAGEM DE REFERÊNCIA.

_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.05:

(x)*---->[Otimizacoes]:
			-----> debate sobre o escopo de metodos: não instancia, ou instancia cada variavel conforme entrar em processamento?
			vai precisar de um escopo para guardar as variaveis inicializadas, senão vira bagunça....
			-----> talvez um problema de desempenho em [Vector] seja a conversao de [Objeto.valor] para [VECTOR(Objeto.valor)].
			se guardarmos uma referencia do [Vector] de objeto.valor, não fica mais rápido, não?
			-----> considerar um acesso direto ao [Array] de [Vector], em vez de uma chamada invoke.
			
			
					-----> fazer um teste de performance: GetElement (com as conversão citado) vs Get (sem conversão, acesso
					direto de indice) vs acesso direto ao [Array] de [Vector].
							-----> testes feitos! acesso direto: 19s, 538/673 para Get e GetElement,  para um malha de 100 ciclos.


(x)*----->[Otimizacao]:	
				-----> codificar o acesso direto ao vetor, se for [GetElement], [SetEleent], tomando cuidado com
				o casting para [Vector].
						-----> FEITO, e muito: o desempenho melhorou e muito! Um porem mas nada complicado,
						foi inscrever dentro de [Metodo.ExecuteAMethod()], uma caso de uso somente para acessos GET/SET
						de [Vector]. o [Vector] é uma classe cruscial para todas linguagens de propgramação.
						nesta linguagem, o [Vector] pode ser um array, ou funcionar como uma lista, com a instrucao: Vector.Clear(),
						e adicionando elementos com Vector.Apppend();


			
			
(x)[Jogo Invaders]:
			*-----> implementar as bullets: instanciação, movimentação, e testes de colisões.
			*-----> o problema da lentidão de teclas pressionadas.(fixado com a otimizacao de [Vector]).
			


(x)[jogo Invaders][Instrucao for]:
			-----> na esta compondo como for (int i=0;i<vetor.size();i++); // não está aceitando [vetor.size()];
						----> É uma questão de lógica: nem todos elementos do vector estão instanciados,
						o que pode resultar num objeto null para processamento.
			-----> cenario de teste em [Vector] não resultou falhas.

(x)[Vector]:
		-----> atualizado as funcoes: insert, remove, set, para compor com o vector [Objeto.valor].

(x)[Vector2D]:
		-----> atualizado para compor com propriedades de [Objeto].
						----> testes, getter funcional.

(x)[GameLibrary]:			
		-----> implementar a funcionalidade de mouse position, mouse click, doubleClick, mouse wheel.


[Mouse Eventos]:
		-----> esboço de jogo para verificar as funções de mouse.
						(x)----> codificado o esboço, adaptando o antigo esboço de verificação de mouse.
						(x)----> está retornando um erro de compilacao, mas verificando os arquivos, está funcional.

[ANOTACAO]:
		-----> toda classe importada, deve herdar de [Objeto], e o campo [Objeto.valor=this],
		importante para o processamento da linguagem orquidea.

[Instrucao Create][problemas de reconhecimento de nomes de propriedades na tabela hash do classificador]:
		-----> para objetos importados, vai ser preciso registrar na tabela hash do [ExpressaoPorClassificacao],
		cada propriedade de objetos importados. porque senao, o classificador não vai reconhecer propriedades de objetos importados.
					-----> um problema de logica de programacao: vai ser inserir os nomes de propriedades,
					mas não há como obter os nomes das propriedades, senao na execução do programaVM!
					-----> o PROBLEMA é resolvido, se instanciar funções GETTERs/SETTERs para cada propriedade 
					criada com [Objeto.SetPropriedade]! não tem outra solução!
					-----> OU então, chamar no codigo a função [Objeto.GetPropriedadade(nomeDaPropriedade)],
					fica melhor, não precisando criar setters/getters.
_____________________________________________________________________________________________________________________________________________________________________________________________________________		
Daily Scrum 16.05:

[Jogo Invaders]

(x)----> (x)----> sistema de colisão, destruicao de invader funcional.
		 (x)----> codificar sistema de invaders disparar.
					----> sob cenarios de testes;
					

(x)---->[Score]: a atualizacao do placar não está funcionando.
			(*)----> será preciso que Text herde de Objeto, então acrescentar propriedades como [caption, x, y],
				     e codificar [Text.SetText]:
			
			(x)----> para mudar o texto, vai ser preciso utilizar a funcao de DrawText com o id do texto.
						---> nao esta aparecendo o novo texto, do score.
	

[Jogo Invaders]:
			------> relato de out of memory!
					(x)----> uma falha na clonagem de [TabelaDeValores] gerou um loop infinito que consumiu a memoria!
					SABOTAGEM: UM TRECHO DE CODIGO QUE NAO TEM NADA A VER, está causando a falta de memoria!!!!

(x)[Sound]:
			------> caminho de arquivo de sons e musicas, path relativo, sem precisar o path completo, que é exigido para
			SFML sounds, musics.
						------> tocado um som, uma musica, com path relativo. o sistema de arquivos [FileInfo],
						retorna o path completo.



(x)[Projeto]:
		   (x)-----> verificar a formação de expressoes condicionais com &&, ||, em [if/else].
								-----> sem previsão em classes int,float,double,char, bool! 
											----> implementado, mas contina lançando erro de compilação.
														-----> como foi inserido muito tempo depois da codificacao de operadores nativos,
														uma parte do codigo de [ExpressaoPorClassificacao] não terminava
														quando o processamento de operadores conectivos &&,|| terminasse,
														caindo em outro caso de uso, gerando um erro de compilação.

			(x)-----> verificar se as atribuicoes, estão criando mais variaveis, o operador = foi da função que lançou a exceção.
								------> laços for agora também com variavel de malha definida antes, poupando a instanciacao
								quando executar o laço for.
								------> implementação desse laço [for] validado.

		


(x)[Sound]:
		*-----> codificar no jogo "invaders", sons de tiro, hit, explosao, e uma musica.		
		*-----> codificar no game uma musica de fundo.
						------> compilacao feito sem erros quanto a sons e musica. cenario de jogo apos a implementacao
						do coletor de variaveis.

	
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________						
Daily Scrum 17.05:

			
(x)[Eficiencia memoria]:			
			-----> implementar um coletor de variaveis, semelhante ao Garbage Collector:
			por um lapso de tempo, verifica o escopo Externo de [Metodo.ExecutAMethod],
			relatando (saida no terminal), o numero de objetos com mesmo nome.
			Mais tarde, este coletor eliminará as variaveis com mesmo nome, resultando
			em caso de perda de memoria adequadamente.
						-----> verificar se o deslocamento de instanciacao de variaveis de malha for,
						para 1 ou 2 variaveis apenas, resolveu o problema de estouro de memoria.
						-----> nao foi detectado nenhum vazamento de memoria... e agora?
	
			------> ATOS DE SABOTAGEM! dando falhas no codigo que estava correto!
						-----> antigo app voltou!


(x)[Invaders]:
		------> estimativa de tempo de compilacao: 1min,20seg.
		[cenarios]
				-----> VERIFICAR: tocar sons, tocar musica, problema de estouro de memoria, texto de score sendo mostrado apos pontuacao.
								-----> musica tocando.
								-----> sons tocando.


(x)[OperadoresNativos]:
		------> encontrado uma falha grave, numa lista de metodos implementador, que não era estática, exigindo calcular toda
		vez que obtesse um operador, causando grande quantidade de memoria, e desempenho.
					-----> fixado o estouro de memoria, e o programa VM ficou muito, muito melhor..


(x)[Jogo Invaders]:
		------> o sistema de atirar quebrou!
					-----> o operador unario ++ não está operacional, causando falha quando o player atira.
								-----> explicitando a operacao com + operador.


(x)[EvalExpression]:
		------> (x) investigar se o operador unario ++ está operacional. Nao está funcionando, faltou a atualização do escopo.
					------> FALHA DE NATUREZA MALEVOLO ESTÁ IMPEDINDO OS OPERADORES UNARIOS FUNCIONAREM.	
				
[JaggedArray]:
		------> este wrapper não está operacional para mais de 2 colunas.


[Esboco de testes de mouse]:
			-----> o programa está travando!	
						----> problemas no GETTER: Vector2.GetX();
									-----> quantidades de propriedades de Vector2D>3000!

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.05:
			

(*)----->[Vector]:
		-----> teste com função [Vector.remove];
				-----> funcao remove funcionando;	
		-----> teste com funcao [Vector.Clear], [Vector.Append];
				-----> funcao append funcionando;
(*)---->[EvalExpression]:
		-----> (x)verificar urgentemente O OPERADOR CONDICIONAL [not: !], parece que não teve previsão!
						----> previsto, mas não implementado totalmente.
		-----> (x) operacional. deve envolver entre parenteses, a expressao condicional negar: (!(x<y));



(*)---->[Input.MousePosition]:
		----->(fixado) quantidades de propriedades de mouse position > 3000!	


[ProcessadorDeIDs]:
		-----> instalado uma variavel estática para indicar a linha em que ocorreu uma falha. precisa melhorar,
		contando as linhas de comentário.
		-----> (x) falha grave de instanciacao de variavel dentro de um bloco de [instrução while], resultando em falha.
						----> fixado com instanciação fora do bloco while.

[Jogo Invaders]:
	-----> a colisao de invader e missel está ocorrendo sem colisoes.
			----> (x) melhorou um pouco, mas na sequencia, os invaders sao atingidos.
			----> as coordenadas Y do missel estão em 0 apos atingirem a borda da tela, ou algum invader!
			----> (x) erro de compilação num dos blocos de if/else;
						----> um codigo mal elaborado, melhor, com confiança numa clonagem de tabela, que não precisava,
						estava lançando uma exceção. porém, o erro de compilação foi capturado corretamente..
			----> (x) o contador de misseis não está funcionando.
					-----> contador estava sendo atualizado com operador unario: não está funcionando corretamente.
			-----> (x) vetores com dimensões com variaveis funcionando.
					-----> (x) atualizados todos vetores com dimensões de variaveis de quantidades de objetos.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.05:

[ProcessadorDeID]:
	(*) -----> um bloco try resolveria problemas de compilação, em ProcessadorDeIDs.CompilarEscopos();
						-----> já havia um bloco try/catch, mas na escrita do  erro nao especificava a sequencia com falha.
	(*) -----> verificar instrução if/else.
						-----> cenario de teste, não detectou nenhuma falha.



[UtilTokens]:
	(*)-----> resolvido de vez o lançamento de erros: unir os tokens em uma string, e lançar na 
	mensagem de erro: não tem a linha, porque não dá devido a mudanças com wrapper objects,
	mas pelo menos tem algo para verificar...
		

[ParserAFile]:
	(*)-----> se houver erros de compilação, mostrar no terminal as mensagens dos erros, e dar uma opção do dev de continuar ou não a execução do programa VM.


[Jogo Invaders]:
	-----> (fixado) o programaVM do jogo bugou! (está travando).
	-----> (fixado) os misseis do player mudam de coordenadas Y, quando lancados, apos um 1o. missel!
				(*)-----> na funcao [Vector.remove], os vectors de coordenadas de misseis estão todos preenchidos!
						----> é porque o tamanho do [Vector] é diminuido 1 unidade para cada remoção de elemento,
						quando se cria um novo missel, o [Vector] está com 1 unidade a menos. 
				(*)-----> Vector funcionando como lista, removeu a falha.



[Vector]:
	(*)-----> considerar a possiblidade de mudar o objeto que guarda os elementos, de [Array] para [List],
	que possibilita remocao segura, e adicao de elementos sem afetar o campo size, na remocao.
				(*)-----> modificacao feita. é uma lista, mas devido a algoritmos de insercao e remocao e de indices mais utiilizados,
				a perda de desempenho é praticamente não.
				(*)-----> revisar o codigo de [Vector], algumas funcoes estão alterando o [Objeto.valor] E Vector.VecObjects.


[Jogo Invaders]:
	-----> acionar o atirar de invaders;

	-----> alterar de contador de missels/bullets, para compor com as dimensões de cada vector,
			ficando nitido o algoritmo. a função [Vector.size()] está sem erros, anteriormente havia confusão
			de dimensões, já que a alocação era em quantidade, tornando dificil saber a dimensão do vector, claramente.
					(*)-----> (sim, há previsão) não há previsão para chamadas de metodos, para limites de uma malha for!
								----> falha desconhecida está invalidando o codigo do jogo!


	-----> placar funcionando;

[InstrucaoFor]:
	(*)----> compor as expressões de malha, para no limite, puder ser também uma chamada de funcao;
				----->já há previsão para chamadas de função na malha.


[ParserAFile]:
		-----> testes de linhas de codigo.
					----> parece não haver contagem das linhas de comentarios, e linhas vazias!


[Text]:
		(*) -----> testes de desenho de codigo.
				(*) ----> fixado uma falha de sobrecarregamento de fonte de textos, em função de chamar toda hora [SetText].
				(*) ----> programa testes validado;
		(*) -----> (fixado, com novo codigo com uma variavel como parametro) causa desconhecida no jogo invaders, no texto de score!
					-----> passagem de parametros de texto+funcao, diretamente no texto, não funciona!
					sem previsão para esse parametro!

[ParserAFile]:
		(*) ----> parece não haver contagem das linhas de comentarios, e linhas vazias!
						-----> cenario de teste como programa "HelloWorld.txt", para verificar onde está a falha na contagem de linhas.
									----> uma falha de logica de programação: quando há uma linha vazios, é para diminuir em 1 unidade o
									contador de linhas, não aumentar em 1 unidade!
									----> quase validado, está havendo contagem de uma linha a mais.
						----> cenario de teste com um erro, para validar a contagem de linhas.
									----> falha completa quando se tem classes.
												----> parece que há um reset em algum lugar, que está atrapalhando a contagem de linhas.
									----> contador de linhas funcionando, para programas sem classes.
									----> contador de linhas, com classes, funcionando, para 1 programas de teste.
						----> não é Física Quantica: não vale o que estou pensando e vira realidade! só de escrever parece
						determinar o sucesso ou falha do código?

						----> melhor pensamento para contagem de linhas, mas com [ParserAFile], e [ProcessadorDeIDs] combinados.
									-----> ligação de [ParserAFile] e [ProcessadorDeIDs], através [SystemInit.contadorDeLinhas],
									relatado a falha em [UtilTokens.WriteAErrorMessage].

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 22.05:

[Jogo Invaders]:
		(*)-----> modificações NO CODIGO DO JOGO para compor em malhas for, vector.size();
						-----> o codigo não está reconhecendo a função [size()]!
									-----> SABOTAGEM! em testes unitarios, a funcao [Vector.size()] validou, para laços for!
									e com variaveis como declaração de tamanho de vetor!
									-----> FALHA: o vector do laço é do tipoElemento="double", mas no laço, exige que seja um "int"!
												----> NÃO! o typeReturn da função deveria prevalecer, mas está setando para
												o tipo de elemento do wrapper object vector! A falha é na lógica de programação
												em [ExpressaoPorClassificacao]!
														----> NÃO! há casos em que o tipo da expressao
														chamada de metodo tem que ser o tipo de elemento da função, E HÁ OUTRO casos em que o tipo 
														tem que ser o tipo de retorno da função. Tentativa de solucionar resultou em +30 erros de compilação!
														revertido para a versão sem esta corretiva...
												----> nova tentativa, melhor, mas o tipo da expressao continua double, deve setar
												o tipo da expressao em outro ponto do codigo...
														-----> setado direto na expressao chamada de metodo, resultou em +30 erros de compilação!
														revertido para versão estável.


		-----> modificações NO CODIGO DO JOGO, para vector.Append(x+3.0),p.ex.;
							----> falha.


[Bullets Invaders]:
		(*) -----> funcao randomica de tiro está funcionando em outro cenario de teste.
		(*) -----> Append com expressões-parametros com vectors, não há processamento!
					----> sem previsão para parametros como: v[0]+3.	
							----> se quiser um codigo robusto, vai ter que processar parametros como: v[1]+2;
							----> sabe onde está a falha? no wrapper data vector!, instrucao GetChamadaDeMetodo,
							tokens processados...
										----> é vector dentro de vector, não tinha previsão para isso...
												(x)----> quase lá, os tokens processados estão corretamente feitos,
												mas o indice de malha em [ExpressaoPorClassificacao] está
												incorreto.
												(x)----> agora é preciso limitar os tokens processados para
												apenas conter v[1], e nao v[1]+3;


		-----> acionar o sistema de tiro dos space invaders;
		-----> tiro dos invaders operacional, no entanto os bullets não estão sendo desenhados.


		-----> finalização: Texto de "GameOver!", com sistema de leitura de tecla para reiniciar,
		e [GameOver] quando: 1- o player é atingido; 2- os invaders tocam o solo, completando uma invasão.


(x)[ExpressaoPorClassificacao]:
		fixar com os cenarios:
				(x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
				(x)[TestesPropriedadesAninhadasEchamadasDeMetodo];
								----> tem desgraçadinho brincando com os testes: quando se muda a posição da sequencia de testes,
								os testes passam!


(x)[Expressao]:
		fixar com os cenarios:
				(x)[TesteExtracaoExpressoes];
						----> teste desatualizado, ante a inserção de [ExpressaoAtribuicao];

				(x)[TestCreateSetElementGetElementMatriz],[TestesExpressoesMaisDe1ElementoWrapper]:
						----> falha na construção de expressões de atribuição. a falha está no processamento de GET/SET wrappers.
										---> uma falha antiga de lógica de programação, debatido há tempos na programação do projeto,
										resultou em falhas em GET Wrappers, em vez de SET Wrappers. 
										----> tipo matriz aceitando elementos "int", em vez de "double";



(*)[WrapperData Objects]:
		----> todos WrapperData: ajuste com base em [WrapperDataVector.GetChamadaDeMetodo], para construir expressoes como: a{"terra"}+"textoLiteral";
				-----> não faz sentido, porque é o caso de wrapper object dentro de wrapper object, e expressoes como isso não são operacionais.


(*)[WrapperData funcoes]:
		(*)----> se for uma chamada de função que não seja GetEleement/SetElement, o tipo da expressão
		é o tipo de retorno da função wrapper! confusão formada em função da anotação wrapper...
					----> diferenciar os 2 tipos de casos: Get/Set e funções de um wrapper, como [Vector.size()].
								-----> implementacao e teste feito.

(*)[Projeto Invaders]:
		-----> implemnenta a função [Vector.size()], em todos laços for.

[ParserAFile]:
		----> testes com mais programas com falhas, afim de determinar linhas de codigo sinalizando uma falha.
						-----> testes com jogo [Invaders], falha na exatidao da contagem de linhas.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 23.05:

(*)[Sistema de contagem de linhas com falha]:
		----> contagem de linhas, programas sem classes, validou.
		----> contagem de linhas, programa com classes, tb validou.
						-----> parece que a linha de codigo do nome de classe, é processado fora do escopo da classe.
									----> contagem de linhas para definicao, e corpo de metodos, mantido.
									----> contagem de corpo de classe, mantido.
									----> contagem com o nome de definicao de classe, removido.


[linhas com falhas]:
		----> mais testes, além de programa com classe/sem classe.
						-----> em 1 jogo de mais de 300 linhas, apontou proximo da linha de erro.


[Jogo invaders]:
		(*)----> verificar o que se pode fazer para o sistema de tiro dos NPC funcione.
						-----> um loop de desenho dos bullet, com variavel limite errados.

		(*)-----> verificar se a linha p.ex.: para vector.Append(x+3.0); ainda buga.
					----> se for possivel, criar um cenario de teste, ou um arquivo de esboço de jogo, afim de verificar porque linhas como estas estão bugando.
								  ----> JA FOI CRIADO UM TESTE, para Append, exatamente como apareceu no jogo, POREM VALIDOU!
												----> falha de natureza malévola, impede a compilacao de Append nestas condições...

		
		(*) -----> termino e recomeço do jogo, feito!!

[WrapperDataDictionaryText]:
		-----> verificar o tipo de elemento de [DictionaryText]: deveria ser string, mas está setando como a declaração do dicionary,
		que pode não ser string.


______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 24.05:

[Jogo Invaders]:
		-----> terminar a codificação de termino de jogo: é preciso setar qtInvaders=maxInvaders, principalmente.

		(*) -----> termino de jogo:
					----> o player atingiu todos invaders.
					----> um bullet dos invaders atingiu o player.
					----> os invaders aterrizaram.

[LinguagenOrquidea]:
		-----> codificação e implementação das palavras chaves: TRUE, FALSE, para variaveis booleanas.
					(*)----> valores dos tokens TRUE, FALSE, na classe [Objeto], como constantes string.
					----> acrescentar em [EvalExpression]:
									(*)-----> ExpressaoAtribuicao;
											-----> verificar a expressao de atribuição no caso de [TRUE], [FALSE].
													----> programa VM com instrução expressao valida de atribuicao bool, validado.
									(*)-----> ExpressaoCondicional;
									(*)-----> ExpressaoOperador;
											----> expressoes com operador retira da pilha de operandos, e como 
											constantes booleanas são guardadas como objetos normais..

					(*)-----> acrescentar em [ExpressaoPorClassificacao]:
									(*)-----> um caso de token, antes de casos de objeto, numeral, literal, para reconhecer os tokens.
											  formação de expressao de atribuição, expressao condicional, automatico,
											  porque TRUE, FALSE é um [Objeto], objeto booleano constante, mas [Objeto].
									(*)-----> atribuicao está caindo em outro caso!
													----> faltou registrar o objeto booleano, na expressao de atribuicao simplificado...
									(*)-----> construcao de expressao de atribuicao boolean, funcionando, porque [TRUE],[FALSE]
									é um [Objeto], sendo reconhecido como ExpressaoObjeto no processamento.



(*)[ExpressaoPorClassificacao]:
		-----> VERIFICAR URGENTEMENTE EXPRESSOES COMO "n=1;", com "n" sendo instaciado anteriormente.
						(*)---> (está reconhecendo sim) está funcionando. a falha está em expressoes recente "b=TRUE",
						não está reconhecendo TRUE como objeto,	setar no [ClassificadorDeTokens], como objeto [TRUE],[FALSE];
	

	
(*)[A novela dos vetores como objetos em chamada de funcao]:
	----> um objeto-elemento de vetor é um objeto anônimo! Não tem identidade definida, nome proprio!
	(nao tem nome definido: é composto pelo nome do objeto vetor, e um indice).

	----> quando uma chamada de função for GetElement, guardar o parametro-indice, e o nome do vetor.
	passar um objeto anonimo para a proxima chamada de metodo, como objeto caller,
	e depois SETAR O objeto-elemento com o parametro-indice e nome do objeto caller, tendo como elemento
	o objeto anonimo! depois, Destruir o objeto-elemento anônimo, tb.
					-----> cancelar o sistema de 3a. chamada de metodo, ante a interceptação feita
					em EvalExpression na avaliação de chamada de método citado..
					-----> não esquecer de atualizar o escopo!

			 ----> (x) atualizar a classe [ExpressaoPorClassificacao];
			 ----> (x) atualizar os cenarios de testes;


(x)[Instanciacao de Objetos]:
		-----> (atualiza o escopo em instanciacao com expressao de atribuicao) verificar se quando ocorre uma instanciacao, dentro de um bloco, ao executar +1 vez o bloco,
		não criará 2 objetos devido a 2+ instanciações. É quase certo que há um escopo.tabela.updateObjeto(),
		o que livra a instanciação excessiva. 
						(*)-----> (contornado anteriormente) falha grave detectada: instanciacao de objetos, instancia x vezes, se for um
						laço while, for, o que sobrecarrega incorretamente o escopo...
										-----> contornar com verificação se objeto já foi registrado.
										----> verificar o tipo de instrucao criado na instanciacao de 1 objeto.
														----> a instrução é uma expressao valida, do tipo [ExpressaoAtribuicao],
														então na execução com eval expression, é feito avaliação de [ExpressaoAtribuicao].
														----> a expressao de atribuicao está verificando se o objeto existe,
														e faz um update do objeto, atualizando o escopo, não registrando o objeto no escopo...
						(*)-----> é por isso que houve medo de instanciar variaveis dentro de um bloco while..
										-----> pode utilizar que não tem porém.

	

(*)---->[linhas de falha de codigo]:
	(*)----> análise de um arquivo-texto de programa, afim de determinar as linhas vazias, se precisa
	de ajustes, porque no jogo [Invaders], o erro da linha não foi exato, passou por +5 linhas de exatidão.
						-----> estudo e codificação para sistema de obtenção de linhas, a partir de um conjunto
						de linhas RAW, e um conjunto de Somente Linhas de codigo (sem quebra de linha, e sem tokens de comentatios de linha inteira);
	(*)-----> testes no dia após.
	
	
(*)[Vector]:
		-----> cenario de teste para função [Vector.Append] não setado adequadamente.
						----> sim, está setado corretamente.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 27.05:

(*)[EvalExpression]:
		(*)-----> expressoes condicionais: embora está funcionando, a logica de programacao não está perfeitamente:
		pode haver expressoes condicionais como [TRUE==a], em vez de [a==TRUE].
		(*) -----> cenario de teste para expressoes condicionais com [TRUE], [FALSE].
					-----> expressao condicional nao validado corretamente.
									----> avaliação de condicionais, sem conectivos codicionais, que é o caso, estava
									com verificação de elementos condicionais: TRUE, FALSE, estava em outro lugar.

(*)[EvalExpression]:
		-----> testes com chamadas de metodo em sequencia: v[1].Hash();
					-----> a função GetElement não está retornando um Objeto, neste caso! tinha que falhar mesmo..
								----> modificado para teste com uma classe [Objeto];
								----> instrucao de criacao de um elemento de vetor, não está sendo chamado.
												------> (x) o interessante é que anteriormente, a instanciacao de elementos de vetor
												estava funcionando perfeitamente.
												-----> (x) instrucao create nao atualiza o escopo!
												-----> (x) não atualiza porque está com o nome incorreto. e
												-----> (x) no caso de elementos-vector, foi codificado 2 instrucoes: uma de criação do elemento, 
												e outra de setar o vetor, com o elemento criado.	
																----->(x)está falhando na obtenção de [Create] o elemento, e também da expressão [SetElement]
								-----> (x) 1a. parte, instanciar o elemento do vector, feito.
								-----> (x) 2a. parte, chamar a função aninhada.
												-----> (x) verificar modificações no elemento-vector, pela funcao aninhada.


[Jogo invaders]:
		(*)-----> fixar o reinicio do jogo, quando todos invaders foram destruidos.
					----> faltou reinicializar as imagens dos invaders, que são removidas quando um invader é destruido.
					----> faltou também resetar a velocidade dos invaders, que é modificado conforme os invaders avançam.
					----> faltou resetar a posicao do player.
				----> o player precisa atirar novamente apos o reinicio do jogo.


		-----> o lançamento do jogo, só que com classes, fecha o product backlog de biblioteca simples de jogos.


[ParserAFile]:
		------> para codigo com classes, não está adicionando as linhas de codigo das classes.
		------> em algum trecho do codigo, ocorre falha na contagem de linhas. programas com grande quantidade de codigo, há falha na contagem.
							----> a falha ocorre com linhas onde começa uma tabulação, mas em seguida vem uma linha de codigo.


O PORQUE DE CONSTRUIR UM JOGO, COM CLASSES DA LINGUAGEM ORQUIDEA:
		-----> um jogo dentro de uma linguagem de programacao, sem funções ou classes, fica incompleto a validação da linguagem perante a construcao de programas validos,
		nesta linguagem.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 28.05:
		


(*)[ParserAFile]:[descricao de linhas de falhas]:
		-----> testes para programas 200-300 linhas;
				----> contagem de linhas, apesar de ser as linhas sem processamento, está fixado.
							-----> utilizado um dicionario para mapear o codigo e o numero das linhas. teste sucedido.
											----> mas como obter os tokens da linhas, exatamente como estão?
														----> formar um dicionario com polinomio de letras dos tokens.
							-----> fica assim então: forma-se o dicionario com chave: a linha do codigo (somente codigo, sem linhas vazias, linhas comentarios),
							e valor os tokens da linha. com o numero da linha, é possivel descrever o texto da linha! e o legal é que não haverá problemas de colisões
							de chave, já que cada linha contem apenas um indice de linha!
							

(*)[UtilsTokens],[ParserAFile]:
		(x)-----> implementar o dicionario numeroLinha-->textoLinha.
				----->primeiro teste, parece que está funcionando.
				-----> susto no cenario: misturou-se dados do dicionario de mapeamento, com os dados reais do programa,
				gerando tokens a mais, e com acrescimos de tokens "===>", o que inviabilizou o codigo é claro.
		(*)-----> novos testes, passou por 1 linha onde estava a falha no codigo.


[Jogo Invaders]:
		-----> não conseguiu-se achar a variavel que torna o inicio do jogo, quando se atinge todos invaders, num bug que inviabiliza
		o reinicio.

[Jogo InvadersComClasses]:
		(x) -----> por não utilizar classes orquidea E muitas modificações no código, chegou-se a uma instanciação sem
		chamar o construtor! e não foi validado pelo jogo invaders justamente porque é um jogo com classe orquidea.
		(x) -----> parametros nao setados corretamente, não está aparecendo os parâmetros do construtor no escopo.
									----> deixe-me explicar o que aconteceu: no processo de otimização,
									cortou-se um dos escopos, justamente o escopo dos parametros, então
									quando se chamava o construtor orquidea (NAO CONSTRUTOR IMPORTADO),
									os parâmetros não eram passados ao escopo do construtor (orquidea);
									----> na longa pausa de codigo com classes orquidea, foi modificado
									o codigo na tentativa de melhorar o desempenho, sendo que o problema
									estava longe, na execução de operadores (faltou uma lista estática, para otmizar
									o acesso a operadores), E também uma otmização para objetos orquidea em [Vector].

		 (x) -----> faltando o parametro string [pathFileImage], que está setado como uma literal, mas deveria ser parametro do
			construtor.
									-----> a inclusão dos objetos parametros para o escopo da função orquidea- construtor,
									preencheu o valor deste parametro.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 29.05:

[ParserFile]:
		-----> continuar os testes de linhas que falham. no jogo currente (invaders com classes), apontou para uma linha,
		e a linha era justamente a linha do arquivo do jogo. porem, o erro estava em outro lugar, mas vale porque
		era uma linha relacionada a variavel sinalizada na descrição da linha de falha mostrada no depurador do [ParserAFile].


[Jogo Invaders com classes]:
		-----> continuar a codificação.
			classe [Ship]:
				(*) -----> funcao DrawShip,UpdateShip, funcionando.
								-----> com classes, é muito mais lento! mas não está travando. aumentando a velocidade dos invaders,
								talvez melhore o desempenho: com +velocidade, o desempenho melhorou.
				(*) -----> um [Vector] com [Ship], desempenho bem aceitável.
				(*) -----> com o aumento de numero de invaders, o processamento fica mais lento.

			classe [Bullet]:
				criado uma classe [Bullet], para disparos dos invaders.
				adicionado a classe [Ship], um [Vector] bullets, que guarda as bullets atirado pelo Ship currente.
							-----> dificuldade de setar para modo lista o vector de bullets.


[ExpressaoPorClassificacao]:	
		------> falha em expressoes como: actual.prop1.funcaoB();	
							(*)----> nao estava reconhecendo [Append] como funcao de [actual] objeto.
							----> problema no [FileHeader]: não reconhece propriedades como Vector: int[] propVector;
											-----> [FileHeader] certo: está extraindo o tipo, nome, e tipo elemento de [Vector];
							(X)----> não está reconhecendo [Vector] como [WrapperObject].
											(x)-----> sem previsão para propriedades [WrapperObject]! extendeu-se o codigo,
											a previsão inicial não tinha wrappers object.
											(x)-----> falha continua, dando falha nas funcoes de [Vector], combinado
											com [actual].
							(x)----> propriedades aninhadas como: actual.prop1.funcaoB(), nao reconhece.
							
							(x)----> sem previsão para execução de expressoes com objeto [actual] combinado com wrappers object.
							
							(x)----> Clonagem de [Vector] feita com [Objeto.valor];
							

							----> quase lá, não está avaliando uma chamada de metodo combinado com objeto [actual], e
							uma função importada [Clear];
										----> objeto caller da chamada está como tipo=[Objeto], em vez de tipo=[Vector].


[Vector]:
		-----> em uma execução de chamada de metodo de [Vector.Clear()], o objeto caller está como de tipo=[Objeto], deveria
		ser tipo=[Vector];
							-----> verificar em [EvalExpression], [expss.Elementos[x].tipo = ExpressaoChamadaDeMetodo].
							-----> problemas na onde? objeto [actual.propriedade[]]! está como [Objeto] deveria ser [Vector].
										(x)-----> teria que copiar as propriedades da classe currente, para o [actual],
										também no caso de proprieddades WrapperObject.
										(x)-----> nome de propriedade WrapperObject, está sem nome!
										(x)-----> instanciacao de [Objeto], no caso de propriedade wrapper object,
										   não está setando o nome.
										(x)-----> nao esquecer do tipoElemento do wrapper object.
		----> todas falhas clareadas, porém: o elemento vector não é setado, com a função [Vector.Append].
				-----> função [Vector.Clear()] chamado, funcao [Vector.Append()] chamado, estão funcionando,
				porem o [Vector] não está com o tamanho validado, está adicionando o elemento na ultima posicao,
				porem a dimensão deveria estar clareada (count=0).
							 -----> valores não repassados para o escopo!, dentro da funcao construtora orquidea..
				-----> VERIFICAR A EXPRESSAO PROPRIEDADE ANINHADA, não está atualizando o escopo.
							 -----> outro lapso de testes: propriedades aninhadas, seguidas de chamadas de metodos:
							 não testou para isso.
				-----> problemas de Clonagem, de 1 hora para outra, o objeto [actual] perde o resultado da funcao [Vector.Clear()];
				

[Projeto]:
		------> extendeu-se o codigo: propriedades de classes agora podem ser wrapper objects. a previsão anterior era wrapper object
		como objetos dentro de metodos. possibilidades de propriedades como [public Bullet[] bullets] como propriedades..
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 03.06:
	
(*)--->(prioridade)[Metodo]:
				-----> se clonar uma função, copiando inclusivamente o escopo do corpo do metodo, é a melhor solução!
	Porque permite multiplas chamadas de metodo, sem perda de dados. E tem mais: o escopo de sessao do metodo
	pode ser deixado de lado: basta copiar os objetos do escopo externo, direto para o escopo do corpo do metodo,
	não esquecendo o escopo de parametros! otmização.
				-----> para expressao chamada de metodo, clonar a função. Uma função é um objeto,
				porque existe na expressao chamada!

		-----> implementado o clone de metodo em [ExpressaoChamadaDeMetodo].	
		-----> implementando a otimizacao de escopos corpo de metodo.
					------> (x) está repetindo objetos do escopo externo. fixado;
					------> (x) está repetindo os objetos propriedades do objeto actual ou objeto caller.
					------> (x) está removendo também o objeto temporário, mas é algo bom, porque o objeto temporário é virtual, não tem endereço no escopo externo.
									----> (x) tem mais: o objeto temporário é passado para o vector, como um objeto-elemento do vector.
		

		
(*)--->(prioridade)[EvalExpression]:
		(x)------> em expressao propriedade aninhada, quando o objeto caller for [actual], inserir no escopo as propriedades do [actual], porque numa chamada de metodo aninhada,
		é nas propriedade atualizadas do [actual] serão processado, nao o actual!
		Testes:
				-----> a falha continua.
							(x)----> tem que setar os valores de propriedades do actual, com os valores vindo do escopo.
											-----> propriedades atualizadas, a falha continua.
														-----> 1 linha de codigo, 1 linha, quebrou o cenario: o objeto caller não era atualizado, dentro
														da função [Metodo.ExecuteAMethod()], obtendo o valor vindo de actual.valor, mas actual.valor não estava atualizado.

		

(*)---->(anotação)[jogo invaders com vectors]:
			-----> jogo invaders, sem classes, completo, ainda funcionando.
			-----> funcao append, aplicado em [Vectors], sem falha.


(anotação)[jogo invaders com classes]:
		(x) vetor de bullets estava sem tipo de [Bullet]!
		(x) falha fixada relatada acima, é possível atualizar o [Vector] [bullets], sendo [bullets] um vector de objetos orquidea, e como propriedade.
						(x) ----> função actual.bullets.Clear() funcionando, actual.bullets.Append() também.
						----> falha na clonagem de um Vector.
											-----> função [Vector.Append] testada, sem nenhuma falha.
											
						(x) em outro jogo, funcao Append funcionando normalmente.
						(x) -----> modificado o [Vector] de [Ship], para funcionar como um array, resultou sem falhas.
						(x) -----> a falha em [Vector.Append] continua!
										-----> sem essa funcao, fica sem falhas, porem o jogo nao roda,
										apesar de todas funcoes orquidea estarem desativado temporariamente.
													-----> nao está rodando porque não compilou o laço while!
										------> falha na instanciacao de invaders.

		(x)-----> modificacoes feitas hoje quebrou o codigo dos jogos! Não está conseguindo clonar um [Vector]!
							(x)----> não quebrou, apenas a propriedade [Vector] bullets não está sendo instanciada
							como [Vector], mas como [Objeto]!
							(x)----> verificar o [ExtratorOO], funcao [ExtraiPropriedades].
							(x)----> removido a clonagem de [Objeto], não é preciso porque os objetos são únicos.
		(x)-----> voltou o processamento da instrução [while];

[Jogo invaders com classes]:
			-----> outro erro, não a clonagem de objetos em [Tabela.Clone()];
		
[Jogos]:
		(x)-----> modificações quebrou o codigo de todos jogos! regressão para testes de [Vector];
		(x)-----> sanado um erro de logica de programação, codigo modificado hoje, apresentou loop infinito.
						-----> problemas estruturais continua.
										----> novos cenarios, esboço de jogo [invaders com classes] voltou a funcionar,
										porem em outro cenario, a iteração de contagem falhou, ou não está funcionando
										por outro motivo.
								-----> ao que parece, uma 2a. iteração da instrução while está falhando.
										-----> (x) novamente a função escopo bloco falhando, duplicata de objetos.
								-----> falha dentro das instruções do bloco da malha while;
											----> falha na logica do jogo: as coordenadas mudaram de int para double,
											gerando exceção porque os parametros não é do tipo certo!


		-----> codigos de jogos voltou a funcionar.
						-----> tomar cuidado na função [Text.SetText] que exige coordenadas em int, e 
						no desenho de textos, as coordenadas são em double.


[Jogo invaders com classes]:
		-----> continuar o cenario de teste.
					(x)----> o codigo está com falhas demais: 1 hora é uma falha no Append, outra Clear, outra no construtor
					chamado pela 2a. vez.. Até quando? Tirar os creditos estudantis tão penosamente conquistado?
					(x)---->o indice de construtor está correto, na compilação, porém na instrucao create, o indice construtor está
						como -1, ou seja, não encontrou 1 construtor compativel.
									(x)-----> surpresa! o indice do construtor orquidea não funciona, tem que obter nas expressoes
									de [InstrucaoCreateAObject];
					(x)---->função orquidea nao trabalhando! chamada de metodo orquidea está travando o jogo. 
									 (x)----> a falha está em [Metodo.BuildParameters]: 
									  as propriedades aninhadas não está funcionando corretamente...
														-----> (x) codigo que não tem nada a ver, está
														transformando o objeto propriedade em 1 numero!
					(x)-----> a falha agora está na confusão de parametros: [Image] como [Objeto].

					(x) ------> acertar a execução de função importada, em que está lançando erro, justamente por parametro
					[Imagem] ser tratado como [Objeto].
									-----> fixado, mas entrou em loop infinito!
												----> falha na instrucao for, aninhado a instrucao while.
															-----> por alguma razão, está perdendo o valor da variavel de controle
															do loop for, quando se utiliza [Vector] objetos.
															-----> falha em operador unário ++!!!!
															deixou-se para uma manutenção posterior, agora está batendo na porta
															a operação unario.
																		----> está estranho, funciona 1 passada de malha for,
																		depois deixa de incrementar em 1 unidade a variavel.
					(x) SABOTAGEM! Por que querem o controle deste Engenheiro? Controle por controle? controle já é
					uma burrice extrema, mas controle por controlar é uma abominação em termos de evolução!
		
______________________________________________________________________________________________________________________________________
Daily Scrum 04.06:

		
(x) [ParserAFile]:
			------> codificação de uma nova funcao de contar linhas de codigo.
						----> precisa contar os operadores braças de comandos, como while, for, if/else, de
						abertura e fechamento de blocos de comandos.


[Metodo.ExecuteAMethod]:		
		(x)-----> continuando, o acesso a variavel de malha é afetada pela operação de elementos de [Vector]!
							-----> variavel de malha de [Vector] está resetando apos 1 rodada de loop for.
		(x)-----> investigar as chamadas de metodo aninhadas, o case que houve otimizações de [Vector].
		
		(x)-----> após 3 passadas de malha, a imagem muda para vector!
					(x)-----> um codigo obscuro, está transformando a imagem para um vector: escopo.tabela.Update(objCaller)!
		(x)-----> agora todos valores de desenho estão null!



[Jogo Invaders com Vector]:
			(*)-----> codigo compilado, jogo rodando, a tecla [Space] não está acionando o tiro do player..


[Metodo]:
	-----> regressão para um codigo estável.
	-----> valores de parametros não validados, 2 estão resultando em null.
				----> passagem de propriedades no construtor orquidea, invalidados.


[Vector]:
	(x)-----> fixar com o cenario teste, que invallidou o construtor (chamada de método dentro do construtor).
				-----> mesma falha fixado anteriormente: função [Vector.Clear()] não está funcionando corretamente.
								------> 1 função funciona perfeitamente, mas a 2a. função do cenario, não atualiza corretamente.
											-----> 1 linha de codigo com teste se o valor fosse null, invalidou o cenario e o codigo.

[projeto- anotação]:
	------> 2 propriedades aninhadas, seguida de chamada de metoodo, funcionando corretamente. construtor orquidea com [Vector],
	funcionando corretamente.
	
_______________________________________________________________________________________________________________________________________
Daily Scrum 05.06:

(x)[jogo invaders classes]:
	------> alta probabilidade do objeto [actual] da classe orquidea [Ship], ter sido subscrito
	com o [actual] da propriedade Imagem no objeto construido. não é um erro exotérico. 
				-----> vai ser preciso quando obter o objeto [actual], saber o tipo do objeto construido.
				e quando construir, não sobrescrever o objeto [actual], porque senão..
	------> não tem nada a ver! a classe [Imagem] é importado, não tem [Objeto] actual!
	O que está pegando é a criação de uma [Imagem] via uma propriedade aninhada! Verificar a construção
	de instrução [Create], na parte de instanciação via uma propriedade aninhada.
				-----> é isso! no jogo [invaders com Vector], a instanciação de imagens foi feito
				separadamente.
				(*)----> [EvalExpression]: encontrado falha no processamento de atribuicao com proprieades aninhadas,
							que impossibilitava uma atribuição de objeto que herda [Objeto], mas não é [Objeto].
							(x)------> fixado a falha em EvalExpression.
							(x)------> [Imagem] sendo construida, porem não está aparecendo a imagem na tela.
										 (x)-----> construtor em ordem, quase: variaveis double estão com valor null.
													(x)-----> faltou adicionar ao escopo da função orquidea (construtor),
															   a lista de parametros construidos.




				(*)-----> VERIFICAR SE A EXPRESSAO DE ATRIBUIÇÃO comporta atribuição de um [Objeto]
				[Imagem], setando o seu campo [Objeto.valor].
							----> não comporta, mas é possível, setando o campo [Objeto.valor]
							da variavel a atribuir. porque toda classe importada é um [Objeto],
							e isso é uma padronização do projeto.
										(x)------> [EvalExpression][ExpressaoAtribuicao]:
										está setando o valor de uma Imagem, no campo [Objeto.valor],
										fixado o caso de Imagem atribuida a uma propriedade aninhada.




(*)[ParserAFile][contagem de linhas de codigo]:
				-----> incluir no codigo de ProcessamentoDeBlocos, 2 linhas vazias da variavel
				contadora de linhas, para procedimento de contagem de linhas de codigo, verificação 
				de linhas que falharam.
							-----> testes, resultou em validado. programa com classes, metoodos, e instrução for que
							contem blocos, e operadores de abre e fecha blocos.
							-----> mais um teste, validou.
							-----> mais um teste, validou.
							-----> mais um teste, validou.


[jogo invaders com classes]:
	[classe Bullet]:
				 (x)------> inclusão da classe [Bullet].
				 (x)------> inclusão de um vetor de [Bullet], na classe [Ship]. chamada de função Clear e Append sendo feitas.
				 (x)------> ataque de [Ship] operacional. fixado uma chamada de função com propriedades, subsittuindo
				 por um objeto dentro do metodo.
						-----> instanciacao de [Bullet], questionavel: a 1a. chamada do construtor, o construtor está null!



					------> verificar a seguinte expressão: actual.gun[k].Draw(), sendo gun um [Vector].

[EvalExpression],[Vector]:
					(x)------> implementar em propriedades aninhadas, a otimização de [Vector.GetElement]+funcao adicional,
					como esá em chamadas de metodo.
					(x)-----> falha na logica de programação, em [EvalExpression][ExpressaoPropriedadeAninhada].

					[ExpressaoPorClassificacao]:
								------> sem previsão para proprieades aninhadas seguida de 2 chamadas de metodos aninhados!
											-----> sem previsão tb para processamento de wrappers object combinado com objeto actual.
														----> o fato é que a propriedade vector da classe, não está lançada no escopo do metodo.
																	(x)----> falha de logica de programação em [ExtratoresOO][ExtraiPropriedades];
																	(x)----> combinação de objeto actual com objetos wrappers, codificada.


____________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.06:

[Vector]:
		-----> é cruscial ter propriedades [Vector] em classes orquideas, e para dar processamento a estas propriedades, é preciso term 2 propriedades aninhadas,
		seguidas de 2 chamadas de metodo aninhados. Sem [Vector], a codificação de jogos fica muito dificil. COM CODIGO DE CLASSES, O TEMPO DE COMPILAÇÃO DIMINUI
		BASTANTE, PORQUE É SOMENTE 1 VECTOR NO CODIGO, na versão do jogo com [Vectors], há muitos [Vector], o que atrasa bastante o tempo de compilação.

				(x)------> cenario de teste a executar.
				(x)------> sem previsão para objeto [actual] compondo com wrapper objects.
								-----> formação de expressoes GetElement+funcaoAdicional.

					(x)-----> testes de programa, não está instanciando o objeto com função [Append], e 
											(x)----->a propriedade na função adicional está incorreto.
											(x)-----> nao esta reconhecendo o construtor da classe do cenario.
														(x)-----> falha na compilacao: construtor não reconhecido.
											(x)----> funcoes Vector.Clear() e Vector.Append() funcionando!
											(x)----> mas o elemento adicionado ao Vector é null, não foi construido.
					(x)-----> sanado a instanciacao do objeto, a função adicional não está funcionando.			
											   ----> o codigo anterior exigia 1 chamada e +1 chamada como sub-expressao.
											   no codigo atual, e com codigo correto no processamento de chamadas de metodo,
											   ao tentar fazer o mesmo em propriedades aninhadas, ficou sem esta observação.
											
											(x)-----> na fixação deste porém, quebrou o codigo de funções sem funcao adicional!
																	-----> regressão para versão mais estável.

					(x)-----> a funcao adicional está sendo chamada, mas falha. funcoes de [Vector] [Clear()], [Append()], funcionando.
										(x)-----> no modo depuração, as instrucoes da funcao [metodoAdicional] está com nenhuma
										instrução, porem na compilação da classe, consta 1 instrucao no corpo do metodo.
														(x)------> porem as funcoes vector anteriores estão funcionando.


					(x)------> todas funções funcionando corretamente, mas precisa atualizar o objeto caller principal.
										------> o engraçado é que este codigo é muito parecido com o codigo de [EvalExpression.ExpressaoChamadaDeMetodo],
										com a otimização para [Vector].
					(x)------> tinha que atualizar o objeto caller da propriedade aninhada, porque não é igual ao codigo de [EvalExpression.ExpressaoChamadaDeMetodo],
					há um objeto que já vem para setar o valor do processamento...


					(x)------> FALTANDO: atualizar o [Vector] vindo do processamento anterior. PORQUE o teste passou.


[ATIVIDADES restantes]:
   				   (x) ------> fechar o cenario de testes, e suturar a validação do teste (automatização do teste).
				   (x) ------> verificar em jogos se não gerou efeito colateral, mas esta parte do código é somente para classes orquidea. nos jogos,
					está utilizando outros recursos da linguagem, como funções importadas, e vectors.
								(x)-----> cenarios de testes [EvalExpression], feito.
								(x)-----> cenarios de testes [LoopGame]:
											(x) ------> programa contagem, feito.
											(x) ------> programa Invaders com classes, compilou e rodou sem [Vector]s de Bullets. justamente o esforço relatado acima, falhou.

[projeto]:
			------> problemas de desempenho, no jogo com classes. 
			------> não dá para entender: no cenario de teste em [Vector], passou, mas no jogo falha. por que? até quando este joguinho de controle? SABOTAGEM.
							-----> [Vector] propriedade com problema.
										-----> a falha está em [ExtratoresOO.ExtraiMetodos], não tem nada a ver com [Vector] propriedaade.
														-----> erro de compilação no metodo [Ship.UpdateShip].
																	----> erro irracional.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.05:

[Jogo resgate de paraquedistas]:

[COMO JOGAR]:
			-----> Ships de transporte lança paraquedista, sua função é resgatá-los, colidindo com eles com suas nave.
			se 3 paraquedistas não forem resgatados e cairem no chão, o jogo acaba. a cada paraquedista salvo 1 ponto no score.

	
[O jogo]:
		(x)------> entrar na compilacao do codigo na linha de atualização das coordenadas do ship.
					(x) fixado uma falha de logica de programacao: adicionava objetos no processamneto de wrappers object,
					mesmo quando o wrapper object não estivesse presente nos tokens da expressao.
		(x) ----> classe PARAQUEDISTA funcional, [Vector] paraquedista funcional, porem as funcoes [Update,Draw] de PARAQUEDISTA não está funcionando
		corretamente, VERIFICAR com cenario de teste se uma chamada como: actual.paraquedista[x].Update() funciona.
					(x) está funcionando. 


		(x)----> ao que parece, deveria funcionar, como actual.paraquedistas[x].Clear(), deveria ser também
		para um metodo como actual.paraquedistas[x].Update().
					(x)-----> parece que as funções de [PARAQUEDISTA], somente após uma instanciação do paraquedista, colocando em codigo anterior da instanciação,
					funcionou! 
					(x)-----> esforço de combinação [actual]+[Vector]+[funcaoAdicional], foi valido.

		(x)-----> imagens de paraquedista importado de assets comprados LeonardAI.
					(x)-----> imagens de player e tropShip importado, também de assets comprados LeonardAI.
					(x)-----> devido a mudanças do tipo do jogo, foi modificado os nomes dos objetos, retirando invaders, qtdInvaders,
					substituindo por tropShips, qtdShips.
	

(x)[MEDIDAS]:
		(x)-----> (inviavel, precisa ter 1 copia para cada objeto somente) reformular o [JoinEscopos], como apenas adição de objetos.
		(x)-----> instanciar 1 unica vez o [EscopoSessaoDoMetodo], e limpar a lista de objetos.
		(x)-----> retirar a clonagem de objetos na parte final do checklist de atualização de [EscopoExterno].
	
			[Metodo][JoinEscopos]: (não, não clona) verificar urgentemente se está clonando os objetos que se adiciona ao escopo.
						(x)------> esta função não tem sentido: a adição de objetos não precisa de verificar se há
						objetos iguais, porque o escopo final não tem nenhum objeto!

			[Metodo][ExecuteAMethod]:
			(x)------> parte final do procedimento, há clonagem de objetos!
			(x)------> retirar a instanciação do EscopoSessaoDoMetodo: é só limpar a lista de objetos, e instanciar 1 vez.
							(x)-----> instanciação de um escopo a toda iteração, custa caro em termos de desempenho do código.

(x)------> [Vector] propriedades de [Ship] operacional.
			-----> alivio porque o esforço para tornar operacional demandou +1 dia de codificação.
							------> métodos adicionais, funcionando corretamente!

(x)------>[ANOTAÇÃO DE ANDAMENTO do Projeto]:
			-----> expressoes condicionais compostas, para [if] instrução, funcionando corretamente!
			-----> A INSERÇÃO DO OBJETO [actual] confundiu todo planejamento, porque é complexo sua implementação.


(x)----->[EvalExpression]:
			-----> teste de expressao condicional em [if/else], se dá resultado em: if (cond==FALSE){cond=TRUE;}. e verficar se cond=TRUE,
			quando cond inicial com cond=FALSE.
							-----> feito teste. o jogo está trabalhando com [Objeto] actual, talvez haja falha entao.
							-----> feito teste, com classes orquidea, com propriedade boolean. validou.


[game rescue para-gliders](andamento):
			------> o desempenho melhorou bastante, mas no decorrer do tempo, vai perdendo performance. investigar
			se é causado pelo acrescimo de objetos copias, pois a retirada pode não ter sido feito corretamente.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.06:


(x)---->[a novela do objeto actual]:
			-----> a matemática do objeto actual é muito instável. pode falhar. foi concebido na época 
			de [ExpressaoGrupos], onde não se concebia nada além de a.var1, a.var1.funcao1().
			com o foco em [Objeto], percebeu-se e tomou medidas para algo como: var1, var1=var1+1.
			a falha do instável actual foi postergada, mas a complicação está atrapalhando.
			Dito isso, fazer as modificações em [InstrucaoCreate], para lançar no escopo as propriedades
			do objeto orquidea instanciado, e também no ProgramaVM.InstrucaoCreate, para um cenario
			de teste sem o actual, e ver se funciona.
						-----> a prova que o actual não é necessário foi a codificação do jogo invaders com vectors!,
						sem utilização de classes...
				
						-----> passos: manter o codigo atual com [actual], e deixar a opção para mudar para o modo sem actual.
									(x)-----> codificar em SystemInit, uma variavel de modeActual.
						
						
						(x)-----> em [ExtratoresOO], função [ExtraiMethods()], tem que ficar depois de [ExtraiPropriedades], e se a opção [modeActual] tiver setada,
						carregar as propriedades da classe, para a lista de objetos dentro do escopo do corpo do metodo;


						(x)-----> em [Method], função [ExecuteAMehtod], se a opção modeActual estiver setada, num bloco de codigo para carregar as propriedades
						da classe do objeto instanciado, e outro bloco para atualizar as propriedades, vindo do escopo. ambos blocos estarão sob if comando que
						verifica se a [opcaoAtual] estiver setada.
										(x)-------> 1o. já estava codificado.
										(x)-------> testes iniciais em [Vector],[WrapperDataVector], afim de verificar o sistema duplo.
										[Testes]:
												 (x)[constatacao] ------> testes, funcionou, mas não atualizou os dados.
																	(x)------> em construtor, o codigo funcionou corretamente. VERIFICAR no construtor orquidea, em [PrgramVM].
																	(x)-----> está duplicando o codigo das propriedades do objeto caller.
																	(x)-----> faltou atualizar o objeto caller, a partir de suas propriedades atualizadas no escopo. 
																	o objetivo era lançar as propriedades no escopo, e depois de executar a função, repassar
																	estas propriedades atualizadas no escopo, de volta para o objeto caller.



(x)---->[projeto]:
		certo, temos então 2 sistemas de anotar uma classe orquidea: 1 com objetos actual, e outra injetando diretamente as propriedades no escopo, e depois pega-la novamente
		do escopo, desta vez atualizada.
						------> o sistema duplo é porque se o 2o. sistema falhar, é possível continuar o projeto com o 1o. sistema, que é instavel, e pode ocorrer enganos.
										-----> em outro momento, pode-se retirar o 1o. sistema, porque pode ocorrer falhas exotéricas, como confusão quando a multiplos objetos actual.

		------> o 2o. sistema, sem floreios com [actual], é preferido por ser mais simples, e menos processamento, pois com [actual], o procedimento é com propriedades aninhadas,
		em vez de objetos, como o 2o. sistema, sistema mais simples.



(x)-----> jogo catch gliders, codificado para o modo simples sem [actual];
					(x)-------> falha na execução de uma variavel dentro de um bloco if/else;
									(x)------> está esvaziando os objetos do escopo de bloco! numa 2a. passada, não havia nenhum objeto.
					(x) anotação: mudança do sistema de [actual], para sistema mais simples, otimizou o codigo.
			

(x)----->[Instrucao,ProgramVM]:										
			------> revisar todas instrucoes que utilizarm [LoadBloco], e [UnLoadBloco].
						----> escopo de instruções revisados:
								-----> if/else
								-----> for (com escopo trocado em UnLoadBloco);
								-----> cases of use;
								-----> while (com escopo trocado em UnLoadBlocos);
						----->os cenarios de teste não alcançou estes trocas porque se sente o efeito somente com 2 ou mais passadas pela instrução com blocos.
						-----> fixado um erro de logica em [Blocos.Compilar], em [bloco.escopo.tabela.objetos], que numa hora de decidir o que incluiria, incluiu todos objetos,
						do escopo da instrucao E o escopo do bloco.


(*)----->[ParserAFile][linhas de codigo]:
			-----> incluir as sequencias de escape de caracteres: /b /v, /f, ... ver aquivo em [Documentos do Projeto].


(*)---->[Instrucao Create, compilação]:
		(x)------> verificar se a compilação de create comporta: [obj=create(parametros)], e também [tipoObj obj= create(parametros)].
		(x)-----> por um erro de logica de programação, o template: [obj=create(parametros)] não estava sendo compilado corretamente, daí o cuidado em programas de testes. validado
		com um programa de jogo.


(x)---->[projeto]:
		------> o que está fazendo falta! O processamento de propriedades e metodos staticos... há previsão, mas está
sem cenarios de testes.
						------> construir um cenario de testes para propriedades estáticas.
										(x) -----> propriedades estáticas armazenadas em [Escopo.EscopoRoot], e também numa lista de propriedades estáticas na classe de origem,
										mas sem muito utilidade, porque não há como acessar. removido a lista de propriedades estáticas.
										(x) -----> Testes:
													-----> 3x a mesma propriedade estática! Há redudancia no processamento.
																(x)-----> escopo root é o escopo inicial, por isso a duplicação. não há necessidade de registrar a
																expressao da proprieade estatica.
																(x)-----> 2a. duplicação valida, porque o escopo root é o escopo inicial, funciona como o escopo externo.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.06:

(*)----->[projeto]:
				(x)------> pronto para remover o sistema [Objeto actual]. não esquecer de atualizar os cenarios de testes.
				(x)------> atualizar todos programas-texto, com classes no codigo.
				(x) ------> atualizar todos cenarios de testes.
									(x)----> ExpressaoPorClassificacao;
									(x)----> Expressao;
									(x)----> EvalExpression;
									(x)----> Objeto;
									(x)----> ProcessamentoInstrucoes;


[jogo catch gliders]:
		------> utilizar uma propriedade estática para contar os paraquedistas, que chegam ao solo, e os que são resgatados.
							(x) -----> verificar novamente o processamento de propriedade estática. 
							em [EvalExpression][ExpressaoAtribuicao], é guardado no escopo a propriedade,
							deveria ter o valor armazenado na propriedade presente no escopoROOT.
									-----> atribuição feita, no escopo certo. Há 2 objetos, porque o escopoROOT 
									neste caso é o mesmo escopoExterno.

							(x) -----> falha no processamento de propriedade estática: não reconheceu como propriedade.
							verificar em [FileHeader] o formato de propriedade estática.



		------> continuar o codigo, instanciando o player: imagem, handlers de teclado, colisão com paraquedistas.
							(x)-------> falha no processamento de propriedades estáticas.
							(x)------> verificando em [ExpressaoPorClassificacao];				
										(x)(há sim!)-----> tudo certo, não há previsão de operacoes aritmeticas com propriedades estáticas!
													(x)------> VERIFICAR novamente em [ExpressaoPorClassificacao],
													funcao de ProcessamentoOperadores();
													   (x)------> quase lá, um erro de logica de programacao, causa pelo excesso de letras
													   em definicoes de variaveis, objetos, levou a uma falha de processamento de atribuicao com propriedade aninhada.
														(x)------> não está setando a propriedade aninhada, na construcao de expressao de atribuicao.
																		(x)------> nao havia implementação de propriedades estaticas, dentro da
																		funcionalidade de [ExpressaoPorClassificacao.propriedades aninhadas].

														 (x)------> falha quebrou o codigo, e o projeto foi salvo e reinicializado,
														  apagando a regressão para o codigo antes do erro!
																		-----> a falha está no PROCESSAMENTO DE PROPRIEDADE ESTÁTICA.
															(x)------> funcao [SetPropriedadeAninhada] sem previsão para propriedades
															estáticas, incapacitando operacoes com propriedades estaticas.
															(x)------> um problema de logica de programacao:
															ao instanciar um [Objeto], as classes tem que estar compiladas.
															para o caso de não compiladas, tem que instanciar com os [Expressao.header],
															que é o pre-compilador.
																------> quase lá, precisa em SetPropriedadeAninhadas,
																prever o caso de propriedade estática.
																	    ------> falha de natureza malevolo está impedindo o
																		processamento de propriedades estaticas.
																		------> o codigo nao quebrou.

															 (x)------> pareceu-me muito razoável dar ao objeto estatico o nome
															 da propriedade: evita-se conflitos de nomes aleatorios para objetos estaticos.


[projeto]:
		----> classes importadas que precisam de adaptações, como Prompt com xWrite (vector multi-argumento),
		deveriam ficar em uma classe [SytemLinguagem], chamada antes da compilação.



[EvalExpression]:
		-----> REMOVER o processamento de objeto actual, nas expressoes a avaliar.
		-----> fixar com os cenarios:
					[TesteClasseOrquideaComBooleans];


[Testes]:
		------> uma recomendação que faça diferença, seria criar uma lista de Testes, para uma classe, depois dos Testes Unitarios permitirem uma construção sólida.
		------> outra recomendação é deixar um comentário assima da função do teste, a fim de clarear o porque o teste está sendo feito.

		------> uma troca de tecnologias, não é apenas para adquirir uma tecnologia, mas também atualização e otmização de tecnologias já conhecidas!
		e também relativamente ao impacto no lucro, proporcional ao orçamento da pessoa. 
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scum 12.06:

[ExpressaoPorClassificacao]:
		------> testes para operacoes com propriedades estáticas.
						(x)-----> continuando o dia anteiror onde começou a fixar operacoes com propriedades estatica.
						(x)-----> NÃO ESTÁ chegando até a funcao que constroi a atribuicao de propriedade estatica.
										(x)-----> valor da expressao de propriedade aninhada estatica incorreta.
														----> sabotagem POR INFRASOM!
										(x)-----> expressao de atribuicao de propriedade aninhada construida incorretamente.	
	
[jogo catchMeteoros]:						
		(x)-----> regressão para outro codigo, mas a funcionalidade anterior está funcionando.
							-----> sem previsão de propriedades de um elemento de Vector.
							-----> contornado sabe como: por uma propriedade estática.
		(x)-------> inicializacao de propriedade estatica, com atribuicao, funcionando corretamente.
		(x)-------> operacoes com variaveis booleans funcionando corretamente. inclusive sem constantes TRUE,FALSE, apenas a variavel boolean.


		(*)------> chamada de metodo estatic de Input.iskeyDown() INOPERANTE. não dá para movimentar o player.
							-----> está inoperante porque seu valor=null!
											-----> confirmado que a falha está na chamada de função importada! (não executa a função, pois o valor  do caller =null).
															----> 1 LINHA DE CODIGO, estava registrando no escopo root nao no escopo currente, o objeto estático que faz a chamada
															de funcao estatica importado.
								
[projeto]:
		(x)---> VERIFICAR URGENTEMENTE o processamento de expressoes de controle, utilizado em if/else.
							-----> por um excesso de preciosíssimo, foi requerido verificar se o resultado da avaliação da expressao de controle, retornasse null, ou um valor que nao fosse boolean.
							-----> feito um cenario de testes, não se verificou anomalias em expressoes de controle de if/else.

[ParserAFile]:
		(x)----> bloco if/else não estava registrando as linhas de compilação dos operadores de bloco.


[ExpressaoPorClassificacao]:
		-----> investigar o por que de acesso a propriedades estáticas nao está sendo feito.
							-----> está sendo feito, mas a expressao de controle, por ora, não tem previsão de operandos condicionais com propriedades aninhadas,
							que é o caso.
										----->(codigo executando) pode ser contornado se na pilha de operandos, tiver um resultado de propriedades aninhadas, antes
										de validar a expressao condicional, verifique na pilha de operandos algum resultado boolean.
										----->(codigo compilando): verificar qual a falha em propriedades aninhadas, dentro da expressão condicional. 
														----> está dando erro de operador condicional não match com os operandos, o que significa que
														a propriedade estática boolean não está sendo considerado um boolean.

______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.06:

[projeto]:	verificar o acesso a propriedades staticas.
			(x)-----> sensacional! uma propriedade estaticas podem ser manipuladas sem o token da classe: Ship.nave, resumido pode: nave;
			e porque a propriedade estatica esta no escopo externo (escopoTotal, sem escopos dos metodos).
						----->por estar no escopo total, as variaveis estaticas sao sempre visiveis, e nem precisa ser estatica! pode-se retirar o termo estática de proprieades.
			
			(X)-----> valores staticos nulos resultam vem erro em runtime, pois o valor neste caso é setado para a propria proppriedade.
									-----> se em propriedades orquidea tiver o valor como o proprio valor, e a propriedade é um campo de um outro objeto,
									é porque há falha em compilação do codigo.
			(x)-----> propriedades estática como propriedades normais, está funcionando, quando um meteoro atinge a terra e isLanding=TRUE.
				


[Jogo catch meteors]:		
		(x)-----> metodo RectangleCollisions não sendo compilado corretamente.
		-----> uma implementacao é um tempo de jogo, final deste tempo, o jogo acaba e verifica-se o score.


[Jogo invaders]:
		(x)------> fixar o RectangleCollisions, não está funcionando mais metodos estaticos para este caso.
		


[Metodo]:
		-----> conforme observado, na verificação de update em propriedades estáticas, tem que
		estar no [EscopoROOT], E no [EscopoExterno].
					-----> E no codigo, tinha que registrar a propriedade aninhada estática, no 
					[EscopoROOT], E no [Escopo] currente! é por isso que há problemas com operadores:
					o codigo não está conseguindo acessar no [Escopo] currente, a propriedade aninhada estatica registrada.
					Nos teste não acusava nada porque o escopo root e o escopo currente são a mesma coisa.
							-----> propriedade aninhada estática registrada no escopo currente, mas não no escopo root.
							-----> cenario de teste, a instanciacao de propriedade estatica está não em numero, mas o proprio objeto estatico.
					------> OU o tipp de expressao, e o tipo da propriedade estática não está sendo
					instanciado corretamente! Em [ExtratoresOO], verificar se está sendo instanciado
					o tipo da propriedade estática, E na manipulação de objetos propriedades estáticas
					se está setando o objeto estatico, COM O TIPO DA PROPRIEDADE, E NÃO O TIPO DA CLASSE!
					
		checklist:
					-----> registrar a propriedade estática no escopo root.
					-----> verificar se o objeto estático, em [ExpressaoPorClassficacao], está
					com o tipo da propriedade, E nao o tipo da classe. Vai ser precio consultar
					a classe, no RepositorioOO, ou nos Expressao.headers. melhor no headers,o pre-compilador,
					porque previne de problemas de sequencia de classes.
								----> verificando, constatou-se que o carregamento do objeto estatico,
								está separado do carregamento da propriedade!
								
					-----> Em metodo, [Metodo.ExcecutaAMethod()] carregar no [EscopoSessaoDoMetodo],
					as variaveis estáticas. parece que está atualizando depois da chamada da função,
					e não antes da chamada.
					
					
					
[ExpressaoPorClassificacao]:
		-----> falha em operacoes aritmeticas com propriedades estaticas aninhadas, ou também propriedades não estáticas aninhadas.
						-----> falha em operacoes aritmeticas, e condicionais, conforme relatado no dia anterior.

(*)---->[Metodo.ExecutAMethod()]:
				-----> quando se acrescenta o escopo corpo do metodo, verificar se os objetos com mesmo nome,
				estão no escopo externo, se tiver deve-se retira-los do escopo sessao do metodo, e acrescentar
				o objeto do corpo do metodo: isto previne o problema de nomes unicos para objetos, e parametros.
						(x)-----> verificar se os objetos com tipo int,double,ou string estão sendo passados por referencia, ou por
						valor que é o desejado. 
						(x)-----> o que parece é que CADA OBJETO DO JOGO, seja variavel, funcao, OU PARAMETRO, deva ter
						um nome unico! o [Heap] do jogo inteiro é compartilhado, e é global...
						(x)-----> correção feita, e em programa de jogo não resultou em falhas.
______________________________________________________________________________________________________________________________________________________________________________________
Proxima Daily Scrum:

[projeto]:
		-----> ver otimização relatado em seguida.
[projeto]:
		-----> encerramento do projeto: documentacao html. lições aprendidas.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.06:

(x)---> [Escopos]:
		----> e se 1o. adicionarmos os objetos do corpo do metodo, DEPOIS os objetos do escopo externo,
		também vai dar certo; e depois da funcao ser invocada, retirarmos os objetos do corpo do metodo,
		DEPOIS atualizarmos os objetos do escopo externo.
							------> teste unitario, preservou os objetos de mesmo nome nos escopos externo e corpo do metodo.
							
				
(x)-----> estudo de desempenho Dictionary, List.FindIndex  em listas de [Objeto];
		------> creio que não me deixaram terminar o cenario, mas aparentemente, os recursos interirores de List, torna tão rápida quanto dicitonaries.
		isso porque o algoritmo de List contem otimização de elementos mais acessados, inserção, remoção em O(1), etc...


(*)---->[ExpressaoPorClassificacao][Testes2]:
		------> Plano de Testes para propriedades aninhadas.
					------> instanciação de propriedade aninhada. (.)
					------> set de propriedade aninhada, alem do construtor; (.)
					------> tipo de propriedade aninhada. (.)
					------> operações matemáticas, dentre outro, em propriedades aninhadas:  int x=obj1.prop1+obj2.prop2; (.)
		

		------> executando o cenario, afim de resolver as falhas com propriedades estáticas.
					(fixado)------> FALHA NO TESTE, SABE EXATAMENTE ONDE? propriedades aninhadas, não está setando um valor após a instanciação.
					(fixadi)------> expressoes construida, expressao de atribuicao com propriedade aninhada construida. a falha
					está na availiação da expressao, em [EvalExpression].
								---->é, estava mesmo em [EvalExpression]. objeto caller da propriedade setado corretamente,
								fica a questão: atualiza a proprieddade no escopo?.

					------> (fixado) criar cenario de teste para propriedades estáticas, que funciona como propriedade aninhada.
								-----> (fixado) falha expressiva, na compilacao de propriedades estáticas. o compilador não está
								processando definicoes de prpriedades estaticas. a falha está nos headers,
								que está setando como tipo estatica para todas propriedades, quando se tem uma propriedade estatica.
								-----> (fixado) replicada a falha, na classe correta: FileHeader;



[jogo CatchMeteors]:
		------> verificar o por que não está lançando meteoros.
					-----> o jogo está instanciando os meteoros, está atualizando meteoros (funcao update), está chamando a funcao  draw,
						   ----> parametro Meteor.yb, operacional.
						   ---->mas sem andamento de [atingir o planeta], new [destroyed].
										-----> está acusando coordenadas > 700.0, o que não só impede de desenhar, como também não está atualizando a situação do meteoro.

							----> há falha nas variaveis [isDestroyed], [isLanding], mas não justifica a falta de desenho dos meteoros.
							-----> FIXANDO agora as propriedades estáticas [isDeroyed], [isLanding].


(x)---->[ExpressaoPorClassificacao]:
		-----> replicar as condicoes da classe do jogo Meteor, mas com propriedades estaticas.	
					----> teste:
							(fixado)-----> está duplicando a propriedade estática.
									 (fixado)-----> a cada chamada de propriedade estática, está criando um objeto no escopo.
							(fixado) -----> não está setando o valor da propriedade estática.
							(fixado)----> o resultado na outra classe resultou em não processamento, com esta propriedade estatica;
											-----> fechado a automatizacao do cenario de teste.


(x)---->[Metodo.ExecuteAMethod()]:
		(x)------> junção do escop root, que contem as propriedades estaticas do codigo.

[projeto]:
		(x)------> LEMBRAR que: as propriedades estaticas estão no [Escopo.escopoROOT];
					-----> compor em [Metodo.ExecuteAMethod()], a junção com [Escopo.escopoROOT], tomando cuidado
					em não juntar uma propriedade estática, mais de 1 vez.
					-----> com isto feito, modificar a classe Meteor, mas com propriedades estáticas, para seu normal processamento.


		(x)------> SENSACIONAL: havia feito uma funcionalidade de atribuição de valor de propriedade 
		(passivel de avaliar, se incluir objetos com valor null, resultará em um valor null), e nem me lembrei, que pena.
		(x)------> chamada de metodo, tendo como parametro o resultado de uma chamada de metodo, operacional.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.06:


(x)---->[Plano de Testes propriedades aninhadas]
			(x)------> incluir um teste de operacoes matematica, com chamada de metodo + propriedade aninhada.
							

[Jogo catchMeteors]:
			(x)-------> inserir propriedades estáticas para controle do funcionamento de updateMeteor();
			(x)-------> utilizar definicoes de propriedades, com valor atribuido (com valores que possam ser avaliado como uma expressao).
							(x)-----> todas funcionalidades funcionando
							(fixado)----->mas a imagem do meteoro não está sendo desenhado.
										-----> é uma falha só na funcao Draw para desenho da imagem de Meteoro.
														------> problema na instanciacao de um objeto de classe importado.
														------> esta funcao esta dentro de uma funcao orquidea aninhado.				
			(x)-----> funcao Draw aninhado em funcao orquidea, funcionando.

			-----> mas não está dando atualizacao atraves das propriedades estáticas! 
			(x)-----> utilizacao de parametros, em vez de propriedades estáticas, falha na atualizacao dos parametros.
						(x)------> tem que atualizar os parametros, que estão no [escopoExterno], com dados do [EscopoSessaoDoMetodo].
									-----> falha na atualizacao dos parametros.
									-----> verificar se na construcao de parametros, em [Metodo.BuildParameters()],
									está respeitando a regra de [readOnly].
												----> o campo responsavel por PARAMETROS não está sendo utilizado,
												a regra [readOnly] não está sendo respeitada.
(x)---->a conclusão:
		(implementado, testado)vai ter mesmo que implementar [ExpressaoChamadaDeMetodo]+[ExpressaoPropriedadeAninhada].
		é o jeito de se obter o valor de uma propriedade de um elemento de vector.


(*)---->[projeto]: 
			problema: em que inserir os parametros no escopo externo. é uma funcao orquidea chamando outra funcao orquidea, e com seus parametros!
			tem que inserir os parametros da funcao orquidea, para que na proxima funcao orquidea, tenha este parametro também.														
										-----> registrado os parametros no escopo externo, afim de proximas funcoes orquideas, dentro da
										funcao orquidea 1a., esteja disponivel.



(x)---->[Reformular os Load/Unload] de objetos de blocos.
				(fixado)------> o problema está no carregamento/descarregamento de escopos bloco!
								-----> erro de logica de programacao;
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.06:


[Jogo catchMeteors]:
		(x)-----> instanciar propriedades em [Meteor], que demonstre seu estado, como [isDestroyed], [isLanding], e acessar estas propriedades
		em [Ship].
				(x)------> modificações feitas, fixou falhas pelo codigo anterior, compilou sem erros.
				------> testes: os meteoros não estão mudando o estados para [isDestroyer], [isCrashing];
				mesmo setando para 1, teima em não devolver o valor corretamente.
							-----> os estados estão mudando, mas na passagem para vecto[x].x, não atualiza a propriedade x, p.ex.
							(x)construtor de objetos orquidea, funcionando corretamente.


[ExpressaoPorClassificacao]:
			-----> mais testes com vectors.
					-----> conseguiu-se replicar a falha: chamadas de metodos dentro de chamadas de metodos.
								-----> não está construindo corretamente a expressao ChamadaDeMetodo+PropriedadeAninhada.
								-----> construcao de chamada de metodo seguida de chamada de metodo, funcionando corretamente.
					-----> mais testes;
								-----> (feito) nao conforme, codificar codigo de chamada de metodo seguida de propriedade aninhadas,
											------> (A FAZER) acertar em [EvalExpression], chamada de metodo seguida de propriedade aninhadas.



(x)---->(regressao para uma versao mais estavel)
[Metodo.ExecutAMethod()] execução de função orquidea:
			planejamento de carregamento de escopo, função orquidea:
						-----> limpar o escopoSessaoMetodo;
						-----> carregar todo o escopo externo, diretamente. É o maior escopo, daí ser o 1o. a carregar;
						-----> inserir no indice 0, todo o escopoCorpoDoMetodo. precisa ser no indice 0, porque tem a preferencia sobre o escopo externo;
						-----> carregar as propriedades estáticas;
									-----> verificar se há necessidade de carregar os objetos parametros: estão já no escopo.
									para função orquidea, tudo está no escopo.
			depois da execução da função orquidea:
					
						-----> atualizar o objeto caller, e suas propriedades;
						-----> atualizar o escopo externo;
						-----> atualizar os objetos parametros;
			(regressao para uma versao mais estavel)Metodo.JoinEscopos]:
			(x)corrigido uma falha grave, que carregava a ultima versao de objeto: deveria ser o 1a. versao.


(*)---->[ExpressaoPorClassificacao],[EvalExpression]:
		(fixado)-----> acertar em [ExpressaoPorClassificacao],[EvalExpression], o codigo de chamada de metodo seguida de propriedade aninhada.



[projeto]:
		------> propriedades estáticas não operacional.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.06:

[PlanoDeTestes]:
				-------> formular um plano de testes, para chamadas de metodo:
								(x) 1 chamada de metodo;
								(x) operacoes aritmeticas, condicionais (principalmente isso), com chamadas de metodo
								(x) chamadas de metodo em expressoes condicionais if/else;
								(x) chamadas de metodo  com parametro de outra chamada de metodo.
								(x) parametros de umObjeto+umaChamadaDeMetodo, em outra chamada de metodo.
								(x) parametros de um numero,string+ umaChamadaDeMetodo, em outra chamada de metodo.
								(x) parametros 1 chamada de metodo, + 1 objeto ou constante, para outra chamda de metodo.

					-----> com o plano de teste, mais que testes unitarios quando se codifica uma funcionalidade,
					são os testes funcionais final. neste teste, fixou: chamadas de metodo condicionais, chamadas de metodo com parametros
					objeto+outra chamada de metodo, dentre outro.
[PlanoDeTestes]:
				  ------> formular testes com getters/setters combinado com classes orquidea estocada em 1 [Vector];
				  ------> A FACE DA MALDADE: codifica no jogo getters/setters, e eles não compilam. mais depois de um plano
				  de testes, que não corrigiu nada, o codigo estava não modificado, pelo menos nesta parte, e o teste valida!
				  vai entender...


[Jogo catchMeteors]:
		(FIXADO) -----> imagem dos meteoros não está sendo desenhada.
					(constatação salvadora)-----> está sendo desenhada (surgiu um relampejo de imagem, proximo aos ships), mas o meteoro é destruido pouco apos sair do ship.
		(FIXADO) -----> acertar a funcao [RectangleCollison], que está bugando, e destruindo o meteoro logo após sua instanciação.
					
										

		(MEDIDAS DE SEGURANÇA)-----> retirado a musica de fundo: não acreditam que COMPREI ESTA MÚSICA DENTRO DE UM PACOTE DE ASSETS!, se não me engano, de itchio.

______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.06:

(x)---->[jogo catch meteors]:
			(x) -----> acertar a contagem de pontos.
					(FIXADO)----> a contagem de pontos está incorreta, porque cada ship tem uma contagem de pontos.
					teria que ser uma propriedade estática, ou um getter de ships: ship.getPontuacao(), e então somar todas pontuações, de cada ship;


(x)---->[EvalExpression]:
	       (x)verificar se expressao chamadaDeMetodo está retornando um valor, afim de verificar se setters orquidea está operacional.
	
	


(x)---->[plano de testes propriedades estaticas]:
				-----> (fixado) 1 erro de digitação, atrasou em 1,5 horas de codigo, incluindo descanso de almoço.
				-----> (fixado) testes basicos, getters/setters, combinado com propriedades estáticas, passou.
				-----> (fixado) erro de digitação, mais 1 vez: escrever codigo em listas de strings, requer ações redobradas.

(x)---->[plano de testes getters/setters com/sem elementos de vector]:
		(x)---> getters/setters de classes orquidea, operacional para objetos que não elemento de vector.
				 -----> 3 erros de digitação do cenario. sem erros de compilação, mas está invalidando assim mesmo.


[Prompt]:
		-----> verificar a classe, com [Prompt.sWrite] multi-argumento.


[plano de teste chamada de metodo]:

----> casos de condicionais formada por chamadas de metodos e operadores, como >,==,>=, etc..

______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.06:

(x)---->[projeto]:
		------> com cenarios de testes, metodos getter/setter combinados com elementos de vector, operacional.
							------> a principal funcionalidade desejada, getter combinado com elemento de vetor, passou.


(x)---->(implementado)[propriedades estaticas]: só pode haver 1 propriedade estatica, de mesmo tipo e mesmo nome!
No jogo, não deu certo porque não há verificação de instanciação de propriedade estatica!
a solução: não incluir na classe, a propriedade estática: apenas registrar no escopo root, mas NÃO na
classe onde a propriedade estática está..

(x)---->[Erros de codigo]:
		erros de compilação: especificar o tipo de instrução está se tratando, seguido dos tokens da sequencia da instrução.
					----->[BuildInstructions]: especificacao de erros mais preciso, feito.
					----->[ProcessadorIDs]: especificação de erros mais preciso, feito.
					----->[ExpressaoPorClassificacao]: especificacao de erros mais preciso, feito. na mensagem mostra os tokens da sequencia em falha. pois o sistema de linhas de
					erros não está funcionando precisamente, mais aproximadamente a linha, por causa dos tipos de formatacao de arquivos de texto.
					------>[Expressao];

[Prompt.xWrite multi-argumento]:
		----> verificar este metodo, util para formatação de textos a imprimir no terminal.

______________________________________________________________________________________________________________________________________________________________________________________
documentacao:

	   lngLinguagemOrquidea;
	   lngUmaLinguagemComputacional;
	   

classes de bibliotecas importadas implementadas em C Sharp:
		gameLibrary;
		imagem;
		input;
		loopGame;
		mapLevelPixels;
		sound;
		text;
		expressionBase;
		timeGame;
		vector2D;
		
		Archive;
		ClasseDoubleMetodos (biblioteca matematica);
		ClasseString (biblioteca de manipulacao de string);
		Prompt;
		Library;

		
		DictionaryText;
		JaggedArray;
		Matriz;
		MultList;
		Vector;

		WrapperData;
		WrapperDataDictionaryText;
		WrapperDataJaggedArray;
		WrapperDataMatriz;
		WrapperDataVector;

		Escopo;
		EvalExpression;
		ParserUniversal;
		ProcessadorDeIDs;

		Expressao;
		ProcessadorDeID_2 (BuildInstrucoes);
		Instrucao;
		ProgramaEmVM;
		Tokenizer;
		TokenizadroAnyLanguage;
		TabelaDeValores;

		Catings;
		ExtratoresOO;
		ImportadorDeClasses;
		RepositorioDeClassesOO;
		Classe;
		Classificador;

		Aspecto;

		TESTES_DESEMPENHO;

		UtilTokens;

______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.06:

(x)--->[Achive][Library]:
	-----> testes com a biblioteca Archive (processamento de arquivos);
					(x)------> teste via codigo orquidea, feito. foi preciso importar como classe, em LinguagemOrquidea.
					(x)------> novas funcoes em [Archive]: getFullPath, getNameFile,Exists;
					(x)------> modificacoes em Read files funções, para ter como parametro um vector, melhor que retornar um vector,
					que pode dar problemas, em [EvalExpression];

					
(x)--->[Prompt][Library]:					
	(x)testes com Prompt.xWrite: utiliza um vector multi-argumento;

(x)---->[EvalExpression]:
		-----> fixar com os cenarios:
					(x)[TesteExpressaoCondificionalComTrueFalse];
					(x)[TesteObjetosBooleans];
					(x)[TesteClasseOrquideaComBooleans];
					(x)[TestesWrapperObjectsExpressaoAtribuicao];

				-----> 3 cenarios com objetos [TRUE], [FALSE], que foram retirados após modificações de correção de expressoes condicionais,
				e que não tinham sido completamente testados.
				-----> 1 cenario com função com 1 só chamada, dificultando a leitura, apesar de deixar o codigo mais simples. removido a função,
				porque função é para codigo muito repetido.

(x)--->[ExpressaoPorClassificacao]:
		-----> fixar com os cenarios:
					(x)[TestePropriedadeAninhadaSeguidaDePropriedadeAninhada];
					(x)[TesteChamadasDeMetodoAninhadasComWrapperObject];
					(x)[TestesFuncoesAninhadasDictionrayText];
					(x)[TestePropriedadeProtected];
					(x)[TestesPropriedadesAninhadasEchamadasDeMetodo];

					------> muda-se a ordem dos testes, e o 1o. teste passa, mas outros testes problematico, não passam se
					não for o 1o. teste. paciência.

(x)--->[Expressao]:
		-----> testes automatizados feito.

(x)--->[game CatchMeteors]:
		-----> teste feito.
______________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum:
		-----> documentos do projeto feito.